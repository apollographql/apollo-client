## API Report File for "@apollo/client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { ASTNode } from 'graphql';
import type { DocumentNode } from 'graphql';
import type { FieldNode } from 'graphql';
import type { FormattedExecutionResult } from 'graphql';
import type { FragmentDefinitionNode } from 'graphql';
import type { GraphQLFormattedError } from 'graphql';
import type { InlineFragmentNode } from 'graphql';
import type { InteropObservable } from 'rxjs';
import { Observable } from 'rxjs';
import type { Observer } from 'rxjs';
import type * as ReactTypes from 'react';
import type { Subscribable } from 'rxjs';
import type { Subscriber } from 'rxjs';
import type { Subscription } from 'rxjs';
import { Trie } from '@wry/trie';
import { TypedDocumentNode } from '@graphql-typed-document-node/core';
import type { VariableDefinitionNode } from 'graphql';

// Warning: (ae-forgotten-export) The symbol "Modifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "StoreObjectValueMaybeReference" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<Entity[keyof Entity] extends infer Value ? StoreObjectValueMaybeReference<Exclude<Value, undefined>> : never>;

// Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
abstract class ApolloCache implements DataProxy {
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    // (undocumented)
    batch<U>(options: Cache_2.BatchOptions<this, U>): U;
    abstract diff<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: Cache_2.DiffOptions<TData, TVariables>): Cache_2.DiffResult<TData>;
    // (undocumented)
    abstract evict(options: Cache_2.EvictOptions): boolean;
    abstract extract(optimistic?: boolean): unknown;
    // (undocumented)
    fragmentMatches?(fragment: InlineFragmentNode, typename: string): boolean;
    // (undocumented)
    gc(): string[];
    // Warning: (ae-forgotten-export) The symbol "getApolloCacheMemoryInternals" needs to be exported by the entry point index.d.ts
    //
    // @internal
    getMemoryInternals?: typeof getApolloCacheMemoryInternals;
    // Warning: (ae-forgotten-export) The symbol "StoreObject" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // (undocumented)
    lookupFragment(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_2.ModifyOptions<Entity>): boolean;
    // Warning: (ae-forgotten-export) The symbol "Transaction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract performTransaction(transaction: Transaction, optimisticId?: string | null): void;
    // Warning: (ae-forgotten-export) The symbol "OperationVariables" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "Unmasked" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract read<TData = unknown, TVariables = OperationVariables>(query: Cache_2.ReadOptions<TVariables, TData>): Unmasked<TData> | null;
    // (undocumented)
    readFragment<TData = unknown, TVariables = OperationVariables>(options: Cache_2.ReadFragmentOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    // (undocumented)
    readQuery<TData = unknown, TVariables = OperationVariables>(options: Cache_2.ReadQueryOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    // (undocumented)
    recordOptimisticTransaction(transaction: Transaction, optimisticId: string): void;
    // (undocumented)
    abstract removeOptimistic(id: string): void;
    // (undocumented)
    abstract reset(options?: Cache_2.ResetOptions): Promise<void>;
    abstract restore(serializedState: unknown): this;
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
    // (undocumented)
    transformForLink(document: DocumentNode): DocumentNode;
    // (undocumented)
    updateFragment<TData = unknown, TVariables = OperationVariables>(options: Cache_2.UpdateFragmentOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    updateQuery<TData = unknown, TVariables = OperationVariables>(options: Cache_2.UpdateQueryOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    abstract watch<TData = unknown, TVariables = OperationVariables>(watch: Cache_2.WatchOptions<TData, TVariables>): () => void;
    // Warning: (ae-forgotten-export) The symbol "WatchFragmentOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "WatchFragmentResult" needs to be exported by the entry point index.d.ts
    watchFragment<TData = unknown, TVars = OperationVariables>(options: WatchFragmentOptions<TData, TVars>): Observable<WatchFragmentResult<TData>>;
    // Warning: (ae-forgotten-export) The symbol "Reference" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract write<TData = unknown, TVariables = OperationVariables>(write: Cache_2.WriteOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeFragment<TData = unknown, TVariables = OperationVariables>({ id, data, fragment, fragmentName, ...options }: Cache_2.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeQuery<TData = unknown, TVariables = OperationVariables>({ id, data, ...options }: Cache_2.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public
class ApolloClient implements DataProxy {
    // (undocumented)
    __actionHookForDevTools(cb: () => any): void;
    constructor(options: ApolloClientOptions);
    // Warning: (ae-forgotten-export) The symbol "GraphQLRequest" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    __requestRaw(payload: GraphQLRequest): Observable<FormattedExecutionResult>;
    // Warning: (ae-forgotten-export) The symbol "Resolvers" needs to be exported by the entry point index.d.ts
    addResolvers(resolvers: Resolvers | Resolvers[]): void;
    // Warning: (ae-forgotten-export) The symbol "ApolloCache" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    cache: ApolloCache;
    clearStore(): Promise<any[]>;
    // (undocumented)
    get defaultContext(): Partial<DefaultContext>;
    // (undocumented)
    defaultOptions: DefaultOptions;
    // Warning: (ae-forgotten-export) The symbol "DevtoolsOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly devtoolsConfig: DevtoolsOptions;
    // @deprecated (undocumented)
    disableNetworkFetches: never;
    // Warning: (ae-forgotten-export) The symbol "DocumentTransform" needs to be exported by the entry point index.d.ts
    get documentTransform(): DocumentTransform;
    extract(optimistic?: boolean): unknown;
    // Warning: (ae-forgotten-export) The symbol "getApolloClientMemoryInternals" needs to be exported by the entry point index.d.ts
    getMemoryInternals?: typeof getApolloClientMemoryInternals;
    // Warning: (ae-forgotten-export) The symbol "RefetchQueriesInclude" needs to be exported by the entry point index.d.ts
    getObservableQueries(include?: RefetchQueriesInclude): Map<string, ObservableQuery<any>>;
    getResolvers(): Resolvers;
    // Warning: (ae-forgotten-export) The symbol "ApolloLink" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    link: ApolloLink;
    // Warning: (ae-forgotten-export) The symbol "DefaultContext" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "MutationOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "FetchResult" needs to be exported by the entry point index.d.ts
    mutate<TData = unknown, TVariables extends OperationVariables = OperationVariables, TContext extends Record<string, any> = DefaultContext, TCache extends ApolloCache = ApolloCache>(options: MutationOptions<TData, TVariables, TContext>): Promise<FetchResult<MaybeMasked<TData>>>;
    onClearStore(cb: () => Promise<any>): () => void;
    onResetStore(cb: () => Promise<any>): () => void;
    set prioritizeCacheValues(value: boolean);
    get prioritizeCacheValues(): boolean;
    // Warning: (ae-forgotten-export) The symbol "QueryOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ApolloQueryResult" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "MaybeMasked" needs to be exported by the entry point index.d.ts
    query<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: QueryOptions<TVariables, TData>): Promise<ApolloQueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    queryDeduplication: boolean;
    readFragment<T = unknown, TVariables = OperationVariables>(options: DataProxy.Fragment<TVariables, T>, optimistic?: boolean): Unmasked<T> | null;
    readQuery<TData = unknown, TVariables = OperationVariables>(options: DataProxy.Query<TVariables, TData>, optimistic?: boolean): Unmasked<TData> | null;
    reFetchObservableQueries(includeStandby?: boolean): Promise<ApolloQueryResult<any>[]>;
    // Warning: (ae-forgotten-export) The symbol "RefetchQueriesOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "RefetchQueriesResult" needs to be exported by the entry point index.d.ts
    refetchQueries<TCache extends ApolloCache = ApolloCache, TResult = Promise<ApolloQueryResult<any>>>(options: RefetchQueriesOptions<TCache, TResult>): RefetchQueriesResult<TResult>;
    resetStore(): Promise<ApolloQueryResult<any>[] | null>;
    restore(serializedState: unknown): ApolloCache;
    setLink(newLink: ApolloLink): void;
    // Warning: (ae-forgotten-export) The symbol "FragmentMatcher" needs to be exported by the entry point index.d.ts
    setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher): void;
    setResolvers(resolvers: Resolvers | Resolvers[]): void;
    stop(): void;
    // Warning: (ae-forgotten-export) The symbol "SubscriptionOptions" needs to be exported by the entry point index.d.ts
    subscribe<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: SubscriptionOptions<TVariables, TData>): Observable<FetchResult<MaybeMasked<TData>>>;
    // Warning: (ae-forgotten-export) The symbol "ApolloClientOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly typeDefs: ApolloClientOptions["typeDefs"];
    // (undocumented)
    version: string;
    watchFragment<TData = unknown, TVariables = OperationVariables>(options: WatchFragmentOptions<TData, TVariables>): Observable<WatchFragmentResult<TData>>;
    // Warning: (ae-forgotten-export) The symbol "WatchQueryOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ObservableQuery" needs to be exported by the entry point index.d.ts
    watchQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: WatchQueryOptions<TVariables, TData>): ObservableQuery<TData, TVariables>;
    writeFragment<TData = unknown, TVariables = OperationVariables>(options: DataProxy.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    writeQuery<TData = unknown, TVariables = OperationVariables>(options: DataProxy.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public (undocumented)
interface ApolloClientOptions {
    assumeImmutableResults?: boolean;
    cache: ApolloCache;
    // @deprecated
    connectToDevTools?: boolean;
    // (undocumented)
    credentials?: string;
    dataMasking?: boolean;
    // (undocumented)
    defaultContext?: Partial<DefaultContext>;
    defaultOptions?: DefaultOptions;
    devtools?: DevtoolsOptions;
    // (undocumented)
    documentTransform?: DocumentTransform;
    // (undocumented)
    fragmentMatcher?: FragmentMatcher;
    headers?: Record<string, string>;
    link?: ApolloLink;
    name?: string;
    queryDeduplication?: boolean;
    // (undocumented)
    resolvers?: Resolvers | Resolvers[];
    ssrForceFetchDelay?: number;
    ssrMode?: boolean;
    // (undocumented)
    typeDefs?: string | string[] | DocumentNode | DocumentNode[];
    // Warning: (ae-forgotten-export) The symbol "UriFunction" needs to be exported by the entry point index.d.ts
    uri?: string | UriFunction;
    version?: string;
}

// Warning: (ae-forgotten-export) The symbol "ApolloConsumerProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const ApolloConsumer: ReactTypes.FC<ApolloConsumerProps>;

// @public (undocumented)
interface ApolloConsumerProps {
    // Warning: (ae-forgotten-export) The symbol "ApolloClient" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    children: (client: ApolloClient) => ReactTypes.ReactNode;
}

// @public (undocumented)
export interface ApolloContextValue {
    // (undocumented)
    client?: ApolloClient;
    // Warning: (ae-forgotten-export) The symbol "RenderPromises" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    renderPromises?: RenderPromises;
}

// @public (undocumented)
class ApolloLink {
    constructor(request?: RequestHandler);
    // (undocumented)
    static concat(first: ApolloLink | RequestHandler, second: ApolloLink | RequestHandler): ApolloLink;
    // (undocumented)
    concat(next: ApolloLink | RequestHandler): ApolloLink;
    // (undocumented)
    static empty(): ApolloLink;
    // (undocumented)
    static execute(link: ApolloLink, operation: GraphQLRequest): Observable<FetchResult>;
    // Warning: (ae-forgotten-export) The symbol "RequestHandler" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static from(links: (ApolloLink | RequestHandler)[]): ApolloLink;
    // @internal
    getMemoryInternals?: () => unknown;
    // @internal
    readonly left?: ApolloLink;
    // (undocumented)
    protected onError(error: any, observer?: Subscriber<FetchResult>): false | void;
    // Warning: (ae-forgotten-export) The symbol "NextLink" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    request(operation: Operation, forward?: NextLink): Observable<FetchResult> | null;
    // @internal
    readonly right?: ApolloLink;
    // (undocumented)
    setOnError(fn: ApolloLink["onError"]): this;
    // Warning: (ae-forgotten-export) The symbol "Operation" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static split(test: (op: Operation) => boolean, left: ApolloLink | RequestHandler, right?: ApolloLink | RequestHandler): ApolloLink;
    // (undocumented)
    split(test: (op: Operation) => boolean, left: ApolloLink | RequestHandler, right?: ApolloLink | RequestHandler): ApolloLink;
}

// Warning: (ae-forgotten-export) The symbol "ApolloProviderProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const ApolloProvider: ReactTypes.FC<ApolloProviderProps>;

// @public (undocumented)
interface ApolloProviderProps {
    // (undocumented)
    children: ReactTypes.ReactNode | ReactTypes.ReactNode[] | null;
    // (undocumented)
    client: ApolloClient;
}

// @public (undocumented)
interface ApolloQueryResult<T> {
    // (undocumented)
    data: T | undefined;
    // Warning: (ae-forgotten-export) The symbol "ErrorLike" needs to be exported by the entry point index.d.ts
    error?: ErrorLike;
    // (undocumented)
    loading: boolean;
    // Warning: (ae-forgotten-export) The symbol "NetworkStatus" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    networkStatus: NetworkStatus;
    // @deprecated
    partial: boolean;
}

// @public
type AsStoreObject<T extends {
    __typename?: string;
}> = {
    [K in keyof T]: T[K];
};

// @public @deprecated (undocumented)
export type BackgroundQueryHookFetchPolicy = useBackgroundQuery.FetchPolicy;

// @public @deprecated (undocumented)
export type BackgroundQueryHookOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useBackgroundQuery.Options<TVariables>;

// @public (undocumented)
namespace Cache_2 {
    // (undocumented)
    interface BatchOptions<TCache extends ApolloCache, TUpdateResult = void> {
        // (undocumented)
        onWatchUpdated?: (this: TCache, watch: Cache_2.WatchOptions, diff: Cache_2.DiffResult<any>, lastDiff?: Cache_2.DiffResult<any> | undefined) => any;
        // (undocumented)
        optimistic?: string | boolean;
        // (undocumented)
        removeOptimistic?: string;
        // (undocumented)
        update(cache: TCache): TUpdateResult;
    }
    // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface DiffOptions<TData = unknown, TVariables = OperationVariables> extends Omit<ReadOptions<TVariables, TData>, "rootId"> {
    }
    // (undocumented)
    interface EvictOptions {
        // (undocumented)
        args?: Record<string, any>;
        // (undocumented)
        broadcast?: boolean;
        // (undocumented)
        fieldName?: string;
        // (undocumented)
        id?: string;
    }
    // (undocumented)
    interface ModifyOptions<Entity extends Record<string, any> = Record<string, any>> {
        // (undocumented)
        broadcast?: boolean;
        // Warning: (ae-forgotten-export) The symbol "Modifiers" needs to be exported by the entry point index.d.ts
        // Warning: (ae-forgotten-export) The symbol "AllFieldsModifier" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        fields: Modifiers<Entity> | AllFieldsModifier<Entity>;
        // (undocumented)
        id?: string;
        // (undocumented)
        optimistic?: boolean;
    }
    // (undocumented)
    interface ReadOptions<TVariables = OperationVariables, TData = unknown> extends DataProxy.Query<TVariables, TData> {
        // (undocumented)
        optimistic: boolean;
        // (undocumented)
        previousResult?: any;
        // (undocumented)
        returnPartialData?: boolean;
        // (undocumented)
        rootId?: string;
    }
    // (undocumented)
    interface ResetOptions {
        // (undocumented)
        discardWatches?: boolean;
    }
    // (undocumented)
    type WatchCallback<TData = unknown> = (diff: Cache_2.DiffResult<TData>, lastDiff?: Cache_2.DiffResult<TData>) => void;
    // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface WatchOptions<TData = unknown, TVariables = OperationVariables> extends DiffOptions<TData, TVariables> {
        // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        callback: WatchCallback<TData>;
        // (undocumented)
        immediate?: boolean;
        // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        lastDiff?: DiffResult<TData>;
        // (undocumented)
        watcher?: object;
    }
    // (undocumented)
    interface WriteOptions<TData = unknown, TVariables = OperationVariables> extends Omit<DataProxy.Query<TVariables, TData>, "id">, Omit<DataProxy.WriteOptions<TData>, "data"> {
        // (undocumented)
        dataId?: string;
        // (undocumented)
        result: Unmasked<TData>;
    }
    import DiffResult = DataProxy.DiffResult;
    import ReadQueryOptions = DataProxy.ReadQueryOptions;
    import ReadFragmentOptions = DataProxy.ReadFragmentOptions;
    import WriteQueryOptions = DataProxy.WriteQueryOptions;
    import WriteFragmentOptions = DataProxy.WriteFragmentOptions;
    import UpdateQueryOptions = DataProxy.UpdateQueryOptions;
    import UpdateFragmentOptions = DataProxy.UpdateFragmentOptions;
    import Fragment = DataProxy.Fragment;
}

// @public (undocumented)
const enum CacheWriteBehavior {
    // (undocumented)
    FORBID = 0,
    // (undocumented)
    MERGE = 2,
    // (undocumented)
    OVERWRITE = 1
}

// Warning: (ae-forgotten-export) The symbol "StoreValue" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type CanReadFunction = (value: StoreValue) => boolean;

// Warning: (ae-forgotten-export) The symbol "Prettify" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MergeUnions" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExtractByMatchingTypeNames" needs to be exported by the entry point index.d.ts
//
// @public
type CombineByTypeName<T extends {
    __typename?: string;
}> = {
    [TypeName in NonNullable<T["__typename"]>]: Prettify<MergeUnions<ExtractByMatchingTypeNames<T, TypeName>>>;
}[NonNullable<T["__typename"]>];

// Warning: (ae-forgotten-export) The symbol "CombineByTypeName" needs to be exported by the entry point index.d.ts
//
// @public
type CombineIntersection<T> = Exclude<T, {
    __typename?: string;
}> | CombineByTypeName<Extract<T, {
    __typename?: string;
}>>;

// Warning: (ae-forgotten-export) The symbol "IsAny" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Exact" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RemoveIndexSignature" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ContainsFragmentsRefs<TData, Seen = never> = true extends (IsAny<TData>) ? false : TData extends object ? Exact<TData> extends Seen ? false : " $fragmentRefs" extends keyof RemoveIndexSignature<TData> ? true : ContainsFragmentsRefs<TData[keyof TData], Seen | Exact<TData>> : false;

// @public
export function createQueryPreloader(client: ApolloClient): PreloadQueryFunction;

// @public (undocumented)
interface DataMasking {
}

// @public (undocumented)
namespace DataProxy {
    // (undocumented)
    type DiffResult<TData> = {
        result: TData;
        complete: true;
        missing?: never;
        fromOptimisticTransaction?: boolean;
    } | {
        result: DeepPartial<TData> | null;
        complete: false;
        missing?: MissingFieldError;
        fromOptimisticTransaction?: boolean;
    };
    // (undocumented)
    interface Fragment<TVariables, TData> {
        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        id?: string;
        variables?: TVariables;
    }
    // (undocumented)
    interface Query<TVariables, TData> {
        id?: string;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        variables?: TVariables;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface ReadFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData> {
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface ReadQueryOptions<TData, TVariables> extends Query<TVariables, TData> {
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface UpdateFragmentOptions<TData, TVariables> extends Omit<ReadFragmentOptions<TData, TVariables> & WriteFragmentOptions<TData, TVariables>, "data"> {
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface UpdateQueryOptions<TData, TVariables> extends Omit<ReadQueryOptions<TData, TVariables> & WriteQueryOptions<TData, TVariables>, "data"> {
    }
    // (undocumented)
    interface WriteFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData>, WriteOptions<TData> {
    }
    // (undocumented)
    interface WriteOptions<TData> {
        broadcast?: boolean;
        data: Unmasked<TData>;
        overwrite?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface WriteQueryOptions<TData, TVariables> extends Query<TVariables, TData>, WriteOptions<TData> {
    }
}

// @public
interface DataProxy {
    readFragment<TData = unknown, TVariables = OperationVariables>(options: DataProxy.ReadFragmentOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    readQuery<TData = unknown, TVariables = OperationVariables>(options: DataProxy.ReadQueryOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    writeFragment<TData = unknown, TVariables = OperationVariables>(options: DataProxy.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    writeQuery<TData = unknown, TVariables = OperationVariables>(options: DataProxy.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// Warning: (ae-forgotten-export) The symbol "DeepPartialPrimitive" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialReadonlyMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialSet" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialReadonlySet" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepPartial<T> = T extends DeepPartialPrimitive ? T : T extends Map<infer TKey, infer TValue> ? DeepPartialMap<TKey, TValue> : T extends ReadonlyMap<infer TKey, infer TValue> ? DeepPartialReadonlyMap<TKey, TValue> : T extends Set<infer TItem> ? DeepPartialSet<TItem> : T extends ReadonlySet<infer TItem> ? DeepPartialReadonlySet<TItem> : T extends (...args: any[]) => unknown ? T | undefined : T extends object ? T extends (ReadonlyArray<infer TItem>) ? TItem[] extends (T) ? readonly TItem[] extends T ? ReadonlyArray<DeepPartial<TItem | undefined>> : Array<DeepPartial<TItem | undefined>> : DeepPartialObject<T> : DeepPartialObject<T> : unknown;

// @public (undocumented)
type DeepPartialMap<TKey, TValue> = {} & Map<DeepPartial<TKey>, DeepPartial<TValue>>;

// @public (undocumented)
type DeepPartialObject<T extends object> = {
    [K in keyof T]?: DeepPartial<T[K]>;
};

// Warning: (ae-forgotten-export) The symbol "Primitive" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepPartialPrimitive = Primitive | Date | RegExp;

// @public (undocumented)
type DeepPartialReadonlyMap<TKey, TValue> = {} & ReadonlyMap<DeepPartial<TKey>, DeepPartial<TValue>>;

// @public (undocumented)
type DeepPartialReadonlySet<T> = {} & ReadonlySet<DeepPartial<T>>;

// @public (undocumented)
type DeepPartialSet<T> = {} & Set<DeepPartial<T>>;

// @public (undocumented)
interface DefaultContext extends Record<string, any> {
}

// @public (undocumented)
interface DefaultOptions {
    // (undocumented)
    mutate?: Partial<MutationOptions<any, any, any>>;
    // (undocumented)
    query?: Partial<QueryOptions<any, any>>;
    // (undocumented)
    watchQuery?: Partial<WatchQueryOptions<any, any>>;
}

// @public (undocumented)
interface DeleteModifier {
    // (undocumented)
    [_deleteModifier]: true;
}

// @public (undocumented)
const _deleteModifier: unique symbol;

// @public (undocumented)
interface DevtoolsOptions {
    enabled?: boolean;
    name?: string;
}

// @public (undocumented)
type DistributedRequiredExclude<T, U> = T extends any ? Required<T> extends Required<U> ? Required<U> extends Required<T> ? never : T : T : T;

// @public (undocumented)
class DocumentTransform {
    // Warning: (ae-forgotten-export) The symbol "TransformFn" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DocumentTransformOptions" needs to be exported by the entry point index.d.ts
    constructor(transform: TransformFn, options?: DocumentTransformOptions);
    // (undocumented)
    concat(otherTransform: DocumentTransform): DocumentTransform;
    // (undocumented)
    static identity(): DocumentTransform;
    // @internal
    readonly left?: DocumentTransform;
    resetCache(): void;
    // @internal
    readonly right?: DocumentTransform;
    // (undocumented)
    static split(predicate: (document: DocumentNode) => boolean, left: DocumentTransform, right?: DocumentTransform): DocumentTransform & {
        left: DocumentTransform;
        right: DocumentTransform;
    };
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
}

// @public (undocumented)
type DocumentTransformCacheKey = ReadonlyArray<unknown>;

// @public (undocumented)
interface DocumentTransformOptions {
    cache?: boolean;
    // Warning: (ae-forgotten-export) The symbol "DocumentTransformCacheKey" needs to be exported by the entry point index.d.ts
    getCacheKey?: (document: DocumentNode) => DocumentTransformCacheKey | undefined;
}

// @public (undocumented)
enum DocumentType_2 {
    // (undocumented)
    Mutation = 1,
    // (undocumented)
    Query = 0,
    // (undocumented)
    Subscription = 2
}
export { DocumentType_2 as DocumentType }

// @public
interface ErrorLike {
    // (undocumented)
    message: string;
    // (undocumented)
    name: string;
    // (undocumented)
    stack?: string;
}

// @public
type ErrorPolicy = "none" | "ignore" | "all";

// @public (undocumented)
type Exact<in out T> = (x: T) => T;

// Warning: (ae-forgotten-export) The symbol "ExecutionPatchResultBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface ExecutionPatchIncrementalResult<TData = Record<string, any>, TExtensions = Record<string, any>> extends ExecutionPatchResultBase {
    // (undocumented)
    data?: never;
    // (undocumented)
    errors?: never;
    // (undocumented)
    extensions?: never;
    // Warning: (ae-forgotten-export) The symbol "IncrementalPayload" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    incremental?: IncrementalPayload<TData, TExtensions>[];
}

// @public (undocumented)
interface ExecutionPatchInitialResult<TData = Record<string, any>, TExtensions = Record<string, any>> extends ExecutionPatchResultBase {
    // (undocumented)
    data: TData | null | undefined;
    // (undocumented)
    errors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    extensions?: TExtensions;
    // (undocumented)
    incremental?: never;
}

// Warning: (ae-forgotten-export) The symbol "ExecutionPatchInitialResult" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExecutionPatchIncrementalResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ExecutionPatchResult<TData = Record<string, any>, TExtensions = Record<string, any>> = ExecutionPatchInitialResult<TData, TExtensions> | ExecutionPatchIncrementalResult<TData, TExtensions>;

// @public (undocumented)
interface ExecutionPatchResultBase {
    // (undocumented)
    hasNext?: boolean;
}

// @public
type ExtractByMatchingTypeNames<Union extends {
    __typename?: string;
}, TypeName extends string> = Union extends any ? TypeName extends NonNullable<Union["__typename"]> ? Omit<Union, "__typename"> & {
    [K in keyof Union as K extends "__typename" ? K : never]: TypeName;
} : never : never;

// Warning: (ae-forgotten-export) The symbol "FetchMoreQueryOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FetchMoreFunction<TData, TVariables extends OperationVariables> = (fetchMoreOptions: FetchMoreQueryOptions<TVariables, TData> & {
    updateQuery?: (previousQueryResult: Unmasked<TData>, options: {
        fetchMoreResult: Unmasked<TData>;
        variables: TVariables;
    }) => Unmasked<TData>;
}) => Promise<ApolloQueryResult<MaybeMasked<TData>>>;

// @public (undocumented)
interface FetchMoreQueryOptions<TVariables, TData = unknown> {
    // (undocumented)
    context?: DefaultContext;
    query?: DocumentNode | TypedDocumentNode<TData, TVariables>;
    variables?: Partial<TVariables>;
}

// @public
type FetchPolicy = "cache-first" | "network-only" | "cache-only" | "no-cache" | "standby";

// Warning: (ae-forgotten-export) The symbol "SingleExecutionResult" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExecutionPatchResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FetchResult<TData = Record<string, any>, TContext = Record<string, any>, TExtensions = Record<string, any>> = SingleExecutionResult<TData, TContext, TExtensions> | ExecutionPatchResult<TData, TExtensions>;

// @public (undocumented)
interface FieldSpecifier {
    // (undocumented)
    args?: Record<string, any>;
    // (undocumented)
    field?: FieldNode;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    typename?: string;
    // (undocumented)
    variables?: Record<string, any>;
}

// @public
interface FragmentMap {
    // (undocumented)
    [fragmentName: string]: FragmentDefinitionNode;
}

// @public (undocumented)
type FragmentMatcher = (rootValue: any, typeCondition: string, context: any) => boolean;

// @public (undocumented)
type FragmentType<TData> = [
TData
] extends [{
    " $fragmentName"?: infer TKey;
}] ? TKey extends string ? {
    " $fragmentRefs"?: {
        [key in TKey]: TData;
    };
} : never : never;

// Warning: (ae-forgotten-export) The symbol "FragmentType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NoInfer_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type From<TData> = StoreObject | Reference | FragmentType<NoInfer_2<TData>> | string | null;

// @internal
const getApolloCacheMemoryInternals: (() => {
    cache: {
        fragmentQueryDocuments: number | undefined;
    };
}) | undefined;

// @internal
const getApolloClientMemoryInternals: (() => {
    limits: {
        [k: string]: number;
    };
    sizes: {
        cache?: {
            fragmentQueryDocuments: number | undefined;
        } | undefined;
        addTypenameDocumentTransform?: {
            cache: number;
        }[] | undefined;
        inMemoryCache?: {
            executeSelectionSet: number | undefined;
            executeSubSelectedArray: number | undefined;
            maybeBroadcastWatch: number | undefined;
        } | undefined;
        fragmentRegistry?: {
            findFragmentSpreads: number | undefined;
            lookup: number | undefined;
            transform: number | undefined;
        } | undefined;
        print: number | undefined;
        parser: number | undefined;
        canonicalStringify: number | undefined;
        links: unknown[];
        queryManager: {
            getDocumentInfo: number;
            documentTransforms: {
                cache: number;
            }[];
        };
    };
}) | undefined;

// @public (undocumented)
export function getApolloContext(): ReactTypes.Context<ApolloContextValue>;

// @public (undocumented)
interface GraphQLRequest<TVariables = Record<string, any>> {
    // (undocumented)
    context?: DefaultContext;
    // (undocumented)
    extensions?: Record<string, any>;
    // (undocumented)
    operationName?: string;
    // (undocumented)
    query: DocumentNode;
    // (undocumented)
    variables?: TVariables;
}

// @public (undocumented)
export interface IDocumentDefinition {
    // (undocumented)
    name: string;
    // (undocumented)
    type: DocumentType_2;
    // (undocumented)
    variables: ReadonlyArray<VariableDefinitionNode>;
}

// @public (undocumented)
interface IgnoreModifier {
    // (undocumented)
    [_ignoreModifier]: true;
}

// @public (undocumented)
const _ignoreModifier: unique symbol;

// @public (undocumented)
interface IncrementalPayload<TData, TExtensions> {
    // (undocumented)
    data: TData | null;
    // (undocumented)
    errors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    extensions?: TExtensions;
    // (undocumented)
    label?: string;
    // Warning: (ae-forgotten-export) The symbol "Path" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    path: Path;
}

// Warning: (ae-forgotten-export) The symbol "InternalRefetchQueryDescriptor" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RefetchQueriesIncludeShorthand" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type InternalRefetchQueriesInclude = InternalRefetchQueryDescriptor[] | RefetchQueriesIncludeShorthand;

// Warning: (ae-forgotten-export) The symbol "InternalRefetchQueriesResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type InternalRefetchQueriesMap<TResult> = Map<ObservableQuery<any>, InternalRefetchQueriesResult<TResult>>;

// @public (undocumented)
interface InternalRefetchQueriesOptions<TCache extends ApolloCache, TResult> extends Omit<RefetchQueriesOptions<TCache, TResult>, "include"> {
    // Warning: (ae-forgotten-export) The symbol "InternalRefetchQueriesInclude" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    include?: InternalRefetchQueriesInclude;
    // (undocumented)
    removeOptimistic?: string;
}

// @public (undocumented)
type InternalRefetchQueriesResult<TResult> = TResult extends boolean ? Promise<ApolloQueryResult<any>> : TResult;

// Warning: (ae-forgotten-export) The symbol "RefetchQueryDescriptor" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type InternalRefetchQueryDescriptor = RefetchQueryDescriptor | QueryOptions;

// @public (undocumented)
interface InvalidateModifier {
    // (undocumented)
    [_invalidateModifier]: true;
}

// @public (undocumented)
const _invalidateModifier: unique symbol;

// @public (undocumented)
type IsAny<T> = 0 extends 1 & T ? true : false;

// @public (undocumented)
function isReference(obj: any): obj is Reference;

// Warning: (ae-forgotten-export) The symbol "UnionToIntersection" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "UnionForAny" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type IsStrictlyAny<T> = UnionToIntersection<UnionForAny<T>> extends never ? true : false;

// @public @deprecated (undocumented)
export type LazyQueryExecFunction<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useLazyQuery.ExecFunction<TData, TVariables>;

// @public @deprecated (undocumented)
export type LazyQueryHookExecOptions<TVariables extends OperationVariables = OperationVariables> = useLazyQuery.ExecOptions<TVariables>;

// @public @deprecated (undocumented)
export type LazyQueryHookOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useLazyQuery.Options<TData, TVariables>;

// @public @deprecated (undocumented)
export type LazyQueryResult<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useLazyQuery.Result<TData, TVariables>;

// @public @deprecated (undocumented)
export type LazyQueryResultTuple<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useLazyQuery.ResultTuple<TData, TVariables>;

// @public @deprecated (undocumented)
export type LoadableQueryFetchPolicy = useLoadableQuery.FetchPolicy;

// @public @deprecated (undocumented)
export type LoadableQueryHookOptions = useLoadableQuery.Options;

// @public @deprecated (undocumented)
export type LoadQueryFunction<TVariables extends OperationVariables> = useLoadableQuery.LoadQueryFunction<TVariables>;

// @public (undocumented)
class LocalState {
    // Warning: (ae-forgotten-export) The symbol "LocalStateOptions" needs to be exported by the entry point index.d.ts
    constructor({ cache, client, resolvers, fragmentMatcher, }: LocalStateOptions);
    // (undocumented)
    addExportedVariables<TVars extends OperationVariables>(document: DocumentNode, variables?: TVars, context?: {}): Promise<TVars>;
    // (undocumented)
    addResolvers(resolvers: Resolvers | Resolvers[]): void;
    // (undocumented)
    clientQuery(document: DocumentNode): DocumentNode | null;
    // (undocumented)
    getFragmentMatcher(): FragmentMatcher | undefined;
    // (undocumented)
    getResolvers(): Resolvers;
    // (undocumented)
    prepareContext(context?: Record<string, any>): {
        cache: ApolloCache;
        getCacheKey(obj: StoreObject): string | undefined;
    };
    // (undocumented)
    runResolvers<TData>({ document, remoteResult, context, variables, onlyRunForcedResolvers, }: {
        document: DocumentNode | null;
        remoteResult: FetchResult<TData>;
        context?: Record<string, any>;
        variables?: Record<string, any>;
        onlyRunForcedResolvers?: boolean;
    }): Promise<FetchResult<TData>>;
    // (undocumented)
    serverQuery(document: DocumentNode): DocumentNode | null;
    // (undocumented)
    setFragmentMatcher(fragmentMatcher: FragmentMatcher): void;
    // (undocumented)
    setResolvers(resolvers: Resolvers | Resolvers[]): void;
    // (undocumented)
    shouldForceResolvers(document: ASTNode): boolean;
}

// @public (undocumented)
type LocalStateOptions = {
    cache: ApolloCache;
    client?: ApolloClient;
    resolvers?: Resolvers | Resolvers[];
    fragmentMatcher?: FragmentMatcher;
};

// @public (undocumented)
interface LookupOptions {
    // (undocumented)
    query: DocumentNode;
    // (undocumented)
    variables?: OperationVariables;
}

// @public (undocumented)
interface MaskFragmentOptions<TData> {
    // (undocumented)
    data: TData;
    // (undocumented)
    fragment: DocumentNode;
    // (undocumented)
    fragmentName?: string;
}

// @public (undocumented)
interface MaskOperationOptions<TData> {
    // (undocumented)
    data: TData;
    // (undocumented)
    document: DocumentNode;
    // Warning: (ae-forgotten-export) The symbol "WatchQueryFetchPolicy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fetchPolicy?: WatchQueryFetchPolicy;
    // (undocumented)
    id: string;
}

// Warning: (ae-forgotten-export) The symbol "DataMasking" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RemoveMaskedMarker" needs to be exported by the entry point index.d.ts
//
// @public
type MaybeMasked<TData> = DataMasking extends {
    mode: "unmask";
} ? TData extends any ? true extends IsAny<TData> ? TData : TData extends {
    __masked?: true;
} ? Prettify<RemoveMaskedMarker<TData>> : Unmasked<TData> : never : DataMasking extends {
    mode: "preserveTypes";
} ? TData : TData;

// Warning: (ae-forgotten-export) The symbol "CombineIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeObjects<T, U> = Prettify<{
    [k in keyof T]: k extends keyof U ? [
    NonNullable<T[k]>,
    NonNullable<U[k]>
    ] extends ([
    infer TK extends object,
    infer UK extends object
    ]) ? TK extends unknown[] ? UK extends unknown[] ? CombineIntersection<TK[number] | UK[number]>[] | Extract<T[k] | U[k], undefined | null> : T[k] : CombineIntersection<TK | UK> | Extract<T[k] | U[k], undefined | null> : T[k] : T[k];
} & Pick<U, Exclude<keyof U, keyof T>>>;

// Warning: (ae-forgotten-export) The symbol "MergeUnionsAcc" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "takeOneFromUnion" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnions<TUnion> = MergeUnionsAcc<TUnion, takeOneFromUnion<TUnion>, never>;

// Warning: (ae-forgotten-export) The symbol "DistributedRequiredExclude" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MergeObjects" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnionsAcc<TUnion, Curr, Merged> = [
Curr
] extends [never] ? Merged : MergeUnionsAcc<DistributedRequiredExclude<TUnion, Curr>, takeOneFromUnion<DistributedRequiredExclude<TUnion, Curr>>, [
Merged
] extends [never] ? Curr : MergeObjects<Curr, Merged>>;

// @public (undocumented)
class MissingFieldError extends Error {
    constructor(message: string, path: MissingTree | Array<string | number>, query: DocumentNode, variables?: Record<string, any> | undefined);
    // (undocumented)
    readonly message: string;
    // (undocumented)
    readonly missing: MissingTree;
    // Warning: (ae-forgotten-export) The symbol "MissingTree" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly path: MissingTree | Array<string | number>;
    // (undocumented)
    readonly query: DocumentNode;
    // (undocumented)
    readonly variables?: Record<string, any> | undefined;
}

// @public (undocumented)
type MissingTree = string | {
    readonly [key: string]: MissingTree;
};

// Warning: (ae-forgotten-export) The symbol "ModifierDetails" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeleteModifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "InvalidateModifier" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Modifier<T> = (value: T, details: ModifierDetails) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;

// @public (undocumented)
type ModifierDetails = {
    DELETE: DeleteModifier;
    INVALIDATE: InvalidateModifier;
    fieldName: string;
    storeFieldName: string;
    readField: ReadFieldFunction;
    canRead: CanReadFunction;
    isReference: typeof isReference;
    toReference: ToReferenceFunction;
    storage: StorageType;
};

// @public (undocumented)
type Modifiers<T extends Record<string, any> = Record<string, unknown>> = Partial<{
    [FieldName in keyof T]: Modifier<StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>>;
}>;

// Warning: (ae-forgotten-export) The symbol "FetchPolicy" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MutationFetchPolicy = Extract<FetchPolicy, "network-only" | "no-cache">;

// @public @deprecated (undocumented)
export type MutationFunctionOptions<TData = unknown, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache = ApolloCache> = useMutation.MutationFunctionOptions<TData, TVariables, TContext, TCache>;

// @public @deprecated (undocumented)
export type MutationHookOptions<TData = unknown, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache = ApolloCache> = useMutation.Options<TData, TVariables, TContext, TCache>;

// @public (undocumented)
interface MutationOptions<TData = unknown, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache = ApolloCache> {
    awaitRefetchQueries?: boolean;
    context?: TContext;
    // Warning: (ae-forgotten-export) The symbol "ErrorPolicy" needs to be exported by the entry point index.d.ts
    errorPolicy?: ErrorPolicy;
    // Warning: (ae-forgotten-export) The symbol "MutationFetchPolicy" needs to be exported by the entry point index.d.ts
    fetchPolicy?: MutationFetchPolicy;
    keepRootFields?: boolean;
    mutation: DocumentNode | TypedDocumentNode<TData, TVariables>;
    // Warning: (ae-forgotten-export) The symbol "OnQueryUpdated" needs to be exported by the entry point index.d.ts
    onQueryUpdated?: OnQueryUpdated<any>;
    // Warning: (ae-forgotten-export) The symbol "IgnoreModifier" needs to be exported by the entry point index.d.ts
    optimisticResponse?: Unmasked<NoInfer_2<TData>> | ((vars: TVariables, { IGNORE }: {
        IGNORE: IgnoreModifier;
    }) => Unmasked<NoInfer_2<TData>> | IgnoreModifier);
    refetchQueries?: ((result: FetchResult<Unmasked<TData>>) => InternalRefetchQueriesInclude) | InternalRefetchQueriesInclude;
    // Warning: (ae-forgotten-export) The symbol "MutationUpdaterFunction" needs to be exported by the entry point index.d.ts
    update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
    // Warning: (ae-forgotten-export) The symbol "MutationQueryReducersMap" needs to be exported by the entry point index.d.ts
    updateQueries?: MutationQueryReducersMap<TData>;
    variables?: TVariables;
}

// @public (undocumented)
type MutationQueryReducer<T> = (previousResult: Record<string, any>, options: {
    mutationResult: FetchResult<Unmasked<T>>;
    queryName: string | undefined;
    queryVariables: Record<string, any>;
}) => Record<string, any>;

// @public (undocumented)
type MutationQueryReducersMap<T = {
    [key: string]: any;
}> = {
    [queryName: string]: MutationQueryReducer<T>;
};

// @public @deprecated (undocumented)
export type MutationResult<TData = unknown> = useMutation.Result<TData>;

// @public (undocumented)
interface MutationStoreValue {
    // (undocumented)
    error: Error | null;
    // (undocumented)
    loading: boolean;
    // (undocumented)
    mutation: DocumentNode;
    // (undocumented)
    variables: Record<string, any>;
}

// @public @deprecated (undocumented)
export type MutationTuple<TData, TVariables, TContext = DefaultContext, TCache extends ApolloCache = ApolloCache> = useMutation.ResultTuple<TData, TVariables, TContext, TCache>;

// @public (undocumented)
type MutationUpdaterFunction<TData, TVariables, TContext, TCache extends ApolloCache> = (cache: TCache, result: Omit<FetchResult<Unmasked<TData>>, "context">, options: {
    context?: TContext;
    variables?: TVariables;
}) => void;

// @public
enum NetworkStatus {
    error = 8,
    fetchMore = 3,
    loading = 1,
    poll = 6,
    ready = 7,
    refetch = 4,
    setVariables = 2
}

// @public (undocumented)
interface NextFetchPolicyContext<TData, TVariables extends OperationVariables> {
    // (undocumented)
    initialFetchPolicy: WatchQueryFetchPolicy;
    // (undocumented)
    observable: ObservableQuery<TData, TVariables>;
    // (undocumented)
    options: WatchQueryOptions<TVariables, TData>;
    // (undocumented)
    reason: "after-fetch" | "variables-changed";
}

// @public (undocumented)
type NextLink = (operation: Operation) => Observable<FetchResult>;

// @public
type NoInfer_2<T> = [T][T extends any ? 0 : never];

// @public (undocumented)
interface ObservableAndInfo<TData> {
    // (undocumented)
    fromLink: boolean;
    // (undocumented)
    observable: Observable<ApolloQueryResult<TData>>;
}

// @public (undocumented)
class ObservableQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables> implements Subscribable<ApolloQueryResult<MaybeMasked<TData>>>, InteropObservable<ApolloQueryResult<MaybeMasked<TData>>> {
    // (undocumented)
    ["@@observable"]: () => Subscribable<ApolloQueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    [Symbol.observable]: () => Subscribable<ApolloQueryResult<MaybeMasked<TData>>>;
    constructor({ queryManager, queryInfo, options, }: {
        queryManager: QueryManager;
        queryInfo: QueryInfo;
        options: WatchQueryOptions<TVariables, TData>;
    });
    fetchMore<TFetchData = TData, TFetchVars extends OperationVariables = TVariables>(fetchMoreOptions: FetchMoreQueryOptions<TFetchVars, TFetchData> & {
        updateQuery?: (previousQueryResult: Unmasked<TData>, options: {
            fetchMoreResult: Unmasked<TFetchData>;
            variables: TFetchVars;
        }) => Unmasked<TData>;
    }): Promise<ApolloQueryResult<MaybeMasked<TFetchData>>>;
    // (undocumented)
    getCurrentResult(saveAsLastResult?: boolean): ApolloQueryResult<MaybeMasked<TData>>;
    // (undocumented)
    getLastError(variablesMustMatch?: boolean): ErrorLike | undefined;
    // (undocumented)
    getLastResult(variablesMustMatch?: boolean): ApolloQueryResult<TData> | undefined;
    // (undocumented)
    hasObservers(): boolean;
    // (undocumented)
    isDifferentFromLastResult(newResult: ApolloQueryResult<TData>, variables?: TVariables): boolean | undefined;
    // (undocumented)
    readonly options: WatchQueryOptions<TVariables, TData>;
    // (undocumented)
    pipe: Observable<ApolloQueryResult<MaybeMasked<TData>>>["pipe"];
    // (undocumented)
    get query(): TypedDocumentNode<TData, TVariables>;
    // (undocumented)
    readonly queryId: string;
    // (undocumented)
    readonly queryName?: string;
    refetch(variables?: Partial<TVariables>): Promise<ApolloQueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    reobserve(newOptions?: Partial<WatchQueryOptions<TVariables, TData>>, newNetworkStatus?: NetworkStatus): Promise<ApolloQueryResult<MaybeMasked<TData>>>;
    // @internal (undocumented)
    resetDiff(): void;
    // (undocumented)
    resetLastResults(): void;
    // (undocumented)
    setOptions(newOptions: Partial<WatchQueryOptions<TVariables, TData>>): Promise<ApolloQueryResult<MaybeMasked<TData>>>;
    setVariables(variables: TVariables): Promise<ApolloQueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    silentSetOptions(newOptions: Partial<WatchQueryOptions<TVariables, TData>>): void;
    startPolling(pollInterval: number): void;
    stopPolling(): void;
    // (undocumented)
    subscribe: (observer: Partial<Observer<ApolloQueryResult<MaybeMasked<TData>>>> | ((value: ApolloQueryResult<MaybeMasked<TData>>) => void)) => Subscription;
    // Warning: (ae-forgotten-export) The symbol "SubscribeToMoreOptions" needs to be exported by the entry point index.d.ts
    subscribeToMore<TSubscriptionData = TData, TSubscriptionVariables extends OperationVariables = TVariables>(options: SubscribeToMoreOptions<TData, TSubscriptionVariables, TSubscriptionData, TVariables>): () => void;
    // Warning: (ae-forgotten-export) The symbol "UpdateQueryMapFn" needs to be exported by the entry point index.d.ts
    updateQuery(mapFn: UpdateQueryMapFn<TData, TVariables>): void;
    get variables(): TVariables | undefined;
}

// @public @deprecated (undocumented)
export type OnDataOptions<TData = unknown> = useSubscription.OnDataOptions<TData>;

// @public
type OnlyRequiredProperties<T> = {
    [K in keyof T as {} extends Pick<T, K> ? never : K]: T[K];
};

// @public (undocumented)
type OnQueryUpdated<TResult> = (observableQuery: ObservableQuery<any>, diff: Cache_2.DiffResult<any>, lastDiff: Cache_2.DiffResult<any> | undefined) => boolean | TResult;

// @public @deprecated (undocumented)
export type OnSubscriptionDataOptions<TData = unknown> = useSubscription.OnSubscriptionDataOptions<TData>;

// @public (undocumented)
interface Operation {
    // (undocumented)
    extensions: Record<string, any>;
    // (undocumented)
    getContext: () => DefaultContext;
    // (undocumented)
    operationName: string;
    // (undocumented)
    query: DocumentNode;
    // (undocumented)
    setContext: {
        (context: Partial<DefaultContext>): void;
        (updateContext: (previousContext: DefaultContext) => Partial<DefaultContext>): void;
    };
    // (undocumented)
    variables: Record<string, any>;
}

// @public (undocumented)
export function operationName(type: DocumentType_2): string;

// @public (undocumented)
type OperationVariables = Record<string, any>;

// @public (undocumented)
export function parser(document: DocumentNode): IDocumentDefinition;

// @public (undocumented)
export namespace parser {
    var // (undocumented)
    resetCache: () => void;
}

// @public (undocumented)
type Path = ReadonlyArray<string | number>;

// @public
export interface PreloadedQueryRef<TData = unknown, TVariables = unknown> extends QueryRef<TData, TVariables> {
    toPromise(): Promise<PreloadedQueryRef<TData, TVariables>>;
}

// @public (undocumented)
export type PreloadQueryFetchPolicy = Extract<WatchQueryFetchPolicy, "cache-first" | "network-only" | "no-cache" | "cache-and-network">;

// @public
export interface PreloadQueryFunction {
    // Warning: (ae-forgotten-export) The symbol "PreloadQueryOptionsArg" needs to be exported by the entry point index.d.ts
    <TData, TVariables extends OperationVariables, TOptions extends Omit<PreloadQueryOptions, "variables">>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, ...[options]: PreloadQueryOptionsArg<NoInfer_2<TVariables>, TOptions>): PreloadedQueryRef<TOptions["errorPolicy"] extends "ignore" | "all" ? TOptions["returnPartialData"] extends true ? DeepPartial<TData> | undefined : TData | undefined : TOptions["returnPartialData"] extends true ? DeepPartial<TData> : TData, TVariables>;
    <TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: PreloadQueryOptions<NoInfer_2<TVariables>> & {
        returnPartialData: true;
        errorPolicy: "ignore" | "all";
    }): PreloadedQueryRef<DeepPartial<TData> | undefined, TVariables>;
    <TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: PreloadQueryOptions<NoInfer_2<TVariables>> & {
        errorPolicy: "ignore" | "all";
    }): PreloadedQueryRef<TData | undefined, TVariables>;
    <TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: PreloadQueryOptions<NoInfer_2<TVariables>> & {
        returnPartialData: true;
    }): PreloadedQueryRef<DeepPartial<TData>, TVariables>;
    <TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, ...[options]: PreloadQueryOptionsArg<NoInfer_2<TVariables>>): PreloadedQueryRef<TData, TVariables>;
}

// Warning: (ae-forgotten-export) The symbol "VariablesOption" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type PreloadQueryOptions<TVariables extends OperationVariables = OperationVariables> = {
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    fetchPolicy?: PreloadQueryFetchPolicy;
    returnPartialData?: boolean;
    refetchWritePolicy?: RefetchWritePolicy;
} & VariablesOption<TVariables>;

// Warning: (ae-forgotten-export) The symbol "OnlyRequiredProperties" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type PreloadQueryOptionsArg<TVariables extends OperationVariables, TOptions = unknown> = [TVariables] extends [never] ? [
options?: PreloadQueryOptions<never> & TOptions
] : {} extends OnlyRequiredProperties<TVariables> ? [
options?: PreloadQueryOptions<NoInfer_2<TVariables>> & Omit<TOptions, "variables">
] : [
options: PreloadQueryOptions<NoInfer_2<TVariables>> & Omit<TOptions, "variables">
];

// @public (undocumented)
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};

// @public (undocumented)
type Primitive = null | undefined | string | number | boolean | symbol | bigint;

// @public (undocumented)
const QUERY_REF_BRAND: unique symbol;

// @public (undocumented)
interface QueryData {
    // (undocumented)
    fetchData(): Promise<void>;
    // (undocumented)
    getOptions(): any;
}

// @public @deprecated (undocumented)
export type QueryHookOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useQuery.Options<TData, TVariables>;

// @public (undocumented)
class QueryInfo {
    constructor(queryManager: QueryManager, queryId?: string);
    // (undocumented)
    document: DocumentNode | null;
    // (undocumented)
    getDiff(): Cache_2.DiffResult<any>;
    // (undocumented)
    init(query: {
        document: DocumentNode;
        variables: Record<string, any> | undefined;
        observableQuery?: ObservableQuery<any, any>;
        lastRequestId?: number;
    }): this;
    // (undocumented)
    lastRequestId: number;
    // Warning: (ae-forgotten-export) The symbol "QueryListener" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    listeners: Set<QueryListener>;
    // Warning: (ae-forgotten-export) The symbol "CacheWriteBehavior" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    markResult<T>(result: FetchResult<T>, document: DocumentNode, options: Pick<WatchQueryOptions, "variables" | "fetchPolicy" | "errorPolicy">, cacheWriteBehavior: CacheWriteBehavior): void;
    // (undocumented)
    notify(): void;
    // (undocumented)
    readonly observableQuery: ObservableQuery<any, any> | null;
    // (undocumented)
    readonly queryId: string;
    // (undocumented)
    reset(): void;
    // (undocumented)
    resetDiff(): void;
    // (undocumented)
    resetLastWrite(): void;
    // (undocumented)
    setDiff(diff: Cache_2.DiffResult<any> | null): void;
    // (undocumented)
    setObservableQuery(oq: ObservableQuery<any, any> | null): void;
    // (undocumented)
    stop(): void;
    // (undocumented)
    stopped: boolean;
    // (undocumented)
    variables?: Record<string, any>;
}

// @public (undocumented)
type QueryListener = (queryInfo: QueryInfo) => void;

// @public (undocumented)
class QueryManager {
    // Warning: (ae-forgotten-export) The symbol "QueryManagerOptions" needs to be exported by the entry point index.d.ts
    constructor(options: QueryManagerOptions);
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    // (undocumented)
    broadcastQueries(): void;
    // (undocumented)
    cache: ApolloCache;
    // (undocumented)
    clearStore(options?: Cache_2.ResetOptions): Promise<void>;
    // (undocumented)
    readonly dataMasking: boolean;
    // (undocumented)
    readonly defaultContext: Partial<DefaultContext>;
    // Warning: (ae-forgotten-export) The symbol "DefaultOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    defaultOptions: DefaultOptions;
    // (undocumented)
    readonly documentTransform: DocumentTransform;
    // (undocumented)
    protected fetchCancelFns: Map<string, (error: any) => any>;
    // Warning: (ae-forgotten-export) The symbol "ObservableAndInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fetchObservableWithInfo<TData, TVars extends OperationVariables>(queryId: string, options: WatchQueryOptions<TVars, TData>, networkStatus?: NetworkStatus, query?: DocumentNode | TypedDocumentNode<TData, TVars>, emitLoadingState?: boolean): ObservableAndInfo<TData>;
    // (undocumented)
    fetchQuery<TData, TVars extends OperationVariables>(queryId: string, options: WatchQueryOptions<TVars, TData>, networkStatus?: NetworkStatus): Promise<ApolloQueryResult<TData>>;
    // (undocumented)
    generateMutationId(): string;
    // (undocumented)
    generateQueryId(): string;
    // (undocumented)
    generateRequestId(): number;
    // Warning: (ae-forgotten-export) The symbol "TransformCacheEntry" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getDocumentInfo(document: DocumentNode): TransformCacheEntry;
    // Warning: (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getLocalState(): LocalState;
    // (undocumented)
    getObservableQueries(include?: InternalRefetchQueriesInclude): Map<string, ObservableQuery<any, OperationVariables>>;
    // (undocumented)
    protected inFlightLinkObservables: Trie<{
        observable?: Observable<FetchResult<any>>;
    }>;
    // (undocumented)
    link: ApolloLink;
    // (undocumented)
    markMutationOptimistic<TData, TVariables extends OperationVariables, TContext, TCache extends ApolloCache>(optimisticResponse: any, mutation: {
        mutationId: string;
        document: DocumentNode;
        variables?: TVariables;
        fetchPolicy?: MutationFetchPolicy;
        errorPolicy: ErrorPolicy;
        context?: TContext;
        updateQueries: UpdateQueries<TData>;
        update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
        keepRootFields?: boolean;
    }): boolean;
    // (undocumented)
    markMutationResult<TData, TVariables extends OperationVariables, TContext, TCache extends ApolloCache>(mutation: {
        mutationId: string;
        result: FetchResult<TData>;
        document: DocumentNode;
        variables?: TVariables;
        fetchPolicy?: MutationFetchPolicy;
        errorPolicy: ErrorPolicy;
        context?: TContext;
        updateQueries: UpdateQueries<TData>;
        update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
        awaitRefetchQueries?: boolean;
        refetchQueries?: InternalRefetchQueriesInclude;
        removeOptimistic?: string;
        onQueryUpdated?: OnQueryUpdated<any>;
        keepRootFields?: boolean;
    }, cache?: ApolloCache): Promise<FetchResult<TData>>;
    // Warning: (ae-forgotten-export) The symbol "MaskFragmentOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>): TData;
    // Warning: (ae-forgotten-export) The symbol "MaskOperationOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    maskOperation<TData = unknown>(options: MaskOperationOptions<TData>): MaybeMasked<TData>;
    // (undocumented)
    mutate<TData, TVariables extends OperationVariables, TContext extends Record<string, any>, TCache extends ApolloCache>({ mutation, variables, optimisticResponse, updateQueries, refetchQueries, awaitRefetchQueries, update: updateWithProxyFn, onQueryUpdated, fetchPolicy, errorPolicy, keepRootFields, context, }: MutationOptions<TData, TVariables, TContext>): Promise<FetchResult<MaybeMasked<TData>>>;
    // (undocumented)
    mutationStore?: {
        [mutationId: string]: MutationStoreValue;
    };
    prioritizeCacheValues: boolean;
    // (undocumented)
    query<TData, TVars extends OperationVariables = OperationVariables>(options: QueryOptions<TVars, TData>, queryId?: string): Promise<ApolloQueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    reFetchObservableQueries(includeStandby?: boolean): Promise<ApolloQueryResult<any>[]>;
    // Warning: (ae-forgotten-export) The symbol "InternalRefetchQueriesOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "InternalRefetchQueriesMap" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    refetchQueries<TResult>({ updateCache, include, optimistic, removeOptimistic, onQueryUpdated, }: InternalRefetchQueriesOptions<ApolloCache, TResult>): InternalRefetchQueriesMap<TResult>;
    // (undocumented)
    removeQuery(queryId: string): void;
    // (undocumented)
    setObservableQuery(observableQuery: ObservableQuery<any, any>): void;
    // (undocumented)
    readonly ssrMode: boolean;
    // (undocumented)
    startGraphQLSubscription<TData = unknown>(options: SubscriptionOptions): Observable<FetchResult<TData>>;
    stop(): void;
    // (undocumented)
    stopQuery(queryId: string): void;
    // (undocumented)
    transform(document: DocumentNode): DocumentNode;
    // (undocumented)
    watchQuery<T, TVariables extends OperationVariables = OperationVariables>(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables>;
}

// @public (undocumented)
interface QueryManagerOptions {
    // (undocumented)
    assumeImmutableResults: boolean;
    // (undocumented)
    cache: ApolloCache;
    // (undocumented)
    clientAwareness: Record<string, string>;
    // (undocumented)
    dataMasking: boolean;
    // (undocumented)
    defaultContext: Partial<DefaultContext> | undefined;
    // (undocumented)
    defaultOptions: DefaultOptions;
    // (undocumented)
    documentTransform: DocumentTransform | null | undefined;
    // (undocumented)
    link: ApolloLink;
    // (undocumented)
    localState: LocalState;
    // (undocumented)
    onBroadcast: undefined | (() => void);
    // (undocumented)
    queryDeduplication: boolean;
    // (undocumented)
    ssrMode: boolean;
}

// @public
interface QueryOptions<TVariables = OperationVariables, TData = unknown> {
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    fetchPolicy?: FetchPolicy;
    notifyOnNetworkStatusChange?: boolean;
    pollInterval?: number;
    query: DocumentNode | TypedDocumentNode<TData, TVariables>;
    returnPartialData?: boolean;
    variables?: TVariables;
}

// @public
export interface QueryRef<TData = unknown, TVariables = unknown> {
    // @internal (undocumented)
    [QUERY_REF_BRAND]?(variables: TVariables): TData;
}

// @public @deprecated (undocumented)
export interface QueryReference<TData = unknown, TVariables = unknown> extends QueryRef<TData, TVariables> {
    // @deprecated (undocumented)
    toPromise?: unknown;
}

// @public @deprecated (undocumented)
export type QueryResult<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useQuery.Result<TData, TVariables>;

// @public (undocumented)
type ReactiveListener<T> = (value: T) => any;

// @public (undocumented)
interface ReactiveVar<T> {
    // (undocumented)
    (newValue?: T): T;
    // (undocumented)
    attachCache(cache: ApolloCache): this;
    // (undocumented)
    forgetCache(cache: ApolloCache): boolean;
    // Warning: (ae-forgotten-export) The symbol "ReactiveListener" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    onNextChange(listener: ReactiveListener<T>): () => void;
}

// @public (undocumented)
interface ReadFieldFunction {
    // Warning: (ae-forgotten-export) The symbol "ReadFieldOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "SafeReadonly" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;
    // (undocumented)
    <V = StoreValue>(fieldName: string, from?: StoreObject | Reference): SafeReadonly<V> | undefined;
}

// Warning: (ae-forgotten-export) The symbol "FieldSpecifier" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface ReadFieldOptions extends FieldSpecifier {
    // (undocumented)
    from?: StoreObject | Reference;
}

// @public (undocumented)
interface Reference {
    // (undocumented)
    readonly __ref: string;
}

// @public (undocumented)
type RefetchFunction<TData, TVariables extends OperationVariables> = ObservableQuery<TData, TVariables>["refetch"];

// @public (undocumented)
type RefetchQueriesInclude = RefetchQueryDescriptor[] | RefetchQueriesIncludeShorthand;

// @public (undocumented)
type RefetchQueriesIncludeShorthand = "all" | "active";

// @public (undocumented)
interface RefetchQueriesOptions<TCache extends ApolloCache, TResult> {
    // (undocumented)
    include?: RefetchQueriesInclude;
    // (undocumented)
    onQueryUpdated?: OnQueryUpdated<TResult> | null;
    // (undocumented)
    optimistic?: boolean;
    // (undocumented)
    updateCache?: (cache: TCache) => void;
}

// Warning: (ae-forgotten-export) The symbol "IsStrictlyAny" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type RefetchQueriesPromiseResults<TResult> = IsStrictlyAny<TResult> extends true ? any[] : TResult extends boolean ? ApolloQueryResult<any>[] : TResult extends PromiseLike<infer U> ? U[] : TResult[];

// Warning: (ae-forgotten-export) The symbol "RefetchQueriesPromiseResults" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface RefetchQueriesResult<TResult> extends Promise<RefetchQueriesPromiseResults<TResult>> {
    // (undocumented)
    queries: ObservableQuery<any>[];
    // (undocumented)
    results: InternalRefetchQueriesResult<TResult>[];
}

// @public (undocumented)
type RefetchQueryDescriptor = string | DocumentNode;

// @public (undocumented)
type RefetchWritePolicy = "merge" | "overwrite";

// @public (undocumented)
type RemoveFragmentName<T> = T extends any ? Omit<T, " $fragmentName"> : T;

// @public (undocumented)
type RemoveIndexSignature<T> = {
    [K in keyof T as string extends K ? never : number extends K ? never : symbol extends K ? never : K]: T[K];
};

// @public (undocumented)
type RemoveMaskedMarker<T> = Omit<T, "__masked">;

// @public (undocumented)
class RenderPromises {
    // (undocumented)
    addObservableQueryPromise<TData, TVariables extends OperationVariables>(obsQuery: ObservableQuery<TData, TVariables>): ReactTypes.ReactNode;
    // Warning: (ae-forgotten-export) The symbol "QueryData" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    addQueryPromise(queryInstance: QueryData, finish?: () => ReactTypes.ReactNode): ReactTypes.ReactNode;
    // (undocumented)
    consumeAndAwaitPromises(): Promise<any[]>;
    // Warning: (ae-forgotten-export) The symbol "LookupOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getSSRObservable<TData, TVariables extends OperationVariables>(props: LookupOptions): ObservableQuery<TData, TVariables> | null;
    // (undocumented)
    hasPromises(): boolean;
    // (undocumented)
    registerSSRObservable<TData, TVariables extends OperationVariables>(observable: ObservableQuery<any, TVariables>): void;
    // (undocumented)
    stop(): void;
}

// @public (undocumented)
type RequestHandler = (operation: Operation, forward: NextLink) => Observable<FetchResult> | null;

// @public (undocumented)
type ResetFunction = () => void;

// @public (undocumented)
type Resolver = (rootValue?: any, args?: any, context?: any, info?: {
    field: FieldNode;
    fragmentMap: FragmentMap;
}) => any;

// @public (undocumented)
interface Resolvers {
    // (undocumented)
    [key: string]: {
        [field: string]: Resolver;
    };
}

// @public (undocumented)
type SafeReadonly<T> = T extends object ? Readonly<T> : T;

// @public (undocumented)
interface SingleExecutionResult<TData = Record<string, any>, TContext = DefaultContext, TExtensions = Record<string, any>> {
    // (undocumented)
    context?: TContext;
    // (undocumented)
    data?: TData | null;
    // (undocumented)
    errors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    extensions?: TExtensions;
}

// @public (undocumented)
export type SkipToken = typeof skipToken;

// @public (undocumented)
export const skipToken: unique symbol;

// @public (undocumented)
type StorageType = Record<string, any>;

// @public (undocumented)
interface StoreObject {
    // (undocumented)
    [storeFieldName: string]: StoreValue;
    // (undocumented)
    __typename?: string;
}

// Warning: (ae-forgotten-export) The symbol "AsStoreObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type StoreObjectValueMaybeReference<StoreVal> = StoreVal extends Array<Record<string, any>> ? StoreVal extends Array<infer Item> ? [
Item
] extends [Record<string, any>] ? ReadonlyArray<AsStoreObject<Item> | Reference> : never : never : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference : StoreVal;

// @public (undocumented)
type StoreValue = number | string | string[] | Reference | Reference[] | null | undefined | void | Object;

// @public (undocumented)
interface SubscribeToMoreFunction<TData, TVariables extends OperationVariables = OperationVariables> {
    // (undocumented)
    <TSubscriptionData = TData, TSubscriptionVariables extends OperationVariables = TVariables>(options: SubscribeToMoreOptions<TData, TSubscriptionVariables, TSubscriptionData, TVariables>): () => void;
}

// @public (undocumented)
interface SubscribeToMoreOptions<TData = unknown, TSubscriptionVariables extends OperationVariables = OperationVariables, TSubscriptionData = TData, TVariables extends OperationVariables = TSubscriptionVariables> {
    // (undocumented)
    context?: DefaultContext;
    // (undocumented)
    document: DocumentNode | TypedDocumentNode<TSubscriptionData, TSubscriptionVariables>;
    // (undocumented)
    onError?: (error: Error) => void;
    // Warning: (ae-forgotten-export) The symbol "SubscribeToMoreUpdateQueryFn" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    updateQuery?: SubscribeToMoreUpdateQueryFn<TData, TVariables, TSubscriptionData>;
    // (undocumented)
    variables?: TSubscriptionVariables;
}

// @public (undocumented)
type SubscribeToMoreUpdateQueryFn<TData = unknown, TVariables extends OperationVariables = OperationVariables, TSubscriptionData = TData> = {
    (
    unsafePreviousData: Unmasked<TData>, options: UpdateQueryOptions<TData, TVariables> & {
        subscriptionData: {
            data: Unmasked<TSubscriptionData>;
        };
    }): Unmasked<TData> | void;
};

// @public @deprecated (undocumented)
export type SubscriptionHookOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useSubscription.Options<TData, TVariables>;

// @public (undocumented)
interface SubscriptionOptions<TVariables = OperationVariables, TData = unknown> {
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    extensions?: Record<string, any>;
    fetchPolicy?: FetchPolicy;
    query: DocumentNode | TypedDocumentNode<TData, TVariables>;
    variables?: TVariables;
}

// @public @deprecated (undocumented)
export type SubscriptionResult<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useSubscription.Result<TData, TVariables>;

// @public @deprecated (undocumented)
export type SuspenseQueryHookFetchPolicy = useSuspenseQuery.FetchPolicy;

// @public @deprecated (undocumented)
export type SuspenseQueryHookOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useSuspenseQuery.Options<TVariables>;

// Warning: (ae-forgotten-export) The symbol "unionToIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type takeOneFromUnion<T> = unionToIntersection<T extends T ? (x: T) => 0 : never> extends ((x: infer U) => 0) ? U : never;

// @public (undocumented)
type ToReferenceFunction = (objOrIdOrRef: StoreObject | string | Reference, mergeIntoStore?: boolean) => Reference | undefined;

// @public (undocumented)
type Transaction = (c: ApolloCache) => void;

// @public (undocumented)
interface TransformCacheEntry {
    // (undocumented)
    asQuery: DocumentNode;
    // (undocumented)
    clientQuery: DocumentNode | null;
    // (undocumented)
    defaultVars: OperationVariables;
    // (undocumented)
    hasClientExports: boolean;
    // (undocumented)
    hasForcedResolvers: boolean;
    // (undocumented)
    hasNonreactiveDirective: boolean;
    // (undocumented)
    nonReactiveQuery: DocumentNode;
    // (undocumented)
    serverQuery: DocumentNode | null;
}

// @public (undocumented)
type TransformFn = (document: DocumentNode) => DocumentNode;

// @public (undocumented)
type UnionForAny<T> = T extends never ? "a" : 1;

// @public (undocumented)
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

// @public (undocumented)
type unionToIntersection<T> = (T extends unknown ? (x: T) => unknown : never) extends ((x: infer U) => unknown) ? U : never;

// Warning: (ae-forgotten-export) The symbol "ContainsFragmentsRefs" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "UnwrapFragmentRefs" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RemoveFragmentName" needs to be exported by the entry point index.d.ts
//
// @public
type Unmasked<TData> = true extends IsAny<TData> ? TData : TData extends object ? true extends ContainsFragmentsRefs<TData> ? UnwrapFragmentRefs<RemoveMaskedMarker<RemoveFragmentName<TData>>> : TData : TData;

// @public (undocumented)
type UnwrapFragmentRefs<TData> = true extends IsAny<TData> ? TData : TData extends any ? TData extends Primitive ? TData : string extends keyof TData ? TData : keyof TData extends never ? TData : TData extends {
    " $fragmentRefs"?: infer FragmentRefs;
} ? UnwrapFragmentRefs<CombineIntersection<Omit<TData, " $fragmentRefs"> | RemoveFragmentName<NonNullable<NonNullable<FragmentRefs>[keyof NonNullable<FragmentRefs>]>>>> : TData extends object ? {
    [K in keyof TData]: UnwrapFragmentRefs<TData[K]>;
} : TData : never;

// @public (undocumented)
type UpdateQueries<TData> = MutationOptions<TData, any, any>["updateQueries"];

// @public (undocumented)
interface UpdateQueryMapFn<TData = unknown, TVariables = OperationVariables> {
    // (undocumented)
    (
    unsafePreviousData: Unmasked<TData>, options: UpdateQueryOptions<TData, TVariables>): Unmasked<TData> | void;
}

// @public (undocumented)
type UpdateQueryOptions<TData, TVariables> = {
    variables?: TVariables;
} & ({
    complete: true;
    previousData: Unmasked<TData>;
} | {
    complete: false;
    previousData: DeepPartial<Unmasked<TData>> | undefined;
});

// @public (undocumented)
interface UriFunction {
    // (undocumented)
    (operation: Operation): string;
}

// @public (undocumented)
export function useApolloClient(override?: ApolloClient): ApolloClient;

// @public (undocumented)
export function useBackgroundQuery<TData, TVariables extends OperationVariables, TOptions extends Omit<useBackgroundQuery.Options, "variables">>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useBackgroundQuery.Options<NoInfer_2<TVariables>> & TOptions): [
(QueryRef<TOptions["errorPolicy"] extends "ignore" | "all" ? TOptions["returnPartialData"] extends true ? DeepPartial<TData> | undefined : TData | undefined : TOptions["returnPartialData"] extends true ? DeepPartial<TData> : TData, TVariables> | (TOptions["skip"] extends boolean ? undefined : never)),
useBackgroundQuery.Result<TData, TVariables>
];

// @public (undocumented)
export function useBackgroundQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useBackgroundQuery.Options<NoInfer_2<TVariables>> & {
    returnPartialData: true;
    errorPolicy: "ignore" | "all";
}): [
QueryRef<DeepPartial<TData> | undefined, TVariables>,
useBackgroundQuery.Result<TData, TVariables>
];

// @public (undocumented)
export function useBackgroundQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useBackgroundQuery.Options<NoInfer_2<TVariables>> & {
    errorPolicy: "ignore" | "all";
}): [
QueryRef<TData | undefined, TVariables>,
useBackgroundQuery.Result<TData, TVariables>
];

// @public (undocumented)
export function useBackgroundQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useBackgroundQuery.Options<NoInfer_2<TVariables>> & {
    skip: boolean;
    returnPartialData: true;
}): [
QueryRef<DeepPartial<TData>, TVariables> | undefined,
useBackgroundQuery.Result<TData, TVariables>
];

// @public (undocumented)
export function useBackgroundQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useBackgroundQuery.Options<NoInfer_2<TVariables>> & {
    returnPartialData: true;
}): [
QueryRef<DeepPartial<TData>, TVariables>,
useBackgroundQuery.Result<TData, TVariables>
];

// @public (undocumented)
export function useBackgroundQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useBackgroundQuery.Options<NoInfer_2<TVariables>> & {
    skip: boolean;
}): [
QueryRef<TData, TVariables> | undefined,
useBackgroundQuery.Result<TData, TVariables>
];

// @public (undocumented)
export function useBackgroundQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useBackgroundQuery.Options<NoInfer_2<TVariables>>): [QueryRef<TData, TVariables>, useBackgroundQuery.Result<TData, TVariables>];

// @public (undocumented)
export function useBackgroundQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: SkipToken): [undefined, useBackgroundQuery.Result<TData, TVariables>];

// @public (undocumented)
export function useBackgroundQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: SkipToken | (useBackgroundQuery.Options<NoInfer_2<TVariables>> & {
    returnPartialData: true;
})): [
QueryRef<DeepPartial<TData>, TVariables> | undefined,
useBackgroundQuery.Result<TData, TVariables>
];

// @public (undocumented)
export function useBackgroundQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: SkipToken | useBackgroundQuery.Options<NoInfer_2<TVariables>>): [
QueryRef<TData, TVariables> | undefined,
useBackgroundQuery.Result<TData, TVariables>
];

// @public (undocumented)
export namespace useBackgroundQuery {
    // (undocumented)
    export type FetchPolicy = Extract<WatchQueryFetchPolicy, "cache-first" | "network-only" | "no-cache" | "cache-and-network">;
    // (undocumented)
    export interface Options<TVariables extends OperationVariables = OperationVariables> {
        client?: ApolloClient;
        context?: DefaultContext;
        errorPolicy?: ErrorPolicy;
        fetchPolicy?: FetchPolicy;
        queryKey?: string | number | any[];
        refetchWritePolicy?: RefetchWritePolicy;
        returnPartialData?: boolean;
        // @deprecated
        skip?: boolean;
        variables?: TVariables;
    }
    // (undocumented)
    export type Result<TData = unknown, TVariables extends OperationVariables = OperationVariables> = {
        subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;
        fetchMore: FetchMoreFunction<TData, TVariables>;
        refetch: RefetchFunction<TData, TVariables>;
    };
}

// @public @deprecated (undocumented)
export type UseBackgroundQueryResult<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useBackgroundQuery.Result<TData, TVariables>;

// @public (undocumented)
export function useFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: useFragment.Options<TData, TVariables>): useFragment.Result<TData>;

// @public (undocumented)
export namespace useFragment {
    // (undocumented)
    export interface Options<TData, TVariables> {
        client?: ApolloClient;
        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        // (undocumented)
        from: StoreObject | Reference | FragmentType<NoInfer_2<TData>> | string | null;
        optimistic?: boolean;
        variables?: NoInfer_2<TVariables>;
    }
    // (undocumented)
    export type Result<TData> = {
        data: MaybeMasked<TData>;
        complete: true;
        missing?: never;
    } | {
        data: DeepPartial<MaybeMasked<TData>>;
        complete: false;
        missing?: MissingTree;
    };
}

// @public @deprecated (undocumented)
export type UseFragmentOptions<TData, TVariables> = useFragment.Options<TData, TVariables>;

// @public @deprecated (undocumented)
export type UseFragmentResult<TData> = useFragment.Result<TData>;

// @public
export function useLazyQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useLazyQuery.Options<NoInfer_2<TData>, NoInfer_2<TVariables>>): useLazyQuery.ResultTuple<TData, TVariables>;

// @public (undocumented)
export namespace useLazyQuery {
    // (undocumented)
    export type ExecFunction<TData, TVariables extends OperationVariables> = (...args: [TVariables] extends [never] ? [
    options?: useLazyQuery.ExecOptions<TVariables>
    ] : Record<string, never> extends OnlyRequiredProperties<TVariables> ? [
    options?: useLazyQuery.ExecOptions<TVariables>
    ] : [options: useLazyQuery.ExecOptions<TVariables>]) => Promise<ApolloQueryResult<TData>>;
    // (undocumented)
    export type ExecOptions<TVariables extends OperationVariables = OperationVariables> = {
        context?: DefaultContext;
    } & VariablesOption<TVariables>;
    // (undocumented)
    export interface Options<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
        client?: ApolloClient;
        context?: DefaultContext;
        errorPolicy?: ErrorPolicy;
        fetchPolicy?: WatchQueryFetchPolicy;
        // Warning: (ae-forgotten-export) The symbol "NextFetchPolicyContext" needs to be exported by the entry point index.d.ts
        nextFetchPolicy?: WatchQueryFetchPolicy | ((this: WatchQueryOptions<TVariables, TData>, currentFetchPolicy: WatchQueryFetchPolicy, context: NextFetchPolicyContext<TData, TVariables>) => WatchQueryFetchPolicy);
        notifyOnNetworkStatusChange?: boolean;
        pollInterval?: number;
        refetchWritePolicy?: RefetchWritePolicy;
        returnPartialData?: boolean;
        skipPollAttempt?: () => boolean;
    }
    // (undocumented)
    export interface Result<TData, TVariables extends OperationVariables> {
        called: boolean;
        client: ApolloClient;
        data: MaybeMasked<TData> | undefined;
        error?: ErrorLike;
        fetchMore: <TFetchData = TData, TFetchVars extends OperationVariables = TVariables>(fetchMoreOptions: FetchMoreQueryOptions<TFetchVars, TFetchData> & {
            updateQuery?: (previousQueryResult: Unmasked<TData>, options: {
                fetchMoreResult: Unmasked<TFetchData>;
                variables: TFetchVars;
            }) => Unmasked<TData>;
        }) => Promise<ApolloQueryResult<MaybeMasked<TFetchData>>>;
        loading: boolean;
        networkStatus: NetworkStatus;
        observable: ObservableQuery<TData, TVariables>;
        previousData?: MaybeMasked<TData>;
        refetch: (variables?: Partial<TVariables>) => Promise<ApolloQueryResult<MaybeMasked<TData>>>;
        startPolling: (pollInterval: number) => void;
        stopPolling: () => void;
        subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;
        updateQuery: (mapFn: UpdateQueryMapFn<TData, TVariables>) => void;
        variables: TVariables | undefined;
    }
    // (undocumented)
    export type ResultTuple<TData, TVariables extends OperationVariables> = [
    execute: ExecFunction<TData, TVariables>,
    result: useLazyQuery.Result<TData, TVariables>
    ];
}

// @public (undocumented)
export function useLoadableQuery<TData, TVariables extends OperationVariables, TOptions extends useLoadableQuery.Options>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useLoadableQuery.Options & TOptions): useLoadableQuery.Result<TOptions["errorPolicy"] extends "ignore" | "all" ? TOptions["returnPartialData"] extends true ? DeepPartial<TData> | undefined : TData | undefined : TOptions["returnPartialData"] extends true ? DeepPartial<TData> : TData, TVariables>;

// @public (undocumented)
export function useLoadableQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useLoadableQuery.Options & {
    returnPartialData: true;
    errorPolicy: "ignore" | "all";
}): useLoadableQuery.Result<DeepPartial<TData> | undefined, TVariables>;

// @public (undocumented)
export function useLoadableQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useLoadableQuery.Options & {
    errorPolicy: "ignore" | "all";
}): useLoadableQuery.Result<TData | undefined, TVariables>;

// @public (undocumented)
export function useLoadableQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useLoadableQuery.Options & {
    returnPartialData: true;
}): useLoadableQuery.Result<DeepPartial<TData>, TVariables>;

// @public
export function useLoadableQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useLoadableQuery.Options): useLoadableQuery.Result<TData, TVariables>;

// @public (undocumented)
export namespace useLoadableQuery {
    // (undocumented)
    export type FetchPolicy = Extract<WatchQueryFetchPolicy, "cache-first" | "network-only" | "no-cache" | "cache-and-network">;
    // (undocumented)
    export type LoadQueryFunction<TVariables extends OperationVariables> = (...args: [TVariables] extends [never] ? [] : {} extends OnlyRequiredProperties<TVariables> ? [variables?: TVariables] : [variables: TVariables]) => void;
    // (undocumented)
    export interface Options {
        client?: ApolloClient;
        context?: DefaultContext;
        errorPolicy?: ErrorPolicy;
        fetchPolicy?: FetchPolicy;
        queryKey?: string | number | any[];
        refetchWritePolicy?: RefetchWritePolicy;
        returnPartialData?: boolean;
    }
    // (undocumented)
    export type Result<TData = unknown, TVariables extends OperationVariables = OperationVariables> = [
    loadQuery: LoadQueryFunction<TVariables>,
    queryRef: QueryRef<TData, TVariables> | null,
    handlers: {
        fetchMore: FetchMoreFunction<TData, TVariables>;
        refetch: RefetchFunction<TData, TVariables>;
        subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;
        reset: ResetFunction;
    }
    ];
}

// @public @deprecated (undocumented)
export type UseLoadableQueryResult<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useLoadableQuery.Result<TData, TVariables>;

// @public
export function useMutation<TData = unknown, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache = ApolloCache>(mutation: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useMutation.Options<NoInfer_2<TData>, NoInfer_2<TVariables>, TContext, TCache>): useMutation.ResultTuple<TData, TVariables, TContext, TCache>;

// @public (undocumented)
export namespace useMutation {
    // (undocumented)
    export interface MutationFunctionOptions<TData = unknown, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache = ApolloCache> extends Options<TData, TVariables, TContext, TCache> {
        mutation?: DocumentNode | TypedDocumentNode<TData, TVariables>;
    }
    // (undocumented)
    export interface Options<TData = unknown, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache = ApolloCache> {
        awaitRefetchQueries?: boolean;
        client?: ApolloClient;
        context?: TContext;
        errorPolicy?: ErrorPolicy;
        fetchPolicy?: MutationFetchPolicy;
        keepRootFields?: boolean;
        notifyOnNetworkStatusChange?: boolean;
        onCompleted?: (data: MaybeMasked<TData>, clientOptions?: Options<TData, TVariables, TContext, TCache>) => void;
        onError?: (error: ErrorLike, clientOptions?: Options<TData, TVariables, TContext, TCache>) => void;
        onQueryUpdated?: OnQueryUpdated<any>;
        optimisticResponse?: Unmasked<NoInfer_2<TData>> | ((vars: TVariables, { IGNORE }: {
            IGNORE: IgnoreModifier;
        }) => Unmasked<NoInfer_2<TData>> | IgnoreModifier);
        refetchQueries?: ((result: FetchResult<Unmasked<TData>>) => InternalRefetchQueriesInclude) | InternalRefetchQueriesInclude;
        update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
        updateQueries?: MutationQueryReducersMap<TData>;
        variables?: TVariables;
    }
    // (undocumented)
    export interface Result<TData = unknown> {
        called: boolean;
        client: ApolloClient;
        data?: MaybeMasked<TData> | null;
        error?: ErrorLike;
        loading: boolean;
        reset: () => void;
    }
    // (undocumented)
    export type ResultTuple<TData, TVariables, TContext = DefaultContext, TCache extends ApolloCache = ApolloCache> = [
    mutate: (options?: MutationFunctionOptions<TData, TVariables, TContext, TCache>) => Promise<FetchResult<MaybeMasked<TData>>>,
    result: Result<TData>
    ];
}

// @public
export function useQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useQuery.Options<NoInfer_2<TData>, NoInfer_2<TVariables>>): useQuery.Result<TData, TVariables>;

// @public (undocumented)
export namespace useQuery {
    // (undocumented)
    export interface Options<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
        client?: ApolloClient;
        context?: DefaultContext;
        errorPolicy?: ErrorPolicy;
        fetchPolicy?: WatchQueryFetchPolicy;
        initialFetchPolicy?: WatchQueryFetchPolicy;
        nextFetchPolicy?: WatchQueryFetchPolicy | ((this: WatchQueryOptions<TVariables, TData>, currentFetchPolicy: WatchQueryFetchPolicy, context: NextFetchPolicyContext<TData, TVariables>) => WatchQueryFetchPolicy);
        notifyOnNetworkStatusChange?: boolean;
        pollInterval?: number;
        refetchWritePolicy?: RefetchWritePolicy;
        returnPartialData?: boolean;
        skip?: boolean;
        skipPollAttempt?: () => boolean;
        ssr?: boolean;
        variables?: TVariables;
    }
    // (undocumented)
    export interface Result<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
        client: ApolloClient;
        data: MaybeMasked<TData> | undefined;
        error?: ErrorLike;
        fetchMore: <TFetchData = TData, TFetchVars extends OperationVariables = TVariables>(fetchMoreOptions: FetchMoreQueryOptions<TFetchVars, TFetchData> & {
            updateQuery?: (previousQueryResult: Unmasked<TData>, options: {
                fetchMoreResult: Unmasked<TFetchData>;
                variables: TFetchVars;
            }) => Unmasked<TData>;
        }) => Promise<ApolloQueryResult<MaybeMasked<TFetchData>>>;
        loading: boolean;
        networkStatus: NetworkStatus;
        observable: ObservableQuery<TData, TVariables>;
        previousData?: MaybeMasked<TData>;
        refetch: (variables?: Partial<TVariables>) => Promise<ApolloQueryResult<MaybeMasked<TData>>>;
        // @internal (undocumented)
        reobserve: (newOptions?: Partial<WatchQueryOptions<TVariables, TData>>, newNetworkStatus?: NetworkStatus) => Promise<ApolloQueryResult<MaybeMasked<TData>>>;
        startPolling: (pollInterval: number) => void;
        stopPolling: () => void;
        subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;
        updateQuery: (mapFn: UpdateQueryMapFn<TData, TVariables>) => void;
        variables: TVariables | undefined;
    }
}

// @public
export function useQueryRefHandlers<TData = unknown, TVariables extends OperationVariables = OperationVariables>(queryRef: QueryRef<TData, TVariables>): useQueryRefHandlers.Result<TData, TVariables>;

// @public (undocumented)
export namespace useQueryRefHandlers {
    // (undocumented)
    export interface Result<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
        fetchMore: FetchMoreFunction<TData, TVariables>;
        refetch: RefetchFunction<TData, TVariables>;
        subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;
    }
}

// @public @deprecated (undocumented)
export type UseQueryRefHandlersResult<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useQueryRefHandlers.Result<TData, TVariables>;

// Warning: (ae-forgotten-export) The symbol "ReactiveVar" needs to be exported by the entry point index.d.ts
//
// @public
export function useReactiveVar<T>(rv: ReactiveVar<T>): T;

// @public (undocumented)
export function useReadQuery<TData>(queryRef: QueryRef<TData>): useReadQuery.Result<TData>;

// @public (undocumented)
export namespace useReadQuery {
    // (undocumented)
    export interface Result<TData = unknown> {
        data: MaybeMasked<TData>;
        error: ErrorLike | undefined;
        networkStatus: NetworkStatus;
    }
}

// @public @deprecated (undocumented)
export type UseReadQueryResult<TData = unknown> = useReadQuery.Result<TData>;

// @public
export function useSubscription<TData = unknown, TVariables extends OperationVariables = OperationVariables>(subscription: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useSubscription.Options<NoInfer_2<TData>, NoInfer_2<TVariables>>): {
    restart: () => void;
    loading: boolean;
    data?: TData | undefined;
    error?: ErrorLike;
    variables?: TVariables | undefined;
};

// @public (undocumented)
export namespace useSubscription {
    // (undocumented)
    export interface OnDataOptions<TData = unknown> {
        // (undocumented)
        client: ApolloClient;
        // (undocumented)
        data: Result<TData>;
    }
    // (undocumented)
    export interface OnSubscriptionDataOptions<TData = unknown> {
        // (undocumented)
        client: ApolloClient;
        // (undocumented)
        subscriptionData: Result<TData>;
    }
    // (undocumented)
    export interface Options<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
        client?: ApolloClient;
        context?: DefaultContext;
        errorPolicy?: ErrorPolicy;
        extensions?: Record<string, any>;
        fetchPolicy?: FetchPolicy;
        ignoreResults?: boolean;
        onComplete?: () => void;
        onData?: (options: OnDataOptions<TData>) => any;
        onError?: (error: ErrorLike) => void;
        // @deprecated
        onSubscriptionComplete?: () => void;
        // @deprecated
        onSubscriptionData?: (options: OnSubscriptionDataOptions<TData>) => any;
        shouldResubscribe?: boolean | ((options: Options<TData, TVariables>) => boolean);
        skip?: boolean;
        variables?: TVariables;
    }
    // (undocumented)
    export interface Result<TData = unknown, TVariables = OperationVariables> {
        data?: MaybeMasked<TData>;
        error?: ErrorLike;
        loading: boolean;
        // @internal (undocumented)
        variables?: TVariables;
    }
}

// @public (undocumented)
export function useSuspenseFragment<TData, TVariables extends OperationVariables = OperationVariables>(options: useSuspenseFragment.Options<TData, TVariables> & {
    from: NonNullable<From<TData>>;
}): useSuspenseFragment.Result<TData>;

// @public (undocumented)
export function useSuspenseFragment<TData, TVariables extends OperationVariables = OperationVariables>(options: useSuspenseFragment.Options<TData, TVariables> & {
    from: null;
}): useSuspenseFragment.Result<null>;

// @public (undocumented)
export function useSuspenseFragment<TData, TVariables extends OperationVariables = OperationVariables>(options: useSuspenseFragment.Options<TData, TVariables> & {
    from: From<TData>;
}): useSuspenseFragment.Result<TData | null>;

// @public (undocumented)
export function useSuspenseFragment<TData, TVariables extends OperationVariables = OperationVariables>(options: useSuspenseFragment.Options<TData, TVariables>): useSuspenseFragment.Result<TData>;

// @public (undocumented)
export namespace useSuspenseFragment {
    // (undocumented)
    export type Options<TData, TVariables extends OperationVariables> = {
        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        from: From<TData>;
        optimistic?: boolean;
        client?: ApolloClient;
    } & VariablesOption<NoInfer_2<TVariables>>;
    // (undocumented)
    export type Result<TData> = {
        data: MaybeMasked<TData>;
    };
}

// @public @deprecated (undocumented)
export type UseSuspenseFragmentOptions<TData, TVariables extends OperationVariables> = useSuspenseFragment.Options<TData, TVariables>;

// @public @deprecated (undocumented)
export type UseSuspenseFragmentResult<TData> = useSuspenseFragment.Result<TData>;

// @public (undocumented)
export function useSuspenseQuery<TData, TVariables extends OperationVariables, TOptions extends Omit<useSuspenseQuery.Options, "variables">>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useSuspenseQuery.Options<NoInfer_2<TVariables>> & TOptions): useSuspenseQuery.Result<TOptions["errorPolicy"] extends "ignore" | "all" ? TOptions["returnPartialData"] extends true ? DeepPartial<TData> | undefined : TData | undefined : TOptions["returnPartialData"] extends true ? TOptions["skip"] extends boolean ? DeepPartial<TData> | undefined : DeepPartial<TData> : TOptions["skip"] extends boolean ? TData | undefined : TData, TVariables>;

// @public (undocumented)
export function useSuspenseQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useSuspenseQuery.Options<NoInfer_2<TVariables>> & {
    returnPartialData: true;
    errorPolicy: "ignore" | "all";
}): useSuspenseQuery.Result<DeepPartial<TData> | undefined, TVariables>;

// @public (undocumented)
export function useSuspenseQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useSuspenseQuery.Options<NoInfer_2<TVariables>> & {
    errorPolicy: "ignore" | "all";
}): useSuspenseQuery.Result<TData | undefined, TVariables>;

// @public (undocumented)
export function useSuspenseQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useSuspenseQuery.Options<NoInfer_2<TVariables>> & {
    skip: boolean;
    returnPartialData: true;
}): useSuspenseQuery.Result<DeepPartial<TData> | undefined, TVariables>;

// @public (undocumented)
export function useSuspenseQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useSuspenseQuery.Options<NoInfer_2<TVariables>> & {
    returnPartialData: true;
}): useSuspenseQuery.Result<DeepPartial<TData>, TVariables>;

// @public (undocumented)
export function useSuspenseQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: useSuspenseQuery.Options<NoInfer_2<TVariables>> & {
    skip: boolean;
}): useSuspenseQuery.Result<TData | undefined, TVariables>;

// @public (undocumented)
export function useSuspenseQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: useSuspenseQuery.Options<NoInfer_2<TVariables>>): useSuspenseQuery.Result<TData, TVariables>;

// @public (undocumented)
export function useSuspenseQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options: SkipToken | (useSuspenseQuery.Options<NoInfer_2<TVariables>> & {
    returnPartialData: true;
})): useSuspenseQuery.Result<DeepPartial<TData> | undefined, TVariables>;

// @public (undocumented)
export function useSuspenseQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: DocumentNode | TypedDocumentNode<TData, TVariables>, options?: SkipToken | useSuspenseQuery.Options<NoInfer_2<TVariables>>): useSuspenseQuery.Result<TData | undefined, TVariables>;

// @public (undocumented)
export namespace useSuspenseQuery {
    // (undocumented)
    export type FetchPolicy = Extract<WatchQueryFetchPolicy, "cache-first" | "network-only" | "no-cache" | "cache-and-network">;
    // (undocumented)
    export interface Options<TVariables extends OperationVariables = OperationVariables> {
        client?: ApolloClient;
        context?: DefaultContext;
        errorPolicy?: ErrorPolicy;
        fetchPolicy?: FetchPolicy;
        queryKey?: string | number | any[];
        refetchWritePolicy?: RefetchWritePolicy;
        returnPartialData?: boolean;
        // @deprecated
        skip?: boolean;
        variables?: TVariables;
    }
    // (undocumented)
    export interface Result<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
        client: ApolloClient;
        data: MaybeMasked<TData>;
        error: ErrorLike | undefined;
        fetchMore: FetchMoreFunction<TData, TVariables>;
        networkStatus: NetworkStatus;
        refetch: RefetchFunction<TData, TVariables>;
        subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;
    }
}

// @public @deprecated (undocumented)
export type UseSuspenseQueryResult<TData = unknown, TVariables extends OperationVariables = OperationVariables> = useSuspenseQuery.Result<TData, TVariables>;

// @public (undocumented)
type VariablesOption<TVariables extends OperationVariables> = [
TVariables
] extends [never] ? {
    variables?: Record<string, never>;
} : Record<string, never> extends OnlyRequiredProperties<TVariables> ? {
    variables?: TVariables;
} : {
    variables: TVariables;
};

// @public
interface WatchFragmentOptions<TData, TVars> {
    fragment: DocumentNode | TypedDocumentNode<TData, TVars>;
    fragmentName?: string;
    from: StoreObject | Reference | FragmentType<NoInfer_2<TData>> | string;
    optimistic?: boolean;
    variables?: TVars;
}

// @public
type WatchFragmentResult<TData> = {
    data: MaybeMasked<TData>;
    complete: true;
    missing?: never;
} | {
    data: DeepPartial<MaybeMasked<TData>>;
    complete: false;
    missing: MissingTree;
};

// @public (undocumented)
type WatchQueryFetchPolicy = FetchPolicy | "cache-and-network";

// @public
interface WatchQueryOptions<TVariables extends OperationVariables = OperationVariables, TData = unknown> {
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    fetchPolicy?: WatchQueryFetchPolicy;
    initialFetchPolicy?: WatchQueryFetchPolicy;
    nextFetchPolicy?: WatchQueryFetchPolicy | ((this: WatchQueryOptions<TVariables, TData>, currentFetchPolicy: WatchQueryFetchPolicy, context: NextFetchPolicyContext<TData, TVariables>) => WatchQueryFetchPolicy);
    notifyOnNetworkStatusChange?: boolean;
    pollInterval?: number;
    query: DocumentNode | TypedDocumentNode<TData, TVariables>;
    refetchWritePolicy?: RefetchWritePolicy;
    returnPartialData?: boolean;
    skipPollAttempt?: () => boolean;
    variables?: TVariables;
}

// Warnings were encountered during analysis:
//
// src/cache/core/types/DataProxy.ts:137:9 - (ae-forgotten-export) The symbol "DeepPartial" needs to be exported by the entry point index.d.ts
// src/cache/core/types/DataProxy.ts:139:9 - (ae-forgotten-export) The symbol "MissingFieldError" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:101:3 - (ae-forgotten-export) The symbol "ReadFieldFunction" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:102:3 - (ae-forgotten-export) The symbol "CanReadFunction" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:103:3 - (ae-forgotten-export) The symbol "isReference" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:104:3 - (ae-forgotten-export) The symbol "ToReferenceFunction" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:105:3 - (ae-forgotten-export) The symbol "StorageType" needs to be exported by the entry point index.d.ts
// src/core/LocalState.ts:46:5 - (ae-forgotten-export) The symbol "FragmentMap" needs to be exported by the entry point index.d.ts
// src/core/ObservableQuery.ts:126:5 - (ae-forgotten-export) The symbol "QueryManager" needs to be exported by the entry point index.d.ts
// src/core/ObservableQuery.ts:127:5 - (ae-forgotten-export) The symbol "QueryInfo" needs to be exported by the entry point index.d.ts
// src/core/QueryManager.ts:184:5 - (ae-forgotten-export) The symbol "MutationStoreValue" needs to be exported by the entry point index.d.ts
// src/core/QueryManager.ts:438:7 - (ae-forgotten-export) The symbol "UpdateQueries" needs to be exported by the entry point index.d.ts
// src/core/types.ts:204:3 - (ae-forgotten-export) The symbol "MutationQueryReducer" needs to be exported by the entry point index.d.ts
// src/core/types.ts:233:5 - (ae-forgotten-export) The symbol "Resolver" needs to be exported by the entry point index.d.ts
// src/core/watchQueryOptions.ts:195:3 - (ae-forgotten-export) The symbol "UpdateQueryOptions" needs to be exported by the entry point index.d.ts
// src/react/hooks/useBackgroundQuery.ts:87:5 - (ae-forgotten-export) The symbol "SubscribeToMoreFunction" needs to be exported by the entry point index.d.ts
// src/react/hooks/useBackgroundQuery.ts:90:5 - (ae-forgotten-export) The symbol "FetchMoreFunction" needs to be exported by the entry point index.d.ts
// src/react/hooks/useBackgroundQuery.ts:93:5 - (ae-forgotten-export) The symbol "RefetchFunction" needs to be exported by the entry point index.d.ts
// src/react/hooks/useLoadableQuery.ts:72:7 - (ae-forgotten-export) The symbol "ResetFunction" needs to be exported by the entry point index.d.ts
// src/react/hooks/useSuspenseFragment.ts:73:5 - (ae-forgotten-export) The symbol "From" needs to be exported by the entry point index.d.ts
// src/react/query-preloader/createQueryPreloader.ts:45:3 - (ae-forgotten-export) The symbol "RefetchWritePolicy" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
