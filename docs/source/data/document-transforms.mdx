---
title: Document transforms
description: Make custom modifications to your GraphQL documents
---

> This article assumes you're familiar with the [anatomy of a GraphQL query](https://www.apollographql.com/blog/graphql/basics/the-anatomy-of-a-graphql-query/) and the concept of an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree). To explore a GraphQL AST, visit [AST Explorer](https://astexplorer.net/).

Have you noticed that Apollo Client makes modifications to your queries, such as adding the `__typename` field, before those queries are sent to your GraphQL server? Apollo Client provides an advanced capability that allows you to define your own GraphQL document transforms that make modifications to your GraphQL queries. Let's learn how you can make and utilize your own GraphQL document transforms.

> This feature requires Apollo Client `v3.8` or greater.

## Overview

Document transforms make modifications to GraphQL documents. A GraphQL document is an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) that defines one or more operations and fragments, parsed from a raw GraphQL query string using the `gql` function. You can create your own document transforms using the `DocumentTransform` class. The created transform is then passed to the `ApolloClient` constructor.

```ts
import { DocumentTransform } from '@apollo/client';

const documentTransform = new DocumentTransform((document) => {
  // modify the document
  return transformedDocument;
});

const client = new ApolloClient({
  documentTransform
});
```

### Lifecycle 

Document transforms are run before every GraphQL request, for all operations, made through Apollo Client. This extends to any API that performs a network request, such as the [`useQuery`](/react/api/react/hooks#usequery) hook or the [`refetch`](/react/api/core/ObservableQuery#refetch) function on [`ObservableQuery`](/react/api/core/ObservableQuery).

Document transforms are run very early in the request's lifecycle which makes it possible for modifications to GraphQL documents to be seen by the cache; an important distinction from modifications made to GraphQL documents in an [Apollo Link](/react/api/link/introduction). Because document transforms are run very early in the request lifecycle, it is also possible to add [`@client`](/react/data/directives#client) directives to fields in your document transform to turn the field into a [local-only field](/react/local-state/managing-state-with-field-policies).

### Interacting with built-in transforms

Apollo Client ships with built-in document transforms that are important to the functionality of the client.

- The `__typename` field is added to every selection set in a query to identify the type of all objects returned by the GraphQL operation.
- Queries that use fragments defined in the [fragment registry](/react/data/fragments#registering-named-fragments-using-createfragmentregistry) are added to the query before the request is sent over the network (requires Apollo Client 3.7 or later).

It's important for custom document transforms to be able to interact with these built-in features. To make the most of your custom document transform, Apollo Client will run these built-in transforms twice: once before and once after your transform.

Running the built-in transforms before your custom transform allows your transform to both see the `__typename` fields added to each selection set and makes it possible to modify fragment definitions defined in the fragment registry. Apollo Client understands that your transform may add new selection sets or add new fragment selections to the GraphQL document. Because of this, Apollo Client will run the built-in transforms again after your transform. This is a convenient capability for you because it means that you do not have to remember to include the `__typename` field for any added selection sets, nor do you need to lookup fragment definitions in the fragment registry for fragment selections added to the GraphQL document.

## Writing your own document transform

As an example, let's write a document transform that ensures an `id` field is selected anytime `currentUser` is queried. We will use several helper functions and utilities provided by the [`graphql-js`](https://graphql.org/graphql-js/) library to help us traverse the AST and make modifications to the GraphQL document.

First, we need to create a new document transform using the `DocumentTransform` class provided by Apollo Client. The `DocumentTransform` constructor takes a callback function that will run for each GraphQL document being transformed. The GraphQL `document` is passed as the only argument to this callback function.

```ts
import { DocumentTransform } from '@apollo/client';

const documentTransform = new DocumentTransform((document) => {
  // Modify the document
});
```

To make modifications to the document, we will bring in the [`visit`](https://graphql.org/graphql-js/language/#visit) function from `graphql-js` that walks the AST and allows us to make modifications to its nodes. The `visit` function takes a GraphQL AST as the first argument and a visitor as the second argument. The `visit` function will return our modified or unmodified GraphQL document, which we return from our document transform callback function.

```ts {5-9}
import { DocumentTransform } from '@apollo/client';
import { visit } from 'graphql';

const documentTransform = new DocumentTransform((document) => {
  const transformedDocument = visit(document, {
    // visitor
  });

  return transformedDocument;
});
```

Visitors allow you to visit many types of nodes in the AST, such as directives, fragments, and fields. In our example, we only care to visit field nodes since we are looking to make modifications to the `currentUser` field in our queries. To visit a field node, we need to define a `Field` callback function which will be called whenever the traversal encounters a field node.

```ts {2-4}
const transformedDocument = visit(document, {
  Field(fieldNode) {
    // ...
  }
});
```

> In this example, we are using the shorthand visitor syntax, which defines the `enter` function on this node for us. This is equivalent to the following:
> ```ts
> visit(document, {
>   Field: {
>     enter(fieldNode) {
>       // ...
>     }
>   }
> });
> ```

Our document transform only needs to make modifications to a field named `currentUser`, so we need to check the field node's `name` to know if we are working with the `currentUser` field. Let's add a conditional check and return early if we encounter any field not named `currentUser`.

```ts
const transformedDocument = visit(document, {
  Field(fieldNode) {
    if (fieldNode.name.value !== 'currentUser') {
      return;
    }
  }
});
```
> Returning `undefined` from our `Field` visitor tells the `visit` function to leave the node unchanged.

Now that we've determined we are working with the `currentUser` field, we need to figure out if our `id` field is already part of the `currentUser` field's selection set. By checking it's selection set, we ensure we don't accidentally select the field twice in our query. 

To do so, let's get the field's `selectionSet` and loop over it's `selections` to determine if it includes a field named `id`. It's important to note that a `selectionSet` may contain `selections` of both fields and fragments. Our implementation will need to perform a check against the selection's `kind` property to limit our check only to fields and not fragments. If we find a match on a field named `id`, we no longer need to do any work and can stop traversal of the AST. 

We will bring in both the [`Kind`](https://graphql.org/graphql-js/language/#kind) enum from `graphql-js`, which allows us to compare against the node's `kind` property, and the [`BREAK`](https://graphql.org/graphql-js/language/#break) constant, which directs the `visit` function to stop traversal of the AST.

```ts {6-15}
import { visit, Kind, BREAK } from 'graphql';

const transformedDocument = visit(document, {
  Field(fieldNode) {
    // ...
    const selections = fieldNode.selectionSet?.selections ?? [];

    for (const selectionNode of selections) {
      if (
        selectionNode.kind === Kind.FIELD &&
        selectionNode.name.value === 'id'
      ) {
        return BREAK;
      }
    }
  }
});
```

> To keep our document transform simple, it does not traverse fragments within the `currentUser` field to determine if those fragments contain an `id` field. A more complete version of this document transform might perform this check.

Now that we know the `id` field is missing, we can add it to our `currentUser` field's selection set. To do so, let's first create a new field node and give it a name of `id`. This is just a plain object with the `kind` property set to `Kind.FIELD` and a `name` node that defines the field's name.

```ts
const idField = {
  kind: Kind.FIELD,
  name: {
    kind: Kind.NAME,
    value: 'id',
  },
};
```

We can now return a modified field node from our visitor that adds that field to the node's `selectionSet` to update our GraphQL document.

```ts {8-14}
const transformedDocument = visit(document, {
  Field(fieldNode) {
    // ...
    const idField = {
      // ... 
    };

    return {
      ...fieldNode,
      selectionSet: {
        ...fieldNode.selectionSet,
        selections: [...selections, idField],
      },
    };
  }
});
```

> Here we've added the `id` field to the end of the selection set. The order does not matter and you may prefer to put the field in a different order within the `selections` array.

Hooray! We've now got a working document transform that ensures the `id` field is selected whenever a query is sent to our server that contains the `currentUser` field. For completeness, here is the full definition of our custom document transform after completing this example.

```ts
import { DocumentTransform } from '@apollo/client';
import { visit, Kind, BREAK } from 'graphql';

const documentTransform = new DocumentTransform((document) => {
  const transformedDocument = visit(document, {
    Field(fieldNode) {
      if (fieldNode.name.value !== 'currentUser') {
        return;
      }

      const selections = fieldNode.selectionSet?.selections ?? [];

      for (const selectionNode of selections) {
        if (
          selectionNode.kind === Kind.FIELD &&
          selectionNode.name.value === 'id'
        ) {
          return BREAK;
        }
      }

      const idField = {
        kind: Kind.FIELD,
        name: {
          kind: Kind.NAME,
          value: 'id',
        },
      };

      return {
        ...fieldNode,
        selectionSet: {
          ...fieldNode.selectionSet,
          selections: [...selections, idField],
        },
      };
    },
  });

  return transformedDocument;
});
```

### Checking our document transform

We can check our custom document transform by calling the `transformDocument` function and passing a GraphQL query to it. 

```ts
import { print } from 'graphql';

const query = gql`
  query TestQuery {
    currentUser {
      name
    }
  }
`;

const documentTransform = new DocumentTransform((document) => {
  // ...
});

const modifiedQuery = documentTransform.transformDocument(query);

console.log(print(modifiedQuery));
// query TestQuery {
//   currentUser {
//     name
//     id
//   }
// }
```

> We use the [`print`](https://graphql.org/graphql-js/language/#print) function exported by `graphql-js` to make the query human-readable.

Similarly, we can verify that passing a query that _doesn't_ query for `currentUser` is not affected by our transform.

```ts
const query = gql`
  query TestQuery {
    user {
      name
    }
  }
`;

const modifiedQuery = documentTransform.transformDocument(query);

console.log(print(modifiedQuery));
// query TestQuery {
//   user {
//     name
//   }
// }
```

## Composing multiple document transforms

You may have noticed that the `ApolloClient` constructor only takes a single `documentTransform` option. As you add new capabities to your document transforms, you may find that a your document transform function starts to grow unwieldy. The `DocumentTransform` class makes it easy to split your transforms up and compose multiple transforms together into a single transform. 

### Combining multiple document transforms

You can combine multiple document transforms together using the `concat()` function. This forms a "chain" of document transforms that are run one right after the other.

```ts
const documentTransform1 = new DocumentTransform(transform1);
const documentTransform2 = new DocumentTransform(transform2);

const documentTransform = documentTransform1.concat(documentTransform2);
```

Here `documentTransform1` is combined with `documentTransform2` into a single document transform. Calling the `transformDocument()` function on `documentTransform` will first run the GraphQL document through `documentTransform1`, then through `documentTransform2`. Changes made to the GraphQL document in `documentTransform1` are seen by `documentTransform2`.

#### A note about performance

Combining multiple transforms is a powerful feature that makes it easy to split up transform logic, which can boost maintainability. It should be noted however that depending on the implementation of your visitor, this can result in the traversal of the GraphQL document AST multiple times. Most of the time this shouldn't be an issue. We recommend using the [`BREAK`](https://graphql.org/graphql-js/language/#break) sentinal from GraphQL where necessary to prevent unnecessary traversal. 

If, however, you are sending very large queries that require a lot of traversal and have already optimized your visitors with the `BREAK` sentinal, you may find it optimal to combine the transforms into a single visitor that traverses the AST once. 

See the section on [document caching](#document-caching) to learn how Apollo Client applies optimizations to individual document transforms to mitigate the performance impact when transforming the same GraphQL document multiple times.

### Conditionally running document transforms

At times, you may want to conditionally run a document transform depending on the GraphQL document. You can conditionally run a transform by calling the `split()` static function on the `DocumentTransform` constructor.

```ts
const documentTransform = new DocumentTransform(transform);

const subscriptionTransforms = DocumentTransform.split(
  (document) => isSubscriptionOperation(document),
  documentTransform
);
```

Here the `documentTransform` is only run for subscription operations. For all other operations, no modifications are made to the GraphQL document. Calling the `transformDocument()` function on `subscriptionTransforms` will first check to see if the `document` is a subscription operation, and if so, proceed to run the `documentTransform`. If not, the document transform is bypassed and the GraphQL document is returned as-is.

The `split` function also allows you to pass a second document transform to its function, allowing you to replicate an if/else condition.

```ts
const subscriptionTransform = new DocumentTransform(transform1);
const defaultTransform = new DocumentTransform(transform2)

const documentTransform = DocumentTransform.split(
  (document) => isSubscriptionOperation(document),
  subscriptionTransform,
  defaultTransform
);
```

Here the `subscriptionTransform` is only run for subscription operations. For all other operations, the GraphQL document is run through the `defaultTransform`.

#### Why should I use the `split()` function instead of a conditional check inside of the transform function?

It is certainly possible to conditionally run a transform by adding a conditional check inside the transform function itself. 

```ts
const documentTransform = new DocumentTransform((document) => {
  if (shouldTransform(document)) {
    // ...
    return transformedDocument
  }

  return document
});
```

Consider the case though where you've combined multiple document transforms together using the `concat()` function.

```ts
const documentTransform1 = new DocumentTransform(transform1);
const documentTransform2 = new DocumentTransform(transform2);
const documentTransform3 = new DocumentTransform(transform3);

const documentTransform = documentTransform1
  .concat(documentTransform2)
  .concat(documentTransform3);
```

The `split()` function makes it easier to skip the _entire_ chain of document transforms.

```ts
const documentTransform = DocumentTransform.split(
  (document) => shouldTransform(document),
  documentTransform1
    .concat(documentTransform2)
    .concat(documentTransform3)
);
```

## Document caching

You should strive to make your document transforms be deterministic, meaning the document transform should always output the same transformed GraphQL document when given the same input GraphQL document. The `DocumentTransform` class optimizes for this case by caching the transformed result for each input GraphQL document. This speeds up repeated calls to the document transform to avoid unnecessary work.

The `DocumentTransform` class takes this one step further and will record all transformed documents. This means that passing an _already_ transformed document to the `transformDocument()` function will immediately return the GraphQL document.

```ts
const transformedDocument = documentTransform.transformDocument(document);

transformedDocument === documentTransform.transformDocument(transformedDocument); // => true
```

### Non-deterministic document transforms

In rare circumstances, you may need to rely on a runtime condition from outside the transform function that changes the result of the document transform. Due to the automatic caching of the document transform, this becomes a problem when that runtime condition changes between calls to `transformDocument()` since your document transform will not know it needs to be run again.

Instead of completely disabling the document cache in these situations, you can provide a custom cache key that will be used to cache the result of the document transform. This ensures your transform is only called as often as necessary, while maintaining the flexiblity of the runtime condition.

To customize the cache key, pass the `getCacheKey` function as an option to the second argument of the `DocumentTransform` constructor. This function receives the `document` that will be passed to your transform function and is expected to return an array.

As an example, here is a document transform that depends on whether the user is connected to the network.

```ts
const documentTransform = new DocumentTransform(
  (document) => {
    if (window.navigator.onLine) {
      // Transform the document when the user is online
    } else {
      // Transform the document when the user is offline
    }
  },
  {
    getCacheKey: (document) => [document, window.navigator.onLine]
  }
);
```

> It is **HIGHLY** recommended you use the `document` as part of your cache key. In this example, if the `document` is omitted from the cache key, the document transform will only ever output two transformed documents: one for the `true` condition and one for the `false` condition. Using the `document` in the cache key ensures that each unique document in your application will be transformed accordingly.

You may conditionally disable the cache for select GraphQL documents by returning `undefined` from the `getCacheKey` function. This will force the document transform to run, regardless of whether the input GraphQL document has been seen or not.

```ts
const documentTransform = new DocumentTransform(
  (document) => {
    // ...
  },
  {
    getCacheKey: (document) => {
      // Always run the transform function when `shouldCache` is `false`
      if (shouldCache(document)) {
        return [document] 
      }
    }
  }
);
```

As a last resort, you may completely disable document caching to force your document transform to run each time `transformDocument()` is called. Set the `cache` option to `false` to disable the cache.

```ts
const documentTransform = new DocumentTransform(
  (document) => {
    // ...
  },
  {
    cache: false
  }
);
```

### Caching within combined transforms

When you combine multiple document transforms together using the `concat()` function, each document transform's cache configuration is honored. This allows you to mix and match transforms that contain varying cache configurations and be confident the transformed GraphQL document is correctly transformed.

```ts
const cachedTransform = new DocumentTransform(transform);

const varyingTransform = new DocumentTransform(transform, {
  getCacheKey: (document) => [document, window.navigator.onLine]
});

const condtionalCachedTransform = new DocumentTransform(transform, {
  getCacheKey: (document) => {
    if (shouldCache(document)) {
      return [document]
    }
  }
});

const nonCachedTransform = new DocumentTransform(transform, {
  cache: false
});

const documentTransform = 
  cachedTransform
    .concat(varyingTransform)
    .concat(conditionalCachedTransform)
    .concat(nonCachedTransform);
```

## TypeScript and GraphQL Code Generator

[GraphQL Code Generator](https://the-guild.dev/graphql/codegen) is a popular tool that generates TypeScript types for your GraphQL documents. It does this by statically analyzing your code to search for GraphQL query strings.

Document transforms present a challenge for this tool. Because these transforms are used at runtime, we have no way to for static analysis to pick up the changes applied to GraphQL documents from our transform.

Thankfully, GraphQL Code Generator provides the ability to run [document transforms](https://the-guild.dev/graphql/codegen/docs/advanced/document-transform) on the documents seen by this tool. We can hook into this ability by using our custom document transform inside the `transform` function passed to the GraphQL Code Generator config.

```ts title="codegen.ts" {2,12-18}
import type { CodegenConfig } from '@graphql-codegen/cli';
import { documentTransform } from './path/to/your/transform';
 
const config: CodegenConfig = {
  schema: 'https://localhost:4000/graphql',
  documents: ['src/**/*.tsx'],
  generates: {
    './src/gql/': {
      preset: 'client',
      documentTransforms: [
        {
          transform: ({ documents }) => {
            return documents.map((documentFile) => {
              documentFile.document = documentTransform.transformDocument(documentFile.document);

              return documentFile;
            });
          }
        }
      ]
    }
  }
}
```

## You might not need document transforms

Document transforms are a powerful feature of Apollo Client. After reading this article, you may find yourself rushing to find as many use cases for this feature as you can think of. While we encourage you to use this feature where it makes sense in your application, there can be a hidden cost to using it.

Consider what happens when you're working in a large production application that span many teams within your organization. Document transforms will typically be defined in the code base far away from where GraphQL queries are defined. Not all developers may be aware of their existence nor understand their impact on final GraphQL document.

Because document transforms have the ability to make endless modifications to GraphQL documents before they are sent to the network, you may find yourself in a position where the result returned from the GraphQL operation does not match the original GraphQL document. This can get especially confusing when document transforms remove fields or make other destructive changes.

Consider leaning on existing techniques as a first resort, such as linting. For example, if you require that every selection set in your GraphQL document should include an `id` field, you may find it more useful to create a lint rule that yells at you when you forget to include it. This makes it more obvious exactly what to expect from your GraphQL queries since its located where youre GraphQL queries are defined. Adding an `id` via a document transform makes this relationship an implicit one.

We encourage you to document your own document transforms to create a shared knowledge base to help avoid confusion. This doesn't mean we consider this feature dangerous. After all, Apollo Client has been performing document transformations for nearly its entire existence and is necessary for its core functionality.
