---
title: TypeScript with Apollo Client
descriptions: How to generate and use TypeScript types in your application
---

As your application grows, a type system can become an essential tool for catching bugs early and improving your overall developer experience.

GraphQL uses a type system to clearly define the available data for each type and field in a GraphQL schema. Given that a GraphQL server's schema is strongly typed, we can generate TypeScript definitions automatically using a tool like [GraphQL Code Generator](https://www.the-guild.dev/graphql/codegen). We'll use our generated types to ensure type safety for the _inputs_ and _results_ of our GraphQL operations.

Below, we'll guide you through installing and configuring GraphQL Code Generator to generate types for your hooks and components.

## Setting up your project

Install the following packages. This installation assumes you already have [insalled `@apollo/client` and its dependencies](../get-started#step-2-install-dependencies).

```bash
npm install -D @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations
```

Next, we'll create a configuration file for GraphQL Code Generator, named [`codegen.ts`](https://www.the-guild.dev/graphql/codegen/docs/config-reference/codegen-config), at the root of our project. The following config is a recommended minimal configuration for Apollo Client apps.

```ts title="codegen.ts"
import { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
  overwrite: true,
  schema: "<URL_OF_YOUR_GRAPHQL_API>",
  // This assumes that all your source files are in a top-level `src/` directory - you might need to adjust this to your file structure
  documents: ["src/**/*.{ts,tsx}"],
  // Don't exit with non-zero status when there are no documents
  ignoreNoDocuments: true,
  generates: {
    // Note: pick a path that works the best for the structure of your application
    "./src/types/__generated__/graphql.ts": {
      plugins: ["typescript", "typescript-operations"],
      config: {
        avoidOptionals: {
          // Use `null` for nullable fields instead of optionals
          field: true,
          // Allow nullable input fields to remain unspecified
          inputValue: false,
        },
        // Use `unknown` instead of `any` for unconfigured scalars
        defaultScalarType: "unknown",
        // Apollo Client always includes `__typename` fields
        nonOptionalTypename: true,
      },
    },
  },
};

export default config;
```

<Note>

There are multiple ways to [specify a schema](https://www.the-guild.dev/graphql/codegen/docs/config-reference/schema-field#root-level) in your `codegen.ts`, so pick whichever way works best for your project setup.

</Note>

Finally, we'll add the script to our `package.json` file:

```json title="package.json"
{
  "scripts": {
    "codegen": "graphql-codegen --config codegen.ts"
  }
}
```

Running either of the scripts above generates types based on the schema file or GraphQL API you provided in `codegen.ts`:

```bash showLineNumbers=false
$ npm run codegen
✔ Parse Configuration
✔ Generate outputs
```

<Note>

If you follow GraphQL Codegen's [quickstart guide](https://the-guild.dev/graphql/codegen/docs/getting-started/installation), it recommends generating your config file using the GraphQL Code Generator CLI. This wizard installs and configures the [`@graphql-codegen/client-preset`](https://the-guild.dev/graphql/codegen/plugins/presets/preset-client).<br /><br />

We don't recommend using the client preset with Apollo Client apps because it generates some runtime code that adds additional bundle size to your app and includes some features that are incompatible with Apollo Client. We instead recommend using the [`typescript`](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript) and [`typescript-operations`](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-operations) plugins directly (at minimum) which focus on only generating types and doesn't include additional runtime code.<br /><br />

If you are already using the client preset, we recommend, at minimum, [disabling fragment masking](https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#how-to-disable-fragment-masking). See the guide on [data masking](../data/fragments#data-masking) for more information on using TypeScript with Apollo Client's data masking feature.

</Note>

## Typing hooks

GraphQL Code Generator automatically creates a `gql` function (from the `src/__generated__/gql.ts` file). This function enables us to type the variables that go into our React hooks, along with the results from those hooks.

### `useQuery`

Below we use the `gql` function to define our query, which automatically generates types for our `useQuery` hook:

```tsx
import React from "react";
import { useQuery } from "@apollo/client/react";

import { gql } from "../src/__generated__/gql";

const GET_ROCKET_INVENTORY = gql(/* GraphQL */ `
  query GetRocketInventory($year: Int!) {
    rocketInventory(year: $year) {
      id
      model
      year
      stock
    }
  }
`);

export function RocketInventoryList() {
  // our query's result, data, is typed!
  const { loading, data } = useQuery(
    GET_ROCKET_INVENTORY,
    // variables are also typed!
    { variables: { year: 2019 } }
  );
  return (
    <div>
      <h3>Available Inventory</h3>
      {loading ?
        <p>Loading ...</p>
      : <table>
          <thead>
            <tr>
              <th>Model</th>
              <th>Stock</th>
            </tr>
          </thead>
          <tbody>
            {data &&
              data.rocketInventory.map((inventory) => (
                <tr>
                  <td>{inventory.model}</td>
                  <td>{inventory.stock}</td>
                </tr>
              ))}
          </tbody>
        </table>
      }
    </div>
  );
}
```

#### `fetchMore` and `subscribeToMore`

The `useQuery` hook returns an instance of `QueryResult`, which includes the `fetchMore` and `subscribeToMore` functions. See [Queries for detailed type information](../data/queries#result). Because these functions execute GraphQL operations, they accept type parameters.

By default, the type parameters for `fetchMore` are the same as those for `useQuery`. Because both `fetchMore` and `useQuery` encapsulate a query operation, it's unlikely that you'll need to pass any type arguments to `fetchMore`.

Expanding our previous example, notice that we don't explicitly type `fetchMore`, because it defaults to using the same type parameters as `useQuery`:

```tsx
// ...
export function RocketInventoryList() {
  const { fetchMore, loading, data } = useQuery(
    GET_ROCKET_INVENTORY,
    // variables are typed!
    { variables: { year: 2019 } }
  );

  return (
    //...
    <button
      onClick={() => {
        // variables are typed!
        fetchMore({ variables: { year: 2020 } });
      }}
    >
      Add 2020 Inventory
    </button>
    //...
  );
}
```

The type parameters and defaults for `subscribeToMore` are identical to those for `fetchMore`. Keep in mind that `subscribeToMore` executes a _subscription_, whereas `fetchMore` executes follow-up queries.

Using `subscribeToMore`, you usually pass at least one typed argument, like so:

```tsx
// ...
const ROCKET_STOCK_SUBSCRIPTION = gql(/* GraphQL */ `
  subscription OnRocketStockUpdated {
    rocketStockAdded {
      id
      stock
    }
  }
`);

export function RocketInventoryList() {
  const { subscribeToMore, loading, data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { year: 2019 },
  });

  React.useEffect(() => {
    subscribeToMore(
      // variables are typed!
      { document: ROCKET_STOCK_SUBSCRIPTION, variables: { year: 2019 } }
    );
  }, [subscribeToMore]);

  // ...
}
```

### `useMutation`

We can type `useMutation` hooks the same way we type `useQuery` hooks. Using the generated `gql` function to define our GraphQL mutations, we ensure that we type our mutation's variables and return data:

```tsx
import React, { useState } from "react";
import { useMutation } from "@apollo/client/react";

import { gql } from "../src/__generated__/gql";

const SAVE_ROCKET = gql(/* GraphQL */ `
  mutation saveRocket($rocket: RocketInput!) {
    saveRocket(rocket: $rocket) {
      model
    }
  }
`);

export function NewRocketForm() {
  const [model, setModel] = useState("");
  const [year, setYear] = useState(0);
  const [stock, setStock] = useState(0);

  // our mutation's result, data, is typed!
  const [saveRocket, { error, data }] = useMutation(SAVE_ROCKET, {
    // variables are also typed!
    variables: { rocket: { model, year: +year, stock: +stock } },
  });

  return (
    <div>
      <h3>Add a Rocket</h3>
      {error ?
        <p>Oh no! {error.message}</p>
      : null}
      {data && data.saveRocket ?
        <p>Saved!</p>
      : null}
      <form>
        <p>
          <label>Model</label>
          <input name="model" onChange={(e) => setModel(e.target.value)} />
        </p>
        <p>
          <label>Year</label>
          <input
            type="number"
            name="year"
            onChange={(e) => setYear(+e.target.value)}
          />
        </p>
        <p>
          <label>Stock</label>
          <input
            type="number"
            name="stock"
            onChange={(e) => setStock(e.target.value)}
          />
        </p>
        <button onClick={() => model && year && stock && saveRocket()}>
          Add
        </button>
      </form>
    </div>
  );
}
```

### `useSubscription`

We can type our `useSubscription` hooks the same way we typed our `useQuery` and `useMutation` hooks. Using the generated `gql` function to define our GraphQL subscriptions, we ensure that we type our subscription variables and return data:

```tsx
import React from "react";
import { useSubscription } from "@apollo/client/react";

import { gql } from "../src/gql";

const LATEST_NEWS = gql(/* GraphQL */ `
  subscription getLatestNews {
    latestNews {
      content
    }
  }
`);

export function LatestNews() {
  // our returned data is typed!
  const { loading, data } = useSubscription(LATEST_NEWS);
  return (
    <div>
      <h5>Latest News</h5>
      <p>{loading ? "Loading..." : data!.latestNews.content}</p>
    </div>
  );
}
```

## Using `TypedDocumentNode`

In TypeScript, all APIs that intake `DocumentNode` can alternatively take `TypedDocumentNode<Data, Variables>`. This type has the same JavaScript representation but enables APIs to infer the data and variable types (instead of making you specify types upon invocation).

This technique enables us to modify the [`useQuery` example](#usequery) above to use a type inference:

```tsx
import React from "react";
import { gql, TypedDocumentNode } from "@apollo/client";
import { useQuery } from "@apollo/client/react";
import {
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables,
} from "./path/to/types/file.ts";

const GET_ROCKET_INVENTORY: TypedDocumentNode<
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables
> = gql`
  query GetRocketInventory($year: Int!) {
    rocketInventory(year: $year) {
      id
      model
      year
      stock
    }
  }
`;

export function RocketInventoryList() {
  const { loading, data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { year: 2019 },
  });
  return (
    <div>
      <h3>Available Inventory</h3>
      {loading ?
        <p>Loading ...</p>
      : <table>
          <thead>
            <tr>
              <th>Model</th>
              <th>Stock</th>
            </tr>
          </thead>
          <tbody>
            {data &&
              data.rocketInventory.map((inventory) => (
                <tr>
                  <td>{inventory.model}</td>
                  <td>{inventory.stock}</td>
                </tr>
              ))}
          </tbody>
        </table>
      }
    </div>
  );
}
```

## Data masking

Learn more about integrating TypeScript with data masking in the [data masking docs](../data/fragments#using-with-typescript).
