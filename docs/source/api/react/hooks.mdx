---
title: Hooks
description: Apollo Client react hooks API reference
minVersion: 3.0.0
---

{/** @import {MDXProvidedComponents} from '../../../shared/MdxProvidedComponents.js' */}

## The `ApolloProvider` component

The `ApolloProvider` component leverages [React's Context API](https://react.dev/reference/react/useContext) to make a configured Apollo Client instance available throughout a React component tree. This component can be imported directly from the `@apollo/client/react` package.

```js
import { ApolloProvider } from '@apollo/client/react';
```

### Props

| Option   | Type                       | Description                 |
| -------- | -------------------------- | --------------------------- |
| `client` | `ApolloClient` | An `ApolloClient` instance. |

### Example

```jsx {7-9}
const client = new ApolloClient({
  cache: new InMemoryCache(),
  uri: "http://localhost:4000/graphql"
});

ReactDOM.render(
  <ApolloProvider client={client}>
    <MyRootComponent />
  </ApolloProvider>,
  document.getElementById('root'),
);
```

## The `ApolloConsumer` component

One way to access the configured Apollo Client instance directly is to create an `ApolloConsumer` component and provide a render prop function as its child. The render prop function will be called with your `ApolloClient` instance as its only argument. You can think of the `ApolloConsumer` component as similar to the `Consumer` component from the [React Context API](https://react.dev/reference/react/useContext).

### Example

```jsx
import { ApolloConsumer } from '@apollo/client/react';

function WithApolloClient() {
  return (
    <ApolloConsumer>
      {client => 'We have access to the client!' /* do stuff here */}
    </ApolloConsumer>
  );
}
```

<FunctionDetails canonicalReference="@apollo/client!useQuery.DocumentationTypes.useQuery:function(1)" headingLevel={2} />


<FunctionDetails canonicalReference="@apollo/client!useLazyQuery.DocumentationTypes.useLazyQuery:function(1)" headingLevel={2}>
  ```ts
  [execute: LazyQueryExecFunction<TData, TVariables>, result: QueryResult<TData, TVariables>]
  ```

  A tuple of two values:

  <ManualTuple>
    <ManualTupleItem
      name="execute"
      type="(options?: LazyQueryHookOptions<TVariables>) => Promise<LazyQueryResult<TData, TVariables>>"
    >
      Function that can be triggered to execute the suspended query. After being called, `useLazyQuery` behaves just like `useQuery`. The `useLazyQuery` function returns a promise that fulfills with a query result when the query succeeds or fails.
    </ManualTupleItem>
    <ManualTupleItem
      name="result"
      type="QueryResult<TData, TVariables>"
      canonicalReference="@apollo/client!QueryResult:interface"
    >
      The result of the query. See the `useQuery` hook for more details.
    </ManualTupleItem>
  </ManualTuple>
</FunctionDetails>

<FunctionDetails
  canonicalReference="@apollo/client!useMutation:function(1)"
  headingLevel={2}
>
  ```ts
  [
    mutate: (options?: MutationFunctionOptions<TData, TVariables>) => Promise<FetchResult<TData>>,
    result: MutationResult<TData>
  ]
  ```
  A tuple of two values:
  <ManualTuple>
    <ManualTupleItem
      name="mutate"
      type={`(
        options?: MutationFunctionOptions<TData, TVariables>
      ) => Promise<FetchResult<TData>>`}
      idPrefix="usemutation-result"
    >
      A function to trigger the mutation from your UI. You can optionally pass this function any of the following options:

      - `awaitRefetchQueries`
      - `context`
      - `fetchPolicy`
      - `onCompleted`
      - `onError`
      - `optimisticResponse`
      - `refetchQueries`
      - `onQueryUpdated`
      - `update`
      - `variables`
      - `client`

      Any option you pass here overrides any existing value for that option that you passed to `useMutation`.

      The mutate function returns a promise that fulfills with your mutation result.
    </ManualTupleItem>
    <ManualTupleItem
      name="result"
      type="MutationResult<TData>"
      canonicalReference="@apollo/client!MutationResult:interface"
      idPrefix="usemutation-result"
    >
      The result of the mutation.
    </ManualTupleItem>
  </ManualTuple>
</FunctionDetails>

<FunctionDetails canonicalReference="@apollo/client!useSubscription:function(1)" headingLevel={2} />

<FunctionDetails canonicalReference="@apollo/client!useApolloClient:function(1)" headingLevel={2} />

<FunctionDetails canonicalReference="@apollo/client!useReactiveVar:function(1)" headingLevel={2} />

<FunctionDetails
  canonicalReference="@apollo/client!useFragment.DocumentationTypes.useFragment:function(1)" headingLevel={2} />



<FunctionDetails
  canonicalReference="@apollo/client!useSuspenseQuery.DocumentationTypes.useSuspenseQuery:function(1)"
  headingLevel={2}
/>

<FunctionDetails
  canonicalReference="@apollo/client!useBackgroundQuery.DocumentationTypes.useBackgroundQuery:function(1)"
  headingLevel={2}

>
  ```ts
    [
      QueryRef<TData, TVariables> | undefined,
      useBackgroundQuery.Result<TData, TVariables>,
    ]
  ```

  A tuple of two values:
  <ManualTuple>

    <ManualTupleItem
      idPrefix="usebackgroundquery-result"
      name="queryRef"
      type="QueryRef<TData, TVariables> | undefined"
    >
      A `QueryRef` that can be passed to `useReadQuery` to read the query result. The `queryRef` is `undefined` if the query is skipped.
    </ManualTupleItem>
    <ManualTupleItem
      idPrefix="usebackgroundquery-result"
      name="result"
      type="useBackgroundQuery.Result<TData, TVariables>"
      canonicalReference={"@apollo/client!useBackgroundQuery.Result:interface"}
    >
      An object containing helper functions for the query:
      - `refetch`: A function to re-execute the query
      - `fetchMore`: A function to fetch more results for pagination
      - `subscribeToMore`: A function to subscribe to updates
    </ManualTupleItem>
  </ManualTuple>
</FunctionDetails>



If no query has been executed yet and you skip the query, the hook will return `undefined` instead of a `queryRef`.

<FunctionDetails
  canonicalReference="@apollo/client!useReadQuery.DocumentationTypes.useReadQuery:function(1)"
  headingLevel={2}
/>

<FunctionDetails
  canonicalReference="@apollo/client!useLoadableQuery.DocumentationTypes.useLoadableQuery:function(1)"
  headingLevel={2}
>
  ```ts
  [
    loadQuery: LoadQueryFunction<TVariables>,
    queryRef: QueryRef<TData, TVariables> | null,
    {
      fetchMore: FetchMoreFunction<TData, TVariables>;
      refetch: RefetchFunction<TData, TVariables>;
      subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;
      reset: ResetFunction;
    }
  ]
  ```

  A tuple of three values:
  <ManualTuple>
    <ManualTupleItem
      idPrefix="useloadablequery-result"
      name="loadQuery"
      type="LoadQueryFunction<TVariables>"
    >
      A function used to imperatively load a query. Calling this function will create or update the `queryRef` returned by `useLoadableQuery`, which should be passed to `useReadQuery`.
    </ManualTupleItem>
    <ManualTupleItem
      idPrefix="useloadablequery-result"
      name="queryRef"
      type="QueryRef<TData, TVariables> | null"
    >
      The `queryRef` used by `useReadQuery` to read the query result.
    </ManualTupleItem>
    <ManualTupleItem
      idPrefix="useloadablequery-result"
      name="handlers"
      type="{ fetchMore: FetchMoreFunction<TData, TVariables>; refetch: RefetchFunction<TData, TVariables>; subscribeToMore: SubscribeToMoreFunction<TData, TVariables>; reset: ResetFunction; }"
    >
      Additional handlers used for the query, such as `refetch`.
    </ManualTupleItem>
  </ManualTuple>
</FunctionDetails>

<FunctionDetails canonicalReference="@apollo/client!useQueryRefHandlers:function(1)" headingLevel={2} />

<MinVersion version="3.8.0">

## `skipToken`

</MinVersion>

While not a hook by itself, `skipToken` is designed to be used with `useSuspenseQuery` and `useBackgroundQuery`.
If a `skipToken` is passed into one of those hooks instead of the `options` object, that hook will not cause any requests or suspenseful behavior, while keeping the last `data` available.

```js title="Recommended usage of skipToken with useSuspenseQuery"
import { skipToken, useSuspenseQuery } from '@apollo/client/react';
const { data } = useSuspenseQuery(
  query,
  id ? { variables: { id } } : skipToken
);
```


```js title="Recommended usage of skipToken with useBackgroundQuery"
import { skipToken, useBackgroundQuery } from '@apollo/client/react';
const [queryRef] = useBackgroundQuery(
  query,
  id ? { variables: { id } } : skipToken
);
```

<blockquote>

Note: **Why do we recommend `skipToken` over `{ skip: true }`?**

Imagine this very common scenario for `skip`: You want to skip your query if a certain variable is not set. You might be tempted to write something like this:

```ts
const { data } = useSuspenseQuery(query, {
  variables: { id },
  skip: !id
});
```
But in that case, TypeScript will complain:
```
Type 'number | undefined' is not assignable to type 'number'.
      Type 'undefined' is not assignable to type 'number'.ts(2769)
```

To get around that, you have to tell TypeScript to ignore the fact that `id` could be `undefined`:
```ts
const { data } = useSuspenseQuery(query, {
  variables: { id: id! },
  skip: !id
});
```
Alternatively, you could also use some obscure default value:
```ts
const { data } = useSuspenseQuery(query, {
  variables: { id: id || 0 },
  skip: !id
});
```

What both of these solutions have in common: They hide a potential bug. If your `skip` logic becomes more complex in the future, you might accidentally introduce a bug that causes your query not to be skipped, even though `id` is still `undefined` - and TypeScript won't be able to warn you about it.

So instead, we recommend using `skipToken`, as that will work without a lie to the compiler or an obscure default value:

```ts
const { data } = useSuspenseQuery(
  query,
  id ? { variables: { id } } : skipToken
);
```
In this case, it becomes apparent for TypeScript that there is a direct connection between skipping and the `variables` option - and it will work without unsafe workarounds.

</blockquote>
