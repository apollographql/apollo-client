## API Report File for "@apollo/client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { DocumentNode } from 'graphql';
import type { FieldNode } from 'graphql';
import type { FragmentDefinitionNode } from 'graphql';
import type { InlineFragmentNode } from 'graphql';
import { Observable } from 'zen-observable-ts';
import { TypedDocumentNode } from '@graphql-typed-document-node/core';

// Warning: (ae-forgotten-export) The symbol "Modifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "StoreObjectValueMaybeReference" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<Entity[keyof Entity] extends infer Value ? StoreObjectValueMaybeReference<Exclude<Value, undefined>> : never>;

// Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
abstract class ApolloCache<TSerialized> implements DataProxy {
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    // (undocumented)
    batch<U>(options: Cache_2.BatchOptions<this, U>): U;
    // (undocumented)
    abstract diff<T>(query: Cache_2.DiffOptions): Cache_2.DiffResult<T>;
    // (undocumented)
    abstract evict(options: Cache_2.EvictOptions): boolean;
    abstract extract(optimistic?: boolean): TSerialized;
    // (undocumented)
    fragmentMatches?(fragment: InlineFragmentNode, typename: string): boolean;
    // (undocumented)
    gc(): string[];
    // Warning: (ae-forgotten-export) The symbol "getApolloCacheMemoryInternals" needs to be exported by the entry point index.d.ts
    //
    // @internal
    getMemoryInternals?: typeof getApolloCacheMemoryInternals;
    // Warning: (ae-forgotten-export) The symbol "StoreObject" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // (undocumented)
    lookupFragment(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_2.ModifyOptions<Entity>): boolean;
    // Warning: (ae-forgotten-export) The symbol "Transaction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract performTransaction(transaction: Transaction<TSerialized>, optimisticId?: string | null): void;
    // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract read<TData = any, TVariables = any>(query: Cache_2.ReadOptions<TVariables, TData>): Unmasked<TData> | null;
    // (undocumented)
    readFragment<FragmentType, TVariables = any>(options: Cache_2.ReadFragmentOptions<FragmentType, TVariables>, optimistic?: boolean): Unmasked<FragmentType> | null;
    // (undocumented)
    readQuery<QueryType, TVariables = any>(options: Cache_2.ReadQueryOptions<QueryType, TVariables>, optimistic?: boolean): Unmasked<QueryType> | null;
    // (undocumented)
    recordOptimisticTransaction(transaction: Transaction<TSerialized>, optimisticId: string): void;
    // (undocumented)
    abstract removeOptimistic(id: string): void;
    // (undocumented)
    abstract reset(options?: Cache_2.ResetOptions): Promise<void>;
    abstract restore(serializedState: TSerialized): ApolloCache<TSerialized>;
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
    // (undocumented)
    transformForLink(document: DocumentNode): DocumentNode;
    // (undocumented)
    updateFragment<TData = any, TVariables = any>(options: Cache_2.UpdateFragmentOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    updateQuery<TData = any, TVariables = any>(options: Cache_2.UpdateQueryOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    abstract watch<TData = any, TVariables = any>(watch: Cache_2.WatchOptions<TData, TVariables>): () => void;
    // Warning: (ae-forgotten-export) The symbol "OperationVariables" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "WatchFragmentOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "WatchFragmentResult" needs to be exported by the entry point index.d.ts
    watchFragment<TData = any, TVars = OperationVariables>(options: WatchFragmentOptions<TData, TVars>): Observable<WatchFragmentResult<TData>>;
    // Warning: (ae-forgotten-export) The symbol "Reference" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract write<TData = any, TVariables = any>(write: Cache_2.WriteOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeFragment<TData = any, TVariables = any>({ id, data, fragment, fragmentName, ...options }: Cache_2.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeQuery<TData = any, TVariables = any>({ id, data, ...options }: Cache_2.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public
type AsStoreObject<T extends {
    __typename?: string;
}> = {
    [K in keyof T]: T[K];
};

// @public (undocumented)
namespace Cache_2 {
    // Warning: (ae-forgotten-export) The symbol "ApolloCache" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface BatchOptions<TCache extends ApolloCache<any>, TUpdateResult = void> {
        // (undocumented)
        onWatchUpdated?: (this: TCache, watch: Cache_2.WatchOptions, diff: Cache_2.DiffResult<any>, lastDiff?: Cache_2.DiffResult<any> | undefined) => any;
        // (undocumented)
        optimistic?: string | boolean;
        // (undocumented)
        removeOptimistic?: string;
        // (undocumented)
        update(cache: TCache): TUpdateResult;
    }
    // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface DiffOptions<TData = any, TVariables = any> extends Omit<ReadOptions<TVariables, TData>, "rootId"> {
    }
    // (undocumented)
    interface EvictOptions {
        // (undocumented)
        args?: Record<string, any>;
        // (undocumented)
        broadcast?: boolean;
        // (undocumented)
        fieldName?: string;
        // (undocumented)
        id?: string;
    }
    // (undocumented)
    interface ModifyOptions<Entity extends Record<string, any> = Record<string, any>> {
        // (undocumented)
        broadcast?: boolean;
        // Warning: (ae-forgotten-export) The symbol "Modifiers" needs to be exported by the entry point index.d.ts
        // Warning: (ae-forgotten-export) The symbol "AllFieldsModifier" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        fields: Modifiers<Entity> | AllFieldsModifier<Entity>;
        // (undocumented)
        id?: string;
        // (undocumented)
        optimistic?: boolean;
    }
    // (undocumented)
    interface ReadOptions<TVariables = any, TData = any> extends DataProxy.Query<TVariables, TData> {
        // @deprecated (undocumented)
        canonizeResults?: boolean;
        // (undocumented)
        optimistic: boolean;
        // (undocumented)
        previousResult?: any;
        // (undocumented)
        returnPartialData?: boolean;
        // (undocumented)
        rootId?: string;
    }
    // (undocumented)
    interface ResetOptions {
        // (undocumented)
        discardWatches?: boolean;
    }
    // (undocumented)
    type WatchCallback<TData = any> = (diff: Cache_2.DiffResult<TData>, lastDiff?: Cache_2.DiffResult<TData>) => void;
    // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface WatchOptions<TData = any, TVariables = any> extends DiffOptions<TData, TVariables> {
        // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        callback: WatchCallback<TData>;
        // (undocumented)
        immediate?: boolean;
        // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        lastDiff?: DiffResult<TData>;
        // (undocumented)
        watcher?: object;
    }
    // (undocumented)
    interface WriteOptions<TResult = any, TVariables = any> extends Omit<DataProxy.Query<TVariables, TResult>, "id">, Omit<DataProxy.WriteOptions<TResult>, "data"> {
        // (undocumented)
        dataId?: string;
        // (undocumented)
        result: Unmasked<TResult>;
    }
    import DiffResult = DataProxy.DiffResult;
    import ReadQueryOptions = DataProxy.ReadQueryOptions;
    import ReadFragmentOptions = DataProxy.ReadFragmentOptions;
    import WriteQueryOptions = DataProxy.WriteQueryOptions;
    import WriteFragmentOptions = DataProxy.WriteFragmentOptions;
    import UpdateQueryOptions = DataProxy.UpdateQueryOptions;
    import UpdateFragmentOptions = DataProxy.UpdateFragmentOptions;
    import Fragment = DataProxy.Fragment;
}

// Warning: (ae-forgotten-export) The symbol "StoreValue" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type CanReadFunction = (value: StoreValue) => boolean;

// Warning: (ae-forgotten-export) The symbol "Prettify" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MergeUnions" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExtractByMatchingTypeNames" needs to be exported by the entry point index.d.ts
//
// @public
type CombineByTypeName<T extends {
    __typename?: string;
}> = {
    [TypeName in NonNullable<T["__typename"]>]: Prettify<MergeUnions<ExtractByMatchingTypeNames<T, TypeName>>>;
}[NonNullable<T["__typename"]>];

// Warning: (ae-forgotten-export) The symbol "CombineByTypeName" needs to be exported by the entry point index.d.ts
//
// @public
type CombineIntersection<T> = Exclude<T, {
    __typename?: string;
}> | CombineByTypeName<Extract<T, {
    __typename?: string;
}>>;

// Warning: (ae-forgotten-export) The symbol "IsAny" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Exact" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RemoveIndexSignature" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ContainsFragmentsRefs<TData, Seen = never> = true extends (IsAny<TData>) ? false : TData extends object ? Exact<TData> extends Seen ? false : " $fragmentRefs" extends keyof RemoveIndexSignature<TData> ? true : ContainsFragmentsRefs<TData[keyof TData], Seen | Exact<TData>> : false;

// @public (undocumented)
export interface DataMasking {
}

// @public (undocumented)
namespace DataProxy {
    // (undocumented)
    type DiffResult<T> = {
        result?: T;
        complete?: boolean;
        missing?: MissingFieldError[];
        fromOptimisticTransaction?: boolean;
    };
    // (undocumented)
    interface Fragment<TVariables, TData> {
        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        id?: string;
        variables?: TVariables;
    }
    // (undocumented)
    interface Query<TVariables, TData> {
        id?: string;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        variables?: TVariables;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface ReadFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData> {
        // @deprecated
        canonizeResults?: boolean;
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface ReadQueryOptions<TData, TVariables> extends Query<TVariables, TData> {
        // @deprecated
        canonizeResults?: boolean;
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface UpdateFragmentOptions<TData, TVariables> extends Omit<ReadFragmentOptions<TData, TVariables> & WriteFragmentOptions<TData, TVariables>, "data"> {
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface UpdateQueryOptions<TData, TVariables> extends Omit<ReadQueryOptions<TData, TVariables> & WriteQueryOptions<TData, TVariables>, "data"> {
    }
    // (undocumented)
    interface WriteFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData>, WriteOptions<TData> {
    }
    // (undocumented)
    interface WriteOptions<TData> {
        broadcast?: boolean;
        data: Unmasked<TData>;
        overwrite?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface WriteQueryOptions<TData, TVariables> extends Query<TVariables, TData>, WriteOptions<TData> {
    }
}

// @public
interface DataProxy {
    readFragment<FragmentType, TVariables = any>(options: DataProxy.ReadFragmentOptions<FragmentType, TVariables>, optimistic?: boolean): Unmasked<FragmentType> | null;
    readQuery<QueryType, TVariables = any>(options: DataProxy.ReadQueryOptions<QueryType, TVariables>, optimistic?: boolean): Unmasked<QueryType> | null;
    writeFragment<TData = any, TVariables = any>(options: DataProxy.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    writeQuery<TData = any, TVariables = any>(options: DataProxy.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// Warning: (ae-forgotten-export) The symbol "DeepPartialPrimitive" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialReadonlyMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialSet" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialReadonlySet" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepPartial<T> = T extends DeepPartialPrimitive ? T : T extends Map<infer TKey, infer TValue> ? DeepPartialMap<TKey, TValue> : T extends ReadonlyMap<infer TKey, infer TValue> ? DeepPartialReadonlyMap<TKey, TValue> : T extends Set<infer TItem> ? DeepPartialSet<TItem> : T extends ReadonlySet<infer TItem> ? DeepPartialReadonlySet<TItem> : T extends (...args: any[]) => unknown ? T | undefined : T extends object ? T extends (ReadonlyArray<infer TItem>) ? TItem[] extends (T) ? readonly TItem[] extends T ? ReadonlyArray<DeepPartial<TItem | undefined>> : Array<DeepPartial<TItem | undefined>> : DeepPartialObject<T> : DeepPartialObject<T> : unknown;

// Warning: (ae-forgotten-export) The symbol "DeepPartial" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepPartialMap<TKey, TValue> = {} & Map<DeepPartial<TKey>, DeepPartial<TValue>>;

// @public (undocumented)
type DeepPartialObject<T extends object> = {
    [K in keyof T]?: DeepPartial<T[K]>;
};

// Warning: (ae-forgotten-export) The symbol "Primitive" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepPartialPrimitive = Primitive | Date | RegExp;

// @public (undocumented)
type DeepPartialReadonlyMap<TKey, TValue> = {} & ReadonlyMap<DeepPartial<TKey>, DeepPartial<TValue>>;

// @public (undocumented)
type DeepPartialReadonlySet<T> = {} & ReadonlySet<DeepPartial<T>>;

// @public (undocumented)
type DeepPartialSet<T> = {} & Set<DeepPartial<T>>;

// @public (undocumented)
interface DeleteModifier {
    // (undocumented)
    [_deleteModifier]: true;
}

// @public (undocumented)
const _deleteModifier: unique symbol;

// @internal (undocumented)
export const disableWarningsSlot: {
    readonly id: string;
    hasValue(): boolean;
    getValue(): boolean | undefined;
    withValue<TResult, TArgs extends any[], TThis = any>(value: boolean, callback: (this: TThis, ...args: TArgs) => TResult, args?: TArgs | undefined, thisArg?: TThis | undefined): TResult;
};

// @public (undocumented)
type DistributedRequiredExclude<T, U> = T extends any ? Required<T> extends Required<U> ? Required<U> extends Required<T> ? never : T : T : T;

// @public (undocumented)
type Exact<in out T> = (x: T) => T;

// @public
type ExtractByMatchingTypeNames<Union extends {
    __typename?: string;
}, TypeName extends string> = Union extends any ? TypeName extends NonNullable<Union["__typename"]> ? Omit<Union, "__typename"> & {
    [K in keyof Union as K extends "__typename" ? K : never]: TypeName;
} : never : never;

// @public (undocumented)
interface FieldSpecifier {
    // (undocumented)
    args?: Record<string, any>;
    // (undocumented)
    field?: FieldNode;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    typename?: string;
    // (undocumented)
    variables?: Record<string, any>;
}

// @public (undocumented)
export type FragmentType<TData> = [
TData
] extends [{
    " $fragmentName"?: infer TKey;
}] ? TKey extends string ? {
    " $fragmentRefs"?: {
        [key in TKey]: TData;
    };
} : never : never;

// @internal
const getApolloCacheMemoryInternals: (() => {
    cache: {
        fragmentQueryDocuments: number | undefined;
    };
}) | undefined;

// @public (undocumented)
interface InvalidateModifier {
    // (undocumented)
    [_invalidateModifier]: true;
}

// @public (undocumented)
const _invalidateModifier: unique symbol;

// @public (undocumented)
type IsAny<T> = 0 extends 1 & T ? true : false;

// @public (undocumented)
function isReference(obj: any): obj is Reference;

// @public
export type Masked<TData> = TData & {
    __masked?: true;
};

// @public
export type MaskedDocumentNode<TData = {
    [key: string]: any;
}, TVariables = {
    [key: string]: any;
}> = TypedDocumentNode<Masked<TData>, TVariables>;

// @internal (undocumented)
export function maskFragment<TData = unknown>(data: TData, document: TypedDocumentNode<TData> | DocumentNode, cache: ApolloCache<unknown>, fragmentName?: string): TData;

// @internal (undocumented)
export function maskOperation<TData = unknown>(data: TData, document: DocumentNode | TypedDocumentNode<TData>, cache: ApolloCache<unknown>): TData;

// Warning: (ae-forgotten-export) The symbol "RemoveMaskedMarker" needs to be exported by the entry point index.d.ts
//
// @public
export type MaybeMasked<TData> = DataMasking extends {
    mode: "unmask";
} ? TData extends any ? true extends IsAny<TData> ? TData : TData extends {
    __masked?: true;
} ? Prettify<RemoveMaskedMarker<TData>> : Unmasked<TData> : never : DataMasking extends {
    mode: "preserveTypes";
} ? TData : TData;

// Warning: (ae-forgotten-export) The symbol "CombineIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeObjects<T, U> = Prettify<{
    [k in keyof T]: k extends keyof U ? [
    NonNullable<T[k]>,
    NonNullable<U[k]>
    ] extends ([
    infer TK extends object,
    infer UK extends object
    ]) ? TK extends unknown[] ? UK extends unknown[] ? CombineIntersection<TK[number] | UK[number]>[] | Extract<T[k] | U[k], undefined | null> : T[k] : CombineIntersection<TK | UK> | Extract<T[k] | U[k], undefined | null> : T[k] : T[k];
} & Pick<U, Exclude<keyof U, keyof T>>>;

// Warning: (ae-forgotten-export) The symbol "MergeUnionsAcc" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "takeOneFromUnion" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnions<TUnion> = MergeUnionsAcc<TUnion, takeOneFromUnion<TUnion>, never>;

// Warning: (ae-forgotten-export) The symbol "DistributedRequiredExclude" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MergeObjects" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnionsAcc<TUnion, Curr, Merged> = [
Curr
] extends [never] ? Merged : MergeUnionsAcc<DistributedRequiredExclude<TUnion, Curr>, takeOneFromUnion<DistributedRequiredExclude<TUnion, Curr>>, [
Merged
] extends [never] ? Curr : MergeObjects<Curr, Merged>>;

// @public (undocumented)
class MissingFieldError extends Error {
    constructor(message: string, path: MissingTree | Array<string | number>, query: DocumentNode, variables?: Record<string, any> | undefined);
    // (undocumented)
    readonly message: string;
    // (undocumented)
    readonly missing: MissingTree;
    // Warning: (ae-forgotten-export) The symbol "MissingTree" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly path: MissingTree | Array<string | number>;
    // (undocumented)
    readonly query: DocumentNode;
    // (undocumented)
    readonly variables?: Record<string, any> | undefined;
}

// @public (undocumented)
type MissingTree = string | {
    readonly [key: string]: MissingTree;
};

// Warning: (ae-forgotten-export) The symbol "ModifierDetails" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeleteModifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "InvalidateModifier" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Modifier<T> = (value: T, details: ModifierDetails) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;

// @public (undocumented)
type ModifierDetails = {
    DELETE: DeleteModifier;
    INVALIDATE: InvalidateModifier;
    fieldName: string;
    storeFieldName: string;
    readField: ReadFieldFunction;
    canRead: CanReadFunction;
    isReference: typeof isReference;
    toReference: ToReferenceFunction;
    storage: StorageType;
};

// @public (undocumented)
type Modifiers<T extends Record<string, any> = Record<string, unknown>> = Partial<{
    [FieldName in keyof T]: Modifier<StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>>;
}>;

// @public
type NoInfer_2<T> = [T][T extends any ? 0 : never];

// @public (undocumented)
type OperationVariables = Record<string, any>;

// @public (undocumented)
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};

// @public (undocumented)
type Primitive = null | undefined | string | number | boolean | symbol | bigint;

// @public (undocumented)
interface ReadFieldFunction {
    // Warning: (ae-forgotten-export) The symbol "ReadFieldOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "SafeReadonly" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;
    // (undocumented)
    <V = StoreValue>(fieldName: string, from?: StoreObject | Reference): SafeReadonly<V> | undefined;
}

// Warning: (ae-forgotten-export) The symbol "FieldSpecifier" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface ReadFieldOptions extends FieldSpecifier {
    // (undocumented)
    from?: StoreObject | Reference;
}

// @public (undocumented)
interface Reference {
    // (undocumented)
    readonly __ref: string;
}

// @public (undocumented)
type RemoveFragmentName<T> = T extends any ? Omit<T, " $fragmentName"> : T;

// @public (undocumented)
type RemoveIndexSignature<T> = {
    [K in keyof T as string extends K ? never : number extends K ? never : symbol extends K ? never : K]: T[K];
};

// @public (undocumented)
type RemoveMaskedMarker<T> = Omit<T, "__masked">;

// @public (undocumented)
type SafeReadonly<T> = T extends object ? Readonly<T> : T;

// @public (undocumented)
type StorageType = Record<string, any>;

// @public (undocumented)
interface StoreObject {
    // (undocumented)
    [storeFieldName: string]: StoreValue;
    // (undocumented)
    __typename?: string;
}

// Warning: (ae-forgotten-export) The symbol "AsStoreObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type StoreObjectValueMaybeReference<StoreVal> = StoreVal extends Array<Record<string, any>> ? StoreVal extends Array<infer Item> ? [
Item
] extends [Record<string, any>] ? ReadonlyArray<AsStoreObject<Item> | Reference> : never : never : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference : StoreVal;

// @public (undocumented)
type StoreValue = number | string | string[] | Reference | Reference[] | null | undefined | void | Object;

// Warning: (ae-forgotten-export) The symbol "unionToIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type takeOneFromUnion<T> = unionToIntersection<T extends T ? (x: T) => 0 : never> extends ((x: infer U) => 0) ? U : never;

// @public (undocumented)
type ToReferenceFunction = (objOrIdOrRef: StoreObject | string | Reference, mergeIntoStore?: boolean) => Reference | undefined;

// @public (undocumented)
type Transaction<T> = (c: ApolloCache<T>) => void;

// @public (undocumented)
type unionToIntersection<T> = (T extends unknown ? (x: T) => unknown : never) extends ((x: infer U) => unknown) ? U : never;

// Warning: (ae-forgotten-export) The symbol "ContainsFragmentsRefs" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "UnwrapFragmentRefs" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RemoveFragmentName" needs to be exported by the entry point index.d.ts
//
// @public
export type Unmasked<TData> = true extends IsAny<TData> ? TData : TData extends object ? true extends ContainsFragmentsRefs<TData> ? UnwrapFragmentRefs<RemoveMaskedMarker<RemoveFragmentName<TData>>> : TData : TData;

// @public (undocumented)
type UnwrapFragmentRefs<TData> = true extends IsAny<TData> ? TData : TData extends any ? TData extends Primitive ? TData : string extends keyof TData ? TData : keyof TData extends never ? TData : TData extends {
    " $fragmentRefs"?: infer FragmentRefs;
} ? UnwrapFragmentRefs<CombineIntersection<Omit<TData, " $fragmentRefs"> | RemoveFragmentName<NonNullable<NonNullable<FragmentRefs>[keyof NonNullable<FragmentRefs>]>>>> : TData extends object ? {
    [K in keyof TData]: UnwrapFragmentRefs<TData[K]>;
} : TData : never;

// @public
interface WatchFragmentOptions<TData, TVars> {
    fragment: DocumentNode | TypedDocumentNode<TData, TVars>;
    fragmentName?: string;
    // Warning: (ae-forgotten-export) The symbol "NoInfer_2" needs to be exported by the entry point index.d.ts
    from: StoreObject | Reference | FragmentType<NoInfer_2<TData>> | string;
    optimistic?: boolean;
    variables?: TVars;
}

// @public
type WatchFragmentResult<TData> = {
    data: MaybeMasked<TData>;
    complete: true;
    missing?: never;
} | {
    data: DeepPartial<MaybeMasked<TData>>;
    complete: false;
    missing: MissingTree;
};

// Warnings were encountered during analysis:
//
// src/cache/core/types/DataProxy.ts:147:7 - (ae-forgotten-export) The symbol "MissingFieldError" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:101:3 - (ae-forgotten-export) The symbol "ReadFieldFunction" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:102:3 - (ae-forgotten-export) The symbol "CanReadFunction" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:103:3 - (ae-forgotten-export) The symbol "isReference" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:104:3 - (ae-forgotten-export) The symbol "ToReferenceFunction" needs to be exported by the entry point index.d.ts
// src/cache/core/types/common.ts:105:3 - (ae-forgotten-export) The symbol "StorageType" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
