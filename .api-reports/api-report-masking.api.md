## API Report File for "@apollo/client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { TypedDocumentNode } from '@graphql-typed-document-node/core';

// Warning: (ae-forgotten-export) The symbol "Prettify" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MergeUnions" needs to be exported by the entry point index.d.ts
//
// @public
type CombineByTypeName<T extends {
    __typename?: string;
}> = {
    [TypeName in NonNullable<T["__typename"]>]: Extract<T, {
        __typename?: TypeName;
    }> extends infer SubSelection ? Prettify<MergeUnions<SubSelection>> : never;
}[NonNullable<T["__typename"]>];

// Warning: (ae-forgotten-export) The symbol "CombineByTypeName" needs to be exported by the entry point index.d.ts
//
// @public
type CombineIntersection<T> = Exclude<T, {
    __typename?: string;
}> | CombineByTypeName<Extract<T, {
    __typename?: string;
}>>;

// @public (undocumented)
type ContainsFragmentsRefs<TData> = TData extends object ? " $fragmentRefs" extends keyof TData ? true : ContainsFragmentsRefs<TData[keyof TData]> : false;

// @public (undocumented)
export interface DataMasking {
}

// @public (undocumented)
type DistributedRequiredExclude<T, U> = T extends any ? Required<T> extends Required<U> ? Required<U> extends Required<T> ? never : T : T : T;

// @public (undocumented)
export type FragmentType<TData> = [
TData
] extends [{
    " $fragmentName"?: infer TKey;
}] ? TKey extends string ? {
    " $fragmentRefs"?: {
        [key in TKey]: TData;
    };
} : never : never;

// @public (undocumented)
type IsAny<T> = 0 extends 1 & T ? true : false;

// @public
export type Masked<TData> = TData & {
    __masked?: true;
};

// @public
export type MaskedDocumentNode<TData = {
    [key: string]: any;
}, TVariables = {
    [key: string]: any;
}> = TypedDocumentNode<Masked<TData>, TVariables>;

// Warning: (ae-forgotten-export) The symbol "IsAny" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RemoveMaskedMarker" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ContainsFragmentsRefs" needs to be exported by the entry point index.d.ts
//
// @public
export type MaybeMasked<TData> = TData extends any ? true extends IsAny<TData> ? TData : TData extends {
    __masked?: true;
} ? Prettify<RemoveMaskedMarker<TData>> : DataMasking extends {
    enabled: true;
} ? TData : true extends ContainsFragmentsRefs<TData> ? Unmasked<TData> : TData : never;

// Warning: (ae-forgotten-export) The symbol "CombineIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeObjects<T, U> = Prettify<{
    [k in keyof T]: k extends keyof U ? [
    NonNullable<T[k]>,
    NonNullable<U[k]>
    ] extends ([
    infer TK extends object,
    infer UK extends object
    ]) ? TK extends unknown[] ? UK extends unknown[] ? CombineIntersection<TK[number] | UK[number]>[] | Extract<T[k] | U[k], undefined | null> : T[k] : CombineIntersection<TK | UK> | Extract<T[k] | U[k], undefined | null> : T[k] : T[k];
} & Pick<U, Exclude<keyof U, keyof T>>>;

// Warning: (ae-forgotten-export) The symbol "MergeUnionsAcc" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "takeOneFromUnion" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnions<TUnion> = MergeUnionsAcc<TUnion, takeOneFromUnion<TUnion>, never>;

// Warning: (ae-forgotten-export) The symbol "DistributedRequiredExclude" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MergeObjects" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnionsAcc<TUnion, Curr, Merged> = [
Curr
] extends [never] ? Merged : MergeUnionsAcc<DistributedRequiredExclude<TUnion, Curr>, takeOneFromUnion<DistributedRequiredExclude<TUnion, Curr>>, [
Merged
] extends [never] ? Curr : MergeObjects<Curr, Merged>>;

// @public (undocumented)
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};

// @public (undocumented)
type RemoveFragmentName<T> = T extends any ? Omit<T, " $fragmentName"> : T;

// @public (undocumented)
type RemoveMaskedMarker<T> = Omit<T, "__masked">;

// Warning: (ae-forgotten-export) The symbol "unionToIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type takeOneFromUnion<T> = unionToIntersection<T extends T ? (x: T) => 0 : never> extends ((x: infer U) => 0) ? U : never;

// @public (undocumented)
type unionToIntersection<T> = (T extends unknown ? (x: T) => unknown : never) extends ((x: infer U) => unknown) ? U : never;

// Warning: (ae-forgotten-export) The symbol "UnwrapFragmentRefs" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RemoveFragmentName" needs to be exported by the entry point index.d.ts
//
// @public
export type Unmasked<TData> = true extends IsAny<TData> ? TData : TData extends object ? UnwrapFragmentRefs<RemoveMaskedMarker<RemoveFragmentName<TData>>> : TData;

// @public (undocumented)
type UnwrapFragmentRefs<TData> = true extends IsAny<TData> ? TData : TData extends any ? string extends keyof TData ? TData : keyof TData extends never ? TData : TData extends {
    " $fragmentRefs"?: infer FragmentRefs;
} ? UnwrapFragmentRefs<CombineIntersection<Omit<TData, " $fragmentRefs"> | RemoveFragmentName<NonNullable<NonNullable<FragmentRefs>[keyof NonNullable<FragmentRefs>]>>>> : TData extends Array<infer TItem> ? Array<UnwrapFragmentRefs<TItem>> : TData extends object ? {
    [K in keyof TData]: UnwrapFragmentRefs<TData[K]>;
} : TData : never;

// (No @packageDocumentation comment for this package)

```
