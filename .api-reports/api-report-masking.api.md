## API Report File for "@apollo/client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { ApolloCache } from '@apollo/client/core';
import type { DocumentNode } from '@apollo/client/core';
import type { Prettify } from '@apollo/client/utilities';
import type { Primitive } from '@apollo/client/utilities';
import type { RemoveIndexSignature } from '@apollo/client/utilities';
import type { TypedDocumentNode } from '@graphql-typed-document-node/core';
import type { TypedDocumentNode as TypedDocumentNode_2 } from '@apollo/client/core';

// Warning: (ae-forgotten-export) The symbol "MergeUnions" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExtractByMatchingTypeNames" needs to be exported by the entry point index.d.ts
//
// @public
type CombineByTypeName<T extends {
    __typename?: string;
}> = {
    [TypeName in NonNullable<T["__typename"]>]: Prettify<MergeUnions<ExtractByMatchingTypeNames<T, TypeName>>>;
}[NonNullable<T["__typename"]>];

// Warning: (ae-forgotten-export) The symbol "CombineByTypeName" needs to be exported by the entry point index.d.ts
//
// @public
type CombineIntersection<T> = Exclude<T, {
    __typename?: string;
}> | CombineByTypeName<Extract<T, {
    __typename?: string;
}>>;

// Warning: (ae-forgotten-export) The symbol "IsAny" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Exact" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ContainsFragmentsRefs<TData, Seen = never> = true extends (IsAny<TData>) ? false : TData extends object ? Exact<TData> extends Seen ? false : " $fragmentRefs" extends keyof RemoveIndexSignature<TData> ? true : ContainsFragmentsRefs<TData[keyof TData], Seen | Exact<TData>> : false;

// @public (undocumented)
export interface DataMasking {
}

// @internal (undocumented)
export const disableWarningsSlot: {
    readonly id: string;
    hasValue(): boolean;
    getValue(): boolean | undefined;
    withValue<TResult, TArgs extends any[], TThis = any>(value: boolean, callback: (this: TThis, ...args: TArgs) => TResult, args?: TArgs | undefined, thisArg?: TThis | undefined): TResult;
};

// @public (undocumented)
type DistributedRequiredExclude<T, U> = T extends any ? Required<T> extends Required<U> ? Required<U> extends Required<T> ? never : T : T : T;

// @public (undocumented)
type Exact<in out T> = (x: T) => T;

// @public
type ExtractByMatchingTypeNames<Union extends {
    __typename?: string;
}, TypeName extends string> = Union extends any ? TypeName extends NonNullable<Union["__typename"]> ? Omit<Union, "__typename"> & {
    [K in keyof Union as K extends "__typename" ? K : never]: TypeName;
} : never : never;

// @public (undocumented)
export type FragmentType<TData> = [
TData
] extends [{
    " $fragmentName"?: infer TKey;
}] ? TKey extends string ? {
    " $fragmentRefs"?: {
        [key in TKey]: TData;
    };
} : never : never;

// @public (undocumented)
type IsAny<T> = 0 extends 1 & T ? true : false;

// @public
export type Masked<TData> = TData & {
    __masked?: true;
};

// @public
export type MaskedDocumentNode<TData = {
    [key: string]: any;
}, TVariables = {
    [key: string]: any;
}> = TypedDocumentNode<Masked<TData>, TVariables>;

// @internal (undocumented)
export function maskFragment<TData = unknown>(data: TData, document: TypedDocumentNode_2<TData> | DocumentNode, cache: ApolloCache, fragmentName?: string): TData;

// @internal (undocumented)
export function maskOperation<TData = unknown>(data: TData, document: DocumentNode | TypedDocumentNode_2<TData>, cache: ApolloCache): TData;

// Warning: (ae-forgotten-export) The symbol "RemoveMaskedMarker" needs to be exported by the entry point index.d.ts
//
// @public
export type MaybeMasked<TData> = DataMasking extends {
    mode: "unmask";
} ? TData extends any ? true extends IsAny<TData> ? TData : TData extends {
    __masked?: true;
} ? Prettify<RemoveMaskedMarker<TData>> : Unmasked<TData> : never : DataMasking extends {
    mode: "preserveTypes";
} ? TData : TData;

// Warning: (ae-forgotten-export) The symbol "CombineIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeObjects<T, U> = Prettify<{
    [k in keyof T]: k extends keyof U ? [
    NonNullable<T[k]>,
    NonNullable<U[k]>
    ] extends ([
    infer TK extends object,
    infer UK extends object
    ]) ? TK extends unknown[] ? UK extends unknown[] ? CombineIntersection<TK[number] | UK[number]>[] | Extract<T[k] | U[k], undefined | null> : T[k] : CombineIntersection<TK | UK> | Extract<T[k] | U[k], undefined | null> : T[k] : T[k];
} & Pick<U, Exclude<keyof U, keyof T>>>;

// Warning: (ae-forgotten-export) The symbol "MergeUnionsAcc" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "takeOneFromUnion" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnions<TUnion> = MergeUnionsAcc<TUnion, takeOneFromUnion<TUnion>, never>;

// Warning: (ae-forgotten-export) The symbol "DistributedRequiredExclude" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MergeObjects" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnionsAcc<TUnion, Curr, Merged> = [
Curr
] extends [never] ? Merged : MergeUnionsAcc<DistributedRequiredExclude<TUnion, Curr>, takeOneFromUnion<DistributedRequiredExclude<TUnion, Curr>>, [
Merged
] extends [never] ? Curr : MergeObjects<Curr, Merged>>;

// @public (undocumented)
type RemoveFragmentName<T> = T extends any ? Omit<T, " $fragmentName"> : T;

// @public (undocumented)
type RemoveMaskedMarker<T> = Omit<T, "__masked">;

// Warning: (ae-forgotten-export) The symbol "unionToIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type takeOneFromUnion<T> = unionToIntersection<T extends T ? (x: T) => 0 : never> extends ((x: infer U) => 0) ? U : never;

// @public (undocumented)
type unionToIntersection<T> = (T extends unknown ? (x: T) => unknown : never) extends ((x: infer U) => unknown) ? U : never;

// Warning: (ae-forgotten-export) The symbol "ContainsFragmentsRefs" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "UnwrapFragmentRefs" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RemoveFragmentName" needs to be exported by the entry point index.d.ts
//
// @public
export type Unmasked<TData> = true extends IsAny<TData> ? TData : TData extends object ? true extends ContainsFragmentsRefs<TData> ? UnwrapFragmentRefs<RemoveMaskedMarker<RemoveFragmentName<TData>>> : TData : TData;

// @public (undocumented)
type UnwrapFragmentRefs<TData> = true extends IsAny<TData> ? TData : TData extends any ? TData extends Primitive ? TData : string extends keyof TData ? TData : keyof TData extends never ? TData : TData extends {
    " $fragmentRefs"?: infer FragmentRefs;
} ? UnwrapFragmentRefs<CombineIntersection<Omit<TData, " $fragmentRefs"> | RemoveFragmentName<NonNullable<NonNullable<FragmentRefs>[keyof NonNullable<FragmentRefs>]>>>> : TData extends object ? {
    [K in keyof TData]: UnwrapFragmentRefs<TData[K]>;
} : TData : never;

// (No @packageDocumentation comment for this package)

```
