---
title: Suspense
description: Using React 18 Suspense features with Apollo Client
minVersion: 3.8.0
---

"Suspense" is both a specific React API ([`<Suspense />`](https://react.dev/reference/react/Suspense), a component which "lets you display a fallback until its children have finished loading"), and often used more generally to refer to a new way to build React apps using the [**concurrent rendering engine**](https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react) introduced in React 18.

In this guide, we'll look at Apollo Client's data fetching hooks introduced in 3.8 which leverage React's powerful concurrent features and walk through some examples of how they can be used.

> To follow along with the examples below, open up our [Suspense demo](https://codesandbox.io/s/github/apollographql/docs-examples/tree/main/apollo-client/v3/suspense-hooks?file=/src/App.tsx) on CodeSandbox.

## Fetching with Suspense

`useSuspenseQuery` initiates a network request and causes the component calling it to suspend while the request is in flight. It can be thought of as a Suspense-ready replacement for `useQuery` that allows you to take advantage of React's concurrent features while fetching during render.

More details on `useSuspenseQuery`'s API can be found in [its API docs](../api/react/hooks/#usesuspensequery).

> **Note:** a component using `useSuspenseQuery` to fetch data will **suspend on first render** unless it can access all of the data for the fields it is querying via the cache (or is configured with `returnPartialData: true` and partial data is present in the cache), so it **may not render until its initial network request finishes**. Keep this in mind and avoid creating "request waterfalls" whereby a series of components fetch data, suspend, receive data and render children which then initiate new network requests causing a "waterfall" of Suspense boundaries to display. In some scenarios this can be avoided by using `useBackgroundQuery` and `useReadQuery` (see below).

```tsx
import { Suspense } from 'react';
import {
  gql,
  TypedDocumentNode,
  useSuspenseQuery
} from '@apollo/client';

interface Data {
  dog: {
    id: string;
    name: string;
  };
}

interface Variables {
  id: string;
}

interface DogProps {
  id: string
}

const GET_DOG_QUERY: TypedDocumentNode<Data, Variables> = gql`
  query GetDog($id: String) {
    dog(id: $id) {
    # By default, an object's cache key is a combination of
    # its __typename and id fields, so we should always make
    # sure the id is in the response so our data can be
    # normalized and cached properly.
      id
      name
    }
  }
`;

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Dog id="3" />
    </Suspense>
  );
}

function Dog({ id }: DogProps) {
  const { data } = useSuspenseQuery(GET_DOG_QUERY, {
    variables: { id },
  });

  return <>Name: {data.dog.name}</>;
}
```

> **Note:** this example manually defines TypeScript interfaces for `Data` and `Variables` as well as the type for `GET_DOG_QUERY` using `TypedDocumentNode`. [GraphQL Code Generator](https://www.the-guild.dev/graphql/codegen) is a popular tool that will create these type definitions automatically for you. See the reference on [Using TypeScript](../development-testing/static-typing) for more information on integrating GraphQL Code Generator with Apollo Client.

In this example, our `App` component renders a `Dog` component which fetches the record for a single dog via `useSuspenseQuery`. When React attempts to render `Dog` for the first time, the cache is empty so `useSuspenseQuery` initiates a network request. `Dog` suspends while the network request is pending, triggering the nearest Suspense boundary _above_ the suspending component in `App` which renders our "Loading..." fallback. Once the network request is complete, `Dog` renders with the newly cached `name` for Mozzarella the Corgi.

You may have noticed that `useSuspenseQuery` does not return a `loading` boolean: this is because the component calling `useSuspenseQuery` will always suspend when fetching data. A corollary is that when it _does_ render, `data` is always defined! With React 18's concurrent features, Suspense fallbacks that exist **outside of suspending components** take the place of loading states that components were responsible for rendering themselves in the previous React paradigm.

> **Note for TypeScript users**: since `GET_DOG_QUERY` is a `TypedDocumentNode` in which we have specified the result type via `Data` generic, the TypeScript type for `data` returned by `useSuspenseQuery` reflects that! This means that `data` is guaranteed to be defined when `Dog` renders, and that `data.dog` will have the shape `{ id: string; name: string; breed: string; }`.

### Changing variables

In the previous example, we fetched the record for a single dog by passing a hard-coded `id` variable, Mozzarella, to `useSuspenseQuery`. Now, let's say we want to fetch the record for a different dog using a dynamic value instead. We'll fetch the list of dogs with just their `name` and `id`, and once the user selects an individual dog we can fetch more details, including their `breed`.

Let's take a look at some code:

```tsx
export const GET_DOG_QUERY: TypedDocumentNode<
  DogData,
  Variables
> = gql`
  query GetDog($id: String) {
    dog(id: $id) {
      id
      name
      breed
    }
  }
`;

export const GET_DOGS_QUERY: TypedDocumentNode<
  DogsData,
  Variables
> = gql`
  query GetDogs {
    dogs {
      id
      name
    }
  }
`;

function App() {
  const { data } = useSuspenseQuery(GET_DOGS_QUERY);
  const [selectedDog, setSelectedDog] = useState(
    data.dogs[0].id
  );

  return (
    <>
      <select
        onChange={(e) => setSelectedDog(e.target.value)}
      >
        {data.dogs.map(({ id, name }) => (
          <option key={id} value={id}>{dog.name}</option>
        ))}
      </select>
      <Suspense fallback={<div>Loading...</div>}>
        <Dog id={selectedDog} />
      </Suspense>
    </>
  );
}

function Dog({ id }: DogProps) {
  const { data } = useSuspenseQuery(GET_DOG_QUERY, {
    variables: { id },
  });

  return (
    <>
      <div>Name: {data.dog.name}</div>
      <div>Breed: {data.dog.breed}</div>
    </>
  );
}
```

Changing the dog via the `select` will cause the component to suspend each time we select a dog whose record **does not yet exist in the cache**. Once we've loaded a given dog's record in the cache, however, selecting that dog again from our dropdown will not cause the component to re-suspend, since under our default `cache-first` fetch policy Apollo Client will not make a network request after a cache hit.

### Updating state without suspending

While we may sometimes want to suspend while we update some state that results in a pending network request, there are many cases when we would prefer to keep displaying the previous render while React prepares to update in the background (thank you, Concurrent React!).

In these cases, we can use a pair of React APIs that allow us to update state without suspending: [`startTransition`](https://react.dev/reference/react/startTransition)/[`useTransition`](https://react.dev/reference/react/useTransition) and [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue). Please see the React documentation for a full set of usage examples and caveats.

Let's modify our code so that the previously displayed dog remains on the screen while the next one is fetched in the background:

```tsx {1,11-13}
import { useState, Suspense, startTransition } from "react";

function App() {
  const { data } = useSuspenseQuery(GET_DOGS_QUERY);
  const [selectedDog, setSelectedDog] = useState(
    data.dogs[0].id
  );

  return (
    <>
      <select
        onChange={(e) => {
          startTransition(() => {
            setSelectedDog(e.target.value);
          });
        }}
      >
        {data.dogs.map(({ id, name }) => (
          <option key={id} value={id}>{name}</option>
        ))}
      </select>
      <Suspense fallback={<div>Loading...</div>}>
        <Dog id={selectedDog} />
      </Suspense>
    </>
  );
}
```

By wrapping our call to `setSelectedDog` in our `App` component in React's `startTransition` method, we no longer see the Suspense fallback every time we select a new dog! Instead, the previous dog remains on the screen while the next dog's record is fetched in the background. Once the network request is complete, the new dog's record is immediately displayed.

### Rendering partial data

You may want to render your component immediately if partial data is available in the cache without suspending first. To do this, you can use the `returnPartialData` option **combined with one of two `fetchPolicy` settings**: `cache-first` (default) or `cache-and-network`.

> **A note on the `fetchPolicy` option:** when fetching data with `useSuspenseQuery` or `useBackgroundQuery`, the four supported fetch policies are `cache-first` (default), `network-only`, `no-cache` and `cache-and-network`. For details on these fetch policies, see [Setting a fetch policy](./queries/#setting-a-fetch-policy).

Consider how we can adjust our example `App` and `Dog` components to render partial data on first render:

```tsx
const GET_DOG_QUERY_PARTIAL: TypedDocumentNode = gql`
  query GetDog($id: String) {
    dog(id: $id) {
      id
      name
    }
  }
`;

function App() {
  const client = useApolloClient();

  // Write partial data for Buck to the cache
  // so it is available when Dog renders...
  client.cache.writeQuery({
    query: GET_DOG_QUERY_PARTIAL,
    variables: { id: "1" },
    data: { dog: { id: "1", name: "Buck" } },
  });

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Dog id="1" />
    </Suspense>
  );
}

function Dog({ id }: DogProps) {
  const { data } = useSuspenseQuery(GET_DOG_QUERY, {
    variables: { id },
    returnPartialData: true,
  });

  return (
    <>
      <div>Name: {data?.dog?.name}</div>
      <div>Breed: {data?.dog?.breed}</div>
    </>
  );
}
```

In this example, we write some partial data for Buck to the cache in `App` to simulate partial data already existing from a previous query with overlapping fields. When `Dog` attempts to render for the first time, it does **not** suspend. Instead, it renders with the partial data for Buck, displaying `Name: Buck` on the first line and `Breed:` with no value (`data.dog.breed` is initially `undefined` since we don't have a value for it in the cache). With a default `fetchPolicy` of `cache-first`, the cache registers the cache miss for the `breed` field and initiates a `GET_DOG_QUERY` network request.

The `Dog` component **does not suspend** while this request is being made. This is because we've opted to render partial data _instead_ of suspending by setting `returnPartialData: true`. Once the network request is complete, `Dog` re-renders with the `breed` now displayed.

> **Note for TypeScript users**: with `returnPartialData` set to `true`, the returned type for the `data` property will mark all fields in the query type as [optional](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties). Apollo Client cannot accurately determine which fields are present in the cache at any given time when returning partial data.

### Error handling

By default, errors are thrown by `useSuspenseQuery`. These errors will be caught and displayed by the closest [error boundary](https://react.dev/reference/react/Component#static-getderivedstatefromerror).

> **Note:** An error boundary is a **class component** that implements `static getDerivedStateFromError`. If you don't want to write an error boundary class component yourself, you can use a library like [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) instead. For more information, see the React docs for [catching rendering errors with an error boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary).

In Apollo Client's new `Suspense` hooks introduced in 3.8, **both network and GraphQL errors are thrown by default**. Let's take a look at an example:

```tsx
function App() {
  const { data } = useSuspenseQuery(GET_DOGS_QUERY);
  const [selectedDog, setSelectedDog] = useState(
    data.dogs[0].id
  );

  return (
    <>
      <select
        onChange={(e) => setSelectedDog(e.target.value)}
      >
        {data.dogs.map(({ id, name }) => (
          <option key={id} value={id}>
            {name}
          </option>
        ))}
      </select>
      <Suspense fallback={<div>Loading...</div>}>
        <Dog id={selectedDog} />
      </Suspense>
    </>
  );
}

function Dog({ id }: DogProps) {
  const { data } = useSuspenseQuery(GET_DOG_QUERY, {
    variables: { id },
  });

  return (
    <>
      <div>Name: {data.dog.name}</div>
      <div>Breed: {data.dog.breed}</div>
    </>
  );
}
```

If the `GET_DOG_QUERY` inside of the `Dog` component were to return with a GraphQL error or a network error, the `Dog` component would throw and the nearest error boundary would render its fallback component. But our component tree doesn't have an error boundary yet—let's add one!

```tsx {1,20-22,26}
import { ErrorBoundary } from "react-error-boundary";

function App() {
  const { data } = useSuspenseQuery(GET_DOGS_QUERY);
  const [selectedDog, setSelectedDog] = useState(
    data.dogs[0].id
  );

  return (
    <>
      <select
        onChange={(e) => setSelectedDog(e.target.value)}
      >
        {data.dogs.map(({ id, name }) => (
          <option key={id} value={id}>
            {name}
          </option>
        ))}
      </select>
      <ErrorBoundary
        FallbackComponent={() => <div>Something went wrong</div>}
      >
        <Suspense fallback={<div>Loading...</div>}>
          <Dog id={selectedDog} />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}
```

Here, we're using the `ErrorBoundary` component from [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) and placing it **outside** of our `Dog` component in our React component tree. Now, when our `Dog` component throws an error **when using the default `errorPolicy` of `none`**, the `ErrorBoundary` will catch it and display the `FallbackComponent` we've provided.

> **Note:** as is the case with many React frameworks, in development mode you may still see an error dialog overlay when errors are thrown even **with** an error boundary. This is because, while the error boundary provides useful information to users in production, in development mode many frameworks still want to make sure developers see the error in case it's unexpected.

#### Rendering partial data alongside errors

In some cases, you may want to ignore GraphQL errors and render partial data instead or alongside an error message. To do this, you can set the `errorPolicy` option to `ignore` (`graphQLErrors` are ignored and `error.graphQLErrors` is _not_ populated) or `all` (both `data` and `error.graphQLErrors` are populated, enabling you to render both partial results and error information).

Note that with both error policies of `ignore` and `all`, when encountering a **network error** Apollo Client's Suspense hooks will always throw an error wherever the data is being read (i.e. in the component calling `useSuspenseQuery` or `useReadQuery`).

### Distinguishing between queries with `queryKey`

By default, Apollo Client uses a query's `DocumentNode` and `Variables` to uniquely identify a query when using Apollo's `Suspense` data fetching hooks, `useSuspenseQuery` and `useBackgroundQuery`.

In practice, this means if you have two components both fetching data using the same `DocumentNode` and `variables`, they will both suspend when either component initiates or re-initiates a network request.

__In rare cases__, you may want to avoid suspending in one component when other components are fetching the same data with the same variables. To do this, you can use the `queryKey` option provided to either `useSuspenseQuery` or `useBackgroundQuery` to uniquely identify a query. When `queryKey` is provided, Apollo Client will use it to identify a query **in combination with its `DocumentNode` and `Variables`**. For more information, see [`useSuspenseQuery`](../api/react/hooks/#usesuspensequery) or [`useBackgroundQuery`](../api/react/hooks/#usebackgroundquery-and-usereadquery)'s API docs.

### `refetch`, `fetchMore` and `subscribeToMore`

Both `useSuspenseQuery` and `useBackgroundQuery` return functions for re-initiating the same query (with existing or new variables) or to fetch more paginated data. `useSuspenseQuery` also provides a `subscribeToMore` function to execute a subscription.

When using `useBackgroundQuery`, both `refetch` and `fetchMore` functions can be destructured from the second item in the tuple returned by the hook.

```tsx
function App() {
  const [queryRef, { refetch }] = useBackgroundQuery(
    GET_BREEDS_QUERY
  );

  const refetchHandler = () => {
    refetch();
  };

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Dog
        id="3"
        queryRef={queryRef}
        refetchHandler={refetchHandler}
      />
    </Suspense>
  );
}

interface DogProps {
  id: string;
  queryRef: QueryReference<BreedData>;
  refetchHandler: () => void;
}

function Dog({
  id,
  queryRef,
  refetchHandler,
}: DogProps) {
  const { data } = useSuspenseQuery(GET_DOG_QUERY, {
    variables: { id },
  });

  return (
    <>
      Name: {data.dog.name}
      <Suspense fallback={<div>Loading breeds...</div>}>
        <Breeds queryRef={queryRef} />
      </Suspense>
      <button onClick={refetchHandler}>Refetch!</button>
    </>
  );
}
```

In this example, every time the user clicks the "Refetch!" button rendered by the `Dog` component, our `refetchHandler` calls the `refetch` function returned by `useBackgroundQuery` which initiates a new network request for the `GET_BREEDS_QUERY` query. As a result, the `Breeds` component re-suspends while the new network request is pending.

## Avoiding request waterfalls

Since `useSuspenseQuery` will usually cause a component to suspend on first render while data is being fetched, a tree of components that all use `useSuspenseQuery` to query different data can cause a "waterfall" of Suspense boundaries to display since each component will suspend before rendering its children (which will then suspend while fetching, and so on). In some cases, this can be avoided by using `useBackgroundQuery` and `useReadQuery` instead.

`useBackgroundQuery` initiates a request for data in a parent component and returns a `QueryReference` which is then passed to `useReadQuery` to read the data in a child component. If the child component attempts to render before data is loaded, the child component will suspend. On cache updates to watched data, the child component calling `useReadQuery` will re-render with new data **but the parent component will not re-render** (as it would, for example, if `useQuery` was making the request in the parent).

Let's look at an example:

```tsx
import {
  useBackgroundQuery,
  useReadQuery,
  useSuspenseQuery,
} from '@apollo/client';

function App() {
  const [queryRef] = useBackgroundQuery(GET_BREEDS_QUERY);

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Dog id="3" queryRef={queryRef} />
    </Suspense>
  );
}

function Dog({ id, queryRef }: DogProps) {
  const { data } = useSuspenseQuery(GET_DOG_QUERY, {
    variables: { id },
  });

  return (
    <>
      Name: {data.dog.name}
      <Suspense fallback={<div>Loading breeds...</div>}>
        <Breeds queryRef={queryRef} />
      </Suspense>
    </>
  );
}

interface BreedsProps {
  queryRef: QueryReference<BreedData>;
}

function Breeds({ queryRef }: BreedsProps) {
  const { data } = useReadQuery(queryRef);

  return data.breeds.map(({ characteristics }) =>
    characteristics.map((characteristic) => (
      <div key={characteristic}>{characteristic}</div>
    ))
  );
}
```

Since we began fetching our `GET_BREEDS_QUERY` in the background when the parent `App` component mounted, the network request is made in the background while React attempts to render the rest of our component tree. When React reaches the `Dog` component, it immediately suspends as it makes a network request to fetch our `GET_DOG_QUERY`.

When the network request for `GET_DOG_QUERY` completes, the `Dog` component unsuspends and continues rendering, reaching the `Breeds` component. Since our `GET_BREEDS_QUERY` request was initiated higher up in our component tree using `useBackgroundQuery`, the network request for `GET_BREEDS_QUERY` **has already completed**! For that reason, when the `Breeds` component attempts to read the data using the `queryRef` for the original query, it **doesn't suspend**. Instead, it can render immediately with the data from the cache.

> **Note:** in a client-rendered application, `useBackgroundQuery` can be used to avoid request waterfalls, but its impact can be even more noticeable in an application using streaming SSR ([when using Apollo Client's Suspense hooks with Next.js's App Router](./#usage-with-nextjs-13-app-router), for example). This is because the server can begin streaming content to the client, bringing even greater performance benefits.

More details on `useBackgroundQuery` and `useReadQuery`'s API can be found in [their API docs](../api/react/hooks/#usebackgroundquery-and-usereadquery).

## React Server Components (RSC)

### Usage with Next.js 13 App Router

In Next.js v13, Next.js's new [App Router](https://nextjs.org/docs/app) brought the React community the first framework with full support for [React Server Components (RSC)](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components) and Streaming SSR, integrating Suspense as a first-class concept from your application's routing layer all the way down.

In order to integrate with these features, our Apollo Client team released an experimental package, [`@apollo/experimental-nextjs-app-support`](https://github.com/apollographql/apollo-client-nextjs), which allows for seamless use of Apollo Client with both RSC and Streaming SSR, one of the first of its kind for data fetching libraries. See its [README](https://github.com/apollographql/apollo-client-nextjs#readme) and our [introductory blog post](https://www.apollographql.com/blog/apollo-client/next-js/how-to-use-apollo-client-with-next-js-13/) for more details.

### Error handling

In a purely client-rendered app, errors thrown in components are always caught and displayed by the closest [error boundary](https://react.dev/reference/react/Component#static-getderivedstatefromerror).

Errors thrown on the server when using one of the [streaming server rendering APIs](https://react.dev/reference/react-dom/server) are treated differently. See the [React documentation](https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content) for more information.

## Further reading

To view a larger codebase that makes use of Apollo Client's Suspense hooks (and many other new features introduced in Apollo Client 3.8), check out Apollo's [Spotify Showcase](https://github.com/apollographql/spotify-showcase) on GitHub. It's a full-stack web application that pays homage to Spotify's iconic UI by building a clone using Apollo Client, Apollo Server and GraphOS.
