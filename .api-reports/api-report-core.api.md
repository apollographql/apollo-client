## API Report File for "@apollo/client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ApolloCache } from '@apollo/client/cache';
import type { ApolloCache as ApolloCache_3 } from '@apollo/client/core';
import { ApolloLink } from '@apollo/client/link/core';
import { ApolloPayloadResult } from '@apollo/client/link/core';
import type { AsStoreObject } from '@apollo/client/utilities';
import type { ASTNode } from 'graphql';
import { Cache as Cache_2 } from '@apollo/client/cache';
import { checkFetcher } from '@apollo/client/link/http';
import { ClientParseError } from '@apollo/client/link/http';
import { CombinedGraphQLErrors } from '@apollo/client/errors';
import { CombinedProtocolErrors } from '@apollo/client/errors';
import { concat } from '@apollo/client/link/core';
import { createHttpLink } from '@apollo/client/link/http';
import { createSignalIfSupported } from '@apollo/client/link/http';
import { DataMasking } from '@apollo/client/masking';
import { DataProxy } from '@apollo/client/cache';
import type { DeepPartial } from '@apollo/client/utilities';
import { defaultDataIdFromObject } from '@apollo/client/cache';
import { defaultPrinter } from '@apollo/client/link/http';
import { disableExperimentalFragmentVariables } from 'graphql-tag';
import { disableFragmentWarnings } from 'graphql-tag';
import { DocumentNode } from '@apollo/client/link/core';
import type { DocumentNode as DocumentNode_2 } from 'graphql';
import { DocumentTransform } from '@apollo/client/utilities';
import { DocumentTransformCacheKey } from '@apollo/client/utilities';
import { empty } from '@apollo/client/link/core';
import { enableExperimentalFragmentVariables } from 'graphql-tag';
import { execute } from '@apollo/client/link/core';
import { ExecutionPatchIncrementalResult } from '@apollo/client/link/core';
import { ExecutionPatchInitialResult } from '@apollo/client/link/core';
import { ExecutionPatchResult } from '@apollo/client/link/core';
import { fallbackHttpConfig } from '@apollo/client/link/http';
import { FetchResult } from '@apollo/client/link/core';
import { FieldFunctionOptions } from '@apollo/client/cache';
import { FieldMergeFunction } from '@apollo/client/cache';
import type { FieldNode } from 'graphql';
import { FieldPolicy } from '@apollo/client/cache';
import { FieldReadFunction } from '@apollo/client/cache';
import type { FormattedExecutionResult } from 'graphql';
import type { FragmentDefinitionNode } from 'graphql';
import type { FragmentMap } from '@apollo/client/utilities';
import type { FragmentMapFunction } from '@apollo/client/utilities';
import { FragmentType } from '@apollo/client/masking';
import { from } from '@apollo/client/link/core';
import { getApolloCacheMemoryInternals } from '@apollo/client/utilities/internal';
import { getApolloClientMemoryInternals } from '@apollo/client/utilities/internal';
import { getInMemoryCacheMemoryInternals } from '@apollo/client/utilities/internal';
import { gql } from 'graphql-tag';
import { GraphQLRequest } from '@apollo/client/link/core';
import { HttpLink } from '@apollo/client/link/http';
import { HttpOptions } from '@apollo/client/link/http';
import { IncrementalPayload } from '@apollo/client/link/core';
import type { InlineFragmentNode } from 'graphql';
import { InMemoryCache } from '@apollo/client/cache';
import { InMemoryCacheConfig } from '@apollo/client/cache';
import type { InteropObservable } from 'rxjs';
import { isReference } from '@apollo/client/utilities';
import type { IsStrictlyAny } from '@apollo/client/utilities';
import { makeReference } from '@apollo/client/utilities';
import { makeVar } from '@apollo/client/cache';
import { Masked } from '@apollo/client/masking';
import { MaskedDocumentNode } from '@apollo/client/masking';
import { MaybeMasked } from '@apollo/client/masking';
import { mergeOptions } from '@apollo/client/utilities';
import { MissingFieldError } from '@apollo/client/cache';
import { NextLink } from '@apollo/client/link/core';
import type { NoInfer as NoInfer_2 } from '@apollo/client/utilities';
import { Observable } from '@apollo/client/utilities';
import { Observable as Observable_2 } from 'rxjs';
import type { Observer } from 'rxjs';
import { Operation } from '@apollo/client/link/core';
import type { OperationVariables as OperationVariables_2 } from '@apollo/client/core';
import { parseAndCheckHttpResponse } from '@apollo/client/link/http';
import { Path } from '@apollo/client/link/core';
import { PossibleTypesMap } from '@apollo/client/cache';
import { ReactiveVar } from '@apollo/client/cache';
import { Reference } from '@apollo/client/utilities';
import type { Reference as Reference_2 } from '@apollo/client/cache';
import { RequestHandler } from '@apollo/client/link/core';
import { resetCaches } from 'graphql-tag';
import { rewriteURIForGET } from '@apollo/client/link/http';
import { selectHttpOptionsAndBody } from '@apollo/client/link/http';
import { selectHttpOptionsAndBodyInternal } from '@apollo/client/link/http';
import type { SelectionSetNode } from 'graphql';
import { selectURI } from '@apollo/client/link/http';
import { serializeFetchParameter } from '@apollo/client/link/http';
import { ServerError } from '@apollo/client/errors';
import { ServerParseError } from '@apollo/client/errors';
import { setVerbosity as setLogVerbosity } from '@apollo/client/utilities/invariant';
import { SingleExecutionResult } from '@apollo/client/link/core';
import { split } from '@apollo/client/link/core';
import { StoreObject } from '@apollo/client/utilities';
import type { StoreValue } from '@apollo/client/utilities';
import type { Subscribable } from 'rxjs';
import type { Subscription } from 'rxjs';
import { Transaction } from '@apollo/client/cache';
import { Trie } from '@wry/trie';
import { TypedDocumentNode } from '@graphql-typed-document-node/core';
import type { TypedDocumentNode as TypedDocumentNode_2 } from '@apollo/client/core';
import { TypePolicies } from '@apollo/client/cache';
import { TypePolicy } from '@apollo/client/cache';
import { UnconventionalError } from '@apollo/client/errors';
import { Unmasked } from '@apollo/client/masking';
import { UriFunction } from '@apollo/client/link/http';
import { WatchFragmentOptions } from '@apollo/client/cache';
import { WatchFragmentResult } from '@apollo/client/cache';

// Warning: (ae-forgotten-export) The symbol "Modifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "StoreObjectValueMaybeReference" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<Entity[keyof Entity] extends infer Value ? StoreObjectValueMaybeReference<Exclude<Value, undefined>> : never>;

export { ApolloCache }

// Warning: (ae-forgotten-export) The symbol "DataProxy_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
abstract class ApolloCache_2 implements DataProxy_2 {
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    // (undocumented)
    batch<U>(options: Cache_3.BatchOptions<this, U>): U;
    abstract diff<TData = unknown, TVariables extends OperationVariables_2 = OperationVariables_2>(query: Cache_3.DiffOptions<TData, TVariables>): Cache_3.DiffResult<TData>;
    // (undocumented)
    abstract evict(options: Cache_3.EvictOptions): boolean;
    abstract extract(optimistic?: boolean): unknown;
    // (undocumented)
    fragmentMatches?(fragment: InlineFragmentNode, typename: string): boolean;
    // (undocumented)
    gc(): string[];
    // @internal
    getMemoryInternals?: typeof getApolloCacheMemoryInternals;
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // (undocumented)
    lookupFragment(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_3.ModifyOptions<Entity>): boolean;
    // Warning: (ae-forgotten-export) The symbol "Transaction_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract performTransaction(transaction: Transaction_2, optimisticId?: string | null): void;
    // Warning: (ae-forgotten-export) The symbol "Cache_3" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract read<TData = unknown, TVariables = OperationVariables_2>(query: Cache_3.ReadOptions<TVariables, TData>): Unmasked<TData> | null;
    // (undocumented)
    readFragment<TData = unknown, TVariables = OperationVariables_2>(options: Cache_3.ReadFragmentOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    // (undocumented)
    readQuery<TData = unknown, TVariables = OperationVariables_2>(options: Cache_3.ReadQueryOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    // (undocumented)
    recordOptimisticTransaction(transaction: Transaction_2, optimisticId: string): void;
    // (undocumented)
    abstract removeOptimistic(id: string): void;
    // (undocumented)
    abstract reset(options?: Cache_3.ResetOptions): Promise<void>;
    abstract restore(serializedState: unknown): this;
    // (undocumented)
    transformDocument(document: DocumentNode_2): DocumentNode_2;
    // (undocumented)
    transformForLink(document: DocumentNode_2): DocumentNode_2;
    // (undocumented)
    updateFragment<TData = unknown, TVariables = OperationVariables_2>(options: Cache_3.UpdateFragmentOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    updateQuery<TData = unknown, TVariables = OperationVariables_2>(options: Cache_3.UpdateQueryOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    abstract watch<TData = unknown, TVariables = OperationVariables_2>(watch: Cache_3.WatchOptions<TData, TVariables>): () => void;
    // Warning: (ae-forgotten-export) The symbol "WatchFragmentOptions_2" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "WatchFragmentResult_2" needs to be exported by the entry point index.d.ts
    watchFragment<TData = unknown, TVars = OperationVariables_2>(options: WatchFragmentOptions_2<TData, TVars>): Observable_2<WatchFragmentResult_2<TData>>;
    // (undocumented)
    abstract write<TData = unknown, TVariables = OperationVariables_2>(write: Cache_3.WriteOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeFragment<TData = unknown, TVariables = OperationVariables_2>({ id, data, fragment, fragmentName, ...options }: Cache_3.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeQuery<TData = unknown, TVariables = OperationVariables_2>({ id, data, ...options }: Cache_3.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public
export class ApolloClient implements DataProxy {
    // (undocumented)
    __actionHookForDevTools(cb: () => any): void;
    constructor(options: ApolloClientOptions);
    // (undocumented)
    __requestRaw(payload: GraphQLRequest): Observable_2<FormattedExecutionResult>;
    addResolvers(resolvers: Resolvers | Resolvers[]): void;
    // (undocumented)
    cache: ApolloCache;
    clearStore(): Promise<any[]>;
    // (undocumented)
    get defaultContext(): Partial<DefaultContext>;
    // (undocumented)
    defaultOptions: DefaultOptions;
    // Warning: (ae-forgotten-export) The symbol "DevtoolsOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly devtoolsConfig: DevtoolsOptions;
    // @deprecated (undocumented)
    disableNetworkFetches: never;
    get documentTransform(): DocumentTransform;
    extract(optimistic?: boolean): unknown;
    getMemoryInternals?: typeof getApolloClientMemoryInternals;
    getObservableQueries(include?: RefetchQueriesInclude): Map<string, ObservableQuery<any>>;
    getResolvers(): Resolvers;
    // (undocumented)
    link: ApolloLink;
    mutate<TData = unknown, TVariables extends OperationVariables = OperationVariables, TContext extends Record<string, any> = DefaultContext, TCache extends ApolloCache = ApolloCache>(options: MutationOptions<TData, TVariables, TContext>): Promise<MutateResult<MaybeMasked<TData>>>;
    onClearStore(cb: () => Promise<any>): () => void;
    onResetStore(cb: () => Promise<any>): () => void;
    set prioritizeCacheValues(value: boolean);
    get prioritizeCacheValues(): boolean;
    query<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: QueryOptions<TVariables, TData>): Promise<QueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    queryDeduplication: boolean;
    readFragment<T = unknown, TVariables = OperationVariables>(options: DataProxy.Fragment<TVariables, T>, optimistic?: boolean): Unmasked<T> | null;
    readQuery<TData = unknown, TVariables = OperationVariables>(options: DataProxy.Query<TVariables, TData>, optimistic?: boolean): Unmasked<TData> | null;
    reFetchObservableQueries(includeStandby?: boolean): Promise<QueryResult<any>[]>;
    refetchQueries<TCache extends ApolloCache = ApolloCache, TResult = Promise<QueryResult<any>>>(options: RefetchQueriesOptions<TCache, TResult>): RefetchQueriesResult<TResult>;
    resetStore(): Promise<QueryResult<any>[] | null>;
    restore(serializedState: unknown): ApolloCache;
    setLink(newLink: ApolloLink): void;
    setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher): void;
    setResolvers(resolvers: Resolvers | Resolvers[]): void;
    stop(): void;
    subscribe<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: SubscriptionOptions<TVariables, TData>): Observable_2<SubscribeResult<MaybeMasked<TData>>>;
    // (undocumented)
    readonly typeDefs: ApolloClientOptions["typeDefs"];
    // (undocumented)
    version: string;
    watchFragment<TData = unknown, TVariables = OperationVariables>(options: WatchFragmentOptions<TData, TVariables>): Observable_2<WatchFragmentResult<TData>>;
    watchQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: WatchQueryOptions<TVariables, TData>): ObservableQuery<TData, TVariables>;
    writeFragment<TData = unknown, TVariables = OperationVariables>(options: DataProxy.WriteFragmentOptions<TData, TVariables>): Reference_2 | undefined;
    writeQuery<TData = unknown, TVariables = OperationVariables>(options: DataProxy.WriteQueryOptions<TData, TVariables>): Reference_2 | undefined;
}

// @public (undocumented)
export interface ApolloClientOptions {
    assumeImmutableResults?: boolean;
    cache: ApolloCache;
    // @deprecated
    connectToDevTools?: boolean;
    // (undocumented)
    credentials?: string;
    dataMasking?: boolean;
    // (undocumented)
    defaultContext?: Partial<DefaultContext>;
    defaultOptions?: DefaultOptions;
    devtools?: DevtoolsOptions;
    // (undocumented)
    documentTransform?: DocumentTransform;
    // (undocumented)
    fragmentMatcher?: FragmentMatcher;
    headers?: Record<string, string>;
    link?: ApolloLink;
    name?: string;
    queryDeduplication?: boolean;
    // (undocumented)
    resolvers?: Resolvers | Resolvers[];
    ssrForceFetchDelay?: number;
    ssrMode?: boolean;
    // (undocumented)
    typeDefs?: string | string[] | DocumentNode_2 | DocumentNode_2[];
    uri?: string | UriFunction;
    version?: string;
}

export { ApolloLink }

export { ApolloPayloadResult }

// @public (undocumented)
export interface ApolloQueryResult<T> {
    // (undocumented)
    data: T | undefined;
    error?: ErrorLike;
    // (undocumented)
    loading: boolean;
    // (undocumented)
    networkStatus: NetworkStatus;
    // @deprecated
    partial: boolean;
}

// @public (undocumented)
export type ApolloReducerConfig = {
    dataIdFromObject?: KeyFieldsFunction;
};

// Warning: (ae-forgotten-export) The symbol "InMemoryCache_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type BroadcastOptions = Pick<Cache_3.BatchOptions<InMemoryCache_2>, "optimistic" | "onWatchUpdated">;

export { Cache_2 as Cache }

// @public (undocumented)
namespace Cache_3 {
    // Warning: (ae-forgotten-export) The symbol "ApolloCache_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface BatchOptions<TCache extends ApolloCache_2, TUpdateResult = void> {
        // (undocumented)
        onWatchUpdated?: (this: TCache, watch: Cache_3.WatchOptions, diff: Cache_3.DiffResult<any>, lastDiff?: Cache_3.DiffResult<any> | undefined) => any;
        // (undocumented)
        optimistic?: string | boolean;
        // (undocumented)
        removeOptimistic?: string;
        // (undocumented)
        update(cache: TCache): TUpdateResult;
    }
    // Warning: (ae-forgotten-export) The symbol "Cache_3" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface DiffOptions<TData = unknown, TVariables = OperationVariables_2> extends Omit<ReadOptions<TVariables, TData>, "rootId"> {
    }
    // (undocumented)
    interface EvictOptions {
        // (undocumented)
        args?: Record<string, any>;
        // (undocumented)
        broadcast?: boolean;
        // (undocumented)
        fieldName?: string;
        // (undocumented)
        id?: string;
    }
    // (undocumented)
    interface ModifyOptions<Entity extends Record<string, any> = Record<string, any>> {
        // (undocumented)
        broadcast?: boolean;
        // Warning: (ae-forgotten-export) The symbol "Modifiers" needs to be exported by the entry point index.d.ts
        // Warning: (ae-forgotten-export) The symbol "AllFieldsModifier" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        fields: Modifiers<Entity> | AllFieldsModifier<Entity>;
        // (undocumented)
        id?: string;
        // (undocumented)
        optimistic?: boolean;
    }
    // (undocumented)
    interface ReadOptions<TVariables = OperationVariables_2, TData = unknown> extends DataProxy_2.Query<TVariables, TData> {
        // (undocumented)
        optimistic: boolean;
        // (undocumented)
        previousResult?: any;
        // (undocumented)
        returnPartialData?: boolean;
        // (undocumented)
        rootId?: string;
    }
    // (undocumented)
    interface ResetOptions {
        // (undocumented)
        discardWatches?: boolean;
    }
    // (undocumented)
    type WatchCallback<TData = unknown> = (diff: Cache_3.DiffResult<TData>, lastDiff?: Cache_3.DiffResult<TData>) => void;
    // Warning: (ae-forgotten-export) The symbol "Cache_3" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface WatchOptions<TData = unknown, TVariables = OperationVariables_2> extends DiffOptions<TData, TVariables> {
        // Warning: (ae-forgotten-export) The symbol "Cache_3" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        callback: WatchCallback<TData>;
        // (undocumented)
        immediate?: boolean;
        // Warning: (ae-forgotten-export) The symbol "DataProxy_2" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        lastDiff?: DiffResult<TData>;
        // (undocumented)
        watcher?: object;
    }
    // (undocumented)
    interface WriteOptions<TData = unknown, TVariables = OperationVariables_2> extends Omit<DataProxy_2.Query<TVariables, TData>, "id">, Omit<DataProxy_2.WriteOptions<TData>, "data"> {
        // (undocumented)
        dataId?: string;
        // (undocumented)
        result: Unmasked<TData>;
    }
    import DiffResult = DataProxy.DiffResult;
    import ReadQueryOptions = DataProxy.ReadQueryOptions;
    import ReadFragmentOptions = DataProxy.ReadFragmentOptions;
    import WriteQueryOptions = DataProxy.WriteQueryOptions;
    import WriteFragmentOptions = DataProxy.WriteFragmentOptions;
    import UpdateQueryOptions = DataProxy.UpdateQueryOptions;
    import UpdateFragmentOptions = DataProxy.UpdateFragmentOptions;
    import Fragment = DataProxy.Fragment;
}

// @public (undocumented)
class CacheGroup {
    constructor(caching: boolean, parent?: CacheGroup | null);
    // (undocumented)
    readonly caching: boolean;
    // (undocumented)
    depend(dataId: string, storeFieldName: string): void;
    // (undocumented)
    dirty(dataId: string, storeFieldName: string): void;
    // (undocumented)
    keyMaker: Trie<object>;
    // (undocumented)
    resetCaching(): void;
}

// @public (undocumented)
const enum CacheWriteBehavior {
    // (undocumented)
    FORBID = 0,
    // (undocumented)
    MERGE = 2,
    // (undocumented)
    OVERWRITE = 1
}

// @public (undocumented)
type CanReadFunction = (value: StoreValue) => boolean;

export { checkFetcher }

export { ClientParseError }

export { CombinedGraphQLErrors }

export { CombinedProtocolErrors }

export { concat }

export { createHttpLink }

export { createSignalIfSupported }

export { DataMasking }

export { DataProxy }

// @public (undocumented)
namespace DataProxy_2 {
    // (undocumented)
    type DiffResult<TData> = {
        result: TData;
        complete: true;
        missing?: never;
        fromOptimisticTransaction?: boolean;
    } | {
        result: DeepPartial<TData> | null;
        complete: false;
        missing?: MissingFieldError_2;
        fromOptimisticTransaction?: boolean;
    };
    // (undocumented)
    interface Fragment<TVariables, TData> {
        fragment: DocumentNode_2 | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        id?: string;
        variables?: TVariables;
    }
    // (undocumented)
    interface Query<TVariables, TData> {
        id?: string;
        query: DocumentNode_2 | TypedDocumentNode<TData, TVariables>;
        variables?: TVariables;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface ReadFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData> {
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface ReadQueryOptions<TData, TVariables> extends Query<TVariables, TData> {
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy_2" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DataProxy_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface UpdateFragmentOptions<TData, TVariables> extends Omit<ReadFragmentOptions<TData, TVariables> & WriteFragmentOptions<TData, TVariables>, "data"> {
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy_2" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DataProxy_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface UpdateQueryOptions<TData, TVariables> extends Omit<ReadQueryOptions<TData, TVariables> & WriteQueryOptions<TData, TVariables>, "data"> {
    }
    // (undocumented)
    interface WriteFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData>, WriteOptions<TData> {
    }
    // (undocumented)
    interface WriteOptions<TData> {
        broadcast?: boolean;
        data: Unmasked<TData>;
        overwrite?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface WriteQueryOptions<TData, TVariables> extends Query<TVariables, TData>, WriteOptions<TData> {
    }
}

// @public
interface DataProxy_2 {
    readFragment<TData = unknown, TVariables = OperationVariables_2>(options: DataProxy_2.ReadFragmentOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    readQuery<TData = unknown, TVariables = OperationVariables_2>(options: DataProxy_2.ReadQueryOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    writeFragment<TData = unknown, TVariables = OperationVariables_2>(options: DataProxy_2.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    writeQuery<TData = unknown, TVariables = OperationVariables_2>(options: DataProxy_2.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public (undocumented)
export interface DefaultContext extends Record<string, any> {
}

export { defaultDataIdFromObject }

// @public (undocumented)
export interface DefaultOptions {
    // (undocumented)
    mutate?: Partial<MutationOptions<any, any, any>>;
    // (undocumented)
    query?: Partial<QueryOptions<any, any>>;
    // (undocumented)
    watchQuery?: Partial<WatchQueryOptions<any, any>>;
}

export { defaultPrinter }

// @public (undocumented)
interface DeleteModifier {
    // (undocumented)
    [_deleteModifier]: true;
}

// @public (undocumented)
const _deleteModifier: unique symbol;

// @public (undocumented)
interface DevtoolsOptions {
    enabled?: boolean;
    name?: string;
}

// @public (undocumented)
export type DiffQueryAgainstStoreOptions = ReadQueryOptions & {
    returnPartialData?: boolean;
};

export { disableExperimentalFragmentVariables }

export { disableFragmentWarnings }

export { DocumentNode }

export { DocumentTransform }

export { DocumentTransformCacheKey }

export { empty }

export { enableExperimentalFragmentVariables }

// @public (undocumented)
abstract class EntityStore implements NormalizedCache {
    constructor(policies: Policies, group: CacheGroup);
    // Warning: (ae-forgotten-export) The symbol "Layer" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
    // Warning: (ae-forgotten-export) The symbol "CanReadFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    clear(): void;
    // (undocumented)
    protected data: NormalizedCacheObject;
    // (undocumented)
    delete(dataId: string, fieldName?: string, args?: Record<string, any>): boolean;
    // (undocumented)
    evict(options: Cache_3.EvictOptions, limit: EntityStore): boolean;
    // (undocumented)
    extract(): NormalizedCacheObject;
    // (undocumented)
    findChildRefIds(dataId: string): Record<string, true>;
    // (undocumented)
    gc(): string[];
    // (undocumented)
    get(dataId: string, fieldName: string): StoreValue;
    // Warning: (ae-forgotten-export) The symbol "SafeReadonly" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getFieldValue: <T = StoreValue>(objectOrReference: StoreObject | Reference | undefined, storeFieldName: string) => SafeReadonly<T>;
    // (undocumented)
    getRootIdSet(ids?: Set<string>): Set<string>;
    // Warning: (ae-forgotten-export) The symbol "StorageType" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract getStorage(idOrObj: string | StoreObject, ...storeFieldNames: (string | number)[]): StorageType;
    // Warning: (ae-forgotten-export) The symbol "CacheGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly group: CacheGroup;
    // (undocumented)
    has(dataId: string): boolean;
    // (undocumented)
    protected lookup(dataId: string, dependOnExistence?: boolean): StoreObject | undefined;
    makeCacheKey(document: DocumentNode_2, callback: Cache_3.WatchCallback<any>, details: string): object;
    makeCacheKey(selectionSet: SelectionSetNode, parent: string | StoreObject, varString: string | undefined): object;
    makeCacheKey(field: FieldNode, array: readonly any[], varString: string | undefined): object;
    // @deprecated (undocumented)
    makeCacheKey(...args: any[]): object;
    // (undocumented)
    merge(older: string | StoreObject, newer: StoreObject | string): void;
    // (undocumented)
    modify(dataId: string, fields: Modifier<any> | Modifiers<Record<string, any>>): boolean;
    // Warning: (ae-forgotten-export) The symbol "Policies" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly policies: Policies;
    // (undocumented)
    release(rootId: string): number;
    // (undocumented)
    abstract removeLayer(layerId: string): EntityStore;
    // (undocumented)
    replace(newData: NormalizedCacheObject | null): void;
    // (undocumented)
    retain(rootId: string): number;
    // (undocumented)
    get supportsResultCaching(): boolean;
    // (undocumented)
    toObject(): NormalizedCacheObject;
    // Warning: (ae-forgotten-export) The symbol "ToReferenceFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    toReference: ToReferenceFunction;
}

// @public (undocumented)
namespace EntityStore {
    // (undocumented)
    class Root extends EntityStore {
        constructor({ policies, resultCaching, seed, }: {
            policies: Policies;
            resultCaching?: boolean;
            seed?: NormalizedCacheObject;
        });
        // (undocumented)
        addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
        // (undocumented)
        getStorage(): StorageType;
        // (undocumented)
        removeLayer(): Root;
        // (undocumented)
        readonly storageTrie: Trie<StorageType>;
        // Warning: (ae-forgotten-export) The symbol "Stump" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        readonly stump: Stump;
    }
}

// @public
export interface ErrorLike {
    // (undocumented)
    message: string;
    // (undocumented)
    name: string;
    // (undocumented)
    stack?: string;
}

// @public
export type ErrorPolicy = "none" | "ignore" | "all";

export { execute }

export { ExecutionPatchIncrementalResult }

export { ExecutionPatchInitialResult }

export { ExecutionPatchResult }

export { fallbackHttpConfig }

// @public (undocumented)
export interface FetchMoreOptions<TData = unknown, TVariables = OperationVariables> {
    // (undocumented)
    updateQuery?: (previousQueryResult: TData, options: {
        fetchMoreResult?: TData;
        variables?: TVariables;
    }) => TData;
}

// @public (undocumented)
export interface FetchMoreQueryOptions<TVariables, TData = unknown> {
    // (undocumented)
    context?: DefaultContext;
    query?: DocumentNode_2 | TypedDocumentNode<TData, TVariables>;
    variables?: Partial<TVariables>;
}

// @public
export type FetchPolicy = "cache-first" | "network-only" | "cache-only" | "no-cache" | "standby";

export { FetchResult }

export { FieldFunctionOptions }

// @public (undocumented)
interface FieldFunctionOptions_2<TArgs = Record<string, any>, TVars = Record<string, any>> {
    // (undocumented)
    args: TArgs | null;
    // (undocumented)
    cache: InMemoryCache_2;
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    field: FieldNode | null;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    isReference: typeof isReference;
    // Warning: (ae-forgotten-export) The symbol "MergeObjectsFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mergeObjects: MergeObjectsFunction;
    // Warning: (ae-forgotten-export) The symbol "ReadFieldFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readField: ReadFieldFunction;
    // (undocumented)
    storage: StorageType;
    // (undocumented)
    storeFieldName: string;
    // (undocumented)
    toReference: ToReferenceFunction;
    // (undocumented)
    variables?: TVars;
}

export { FieldMergeFunction }

// Warning: (ae-forgotten-export) The symbol "FieldFunctionOptions_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FieldMergeFunction_2<TExisting = any, TIncoming = TExisting, TOptions extends FieldFunctionOptions_2 = FieldFunctionOptions_2> = (existing: SafeReadonly<TExisting> | undefined, incoming: SafeReadonly<TIncoming>, options: TOptions) => SafeReadonly<TExisting>;

export { FieldPolicy }

// @public (undocumented)
type FieldPolicy_2<TExisting = any, TIncoming = TExisting, TReadResult = TIncoming, TOptions extends FieldFunctionOptions_2 = FieldFunctionOptions_2> = {
    keyArgs?: KeySpecifier | KeyArgsFunction | false;
    read?: FieldReadFunction_2<TExisting, TReadResult, TOptions>;
    merge?: FieldMergeFunction_2<TExisting, TIncoming, TOptions> | boolean;
};

export { FieldReadFunction }

// @public (undocumented)
type FieldReadFunction_2<TExisting = any, TReadResult = TExisting, TOptions extends FieldFunctionOptions_2 = FieldFunctionOptions_2> = (existing: SafeReadonly<TExisting> | undefined, options: TOptions) => TReadResult | undefined;

// @public (undocumented)
interface FieldSpecifier {
    // (undocumented)
    args?: Record<string, any>;
    // (undocumented)
    field?: FieldNode;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    typename?: string;
    // (undocumented)
    variables?: Record<string, any>;
}

// Warning: (ae-forgotten-export) The symbol "EntityStore" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FieldValueGetter = EntityStore["getFieldValue"];

// Warning: (ae-forgotten-export) The symbol "WriteContext" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FlavorableWriteContext = Pick<WriteContext, "clientOnly" | "deferred" | "flavors">;

// @public (undocumented)
export type FragmentMatcher = (rootValue: any, typeCondition: string, context: any) => boolean;

// @public (undocumented)
interface FragmentRegistryAPI {
    // (undocumented)
    lookup(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    register(...fragments: DocumentNode_2[]): this;
    // (undocumented)
    resetCaches(): void;
    // (undocumented)
    transform<D extends DocumentNode_2>(document: D): D;
}

export { FragmentType }

export { from }

export { gql }

export { GraphQLRequest }

export { HttpLink }

export { HttpOptions }

// @public (undocumented)
export type IdGetter = (value: IdGetterObj) => string | undefined;

// @public (undocumented)
export interface IdGetterObj extends Object {
    // (undocumented)
    __typename?: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    _id?: string;
}

// @public (undocumented)
interface IgnoreModifier {
    // (undocumented)
    [_ignoreModifier]: true;
}

// @public (undocumented)
const _ignoreModifier: unique symbol;

export { IncrementalPayload }

export { InMemoryCache }

// @public (undocumented)
class InMemoryCache_2 extends ApolloCache_2 {
    constructor(config?: InMemoryCacheConfig_2);
    // (undocumented)
    readonly assumeImmutableResults = true;
    // (undocumented)
    batch<TUpdateResult>(options: Cache_3.BatchOptions<InMemoryCache_2, TUpdateResult>): TUpdateResult;
    // Warning: (ae-forgotten-export) The symbol "BroadcastOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected broadcastWatches(options?: BroadcastOptions): void;
    // Warning: (ae-forgotten-export) The symbol "InMemoryCacheConfig_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected config: InMemoryCacheConfig_2;
    // (undocumented)
    diff<TData = unknown, TVariables extends OperationVariables_2 = OperationVariables_2>(options: Cache_3.DiffOptions<TData, TVariables>): Cache_3.DiffResult<TData>;
    // (undocumented)
    evict(options: Cache_3.EvictOptions): boolean;
    // (undocumented)
    extract(optimistic?: boolean): NormalizedCacheObject;
    // (undocumented)
    fragmentMatches(fragment: InlineFragmentNode, typename: string): boolean;
    // (undocumented)
    gc(options?: {
        resetResultCache?: boolean;
    }): string[];
    // @internal
    getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // (undocumented)
    lookupFragment(fragmentName: string): FragmentDefinitionNode | null;
    // Warning: (ae-forgotten-export) The symbol "makeVar_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly makeVar: typeof makeVar_2;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_3.ModifyOptions<Entity>): boolean;
    // (undocumented)
    performTransaction(update: (cache: InMemoryCache_2) => any, optimisticId?: string | null): any;
    // (undocumented)
    readonly policies: Policies;
    // (undocumented)
    read<TData = unknown>(options: Cache_3.ReadOptions<OperationVariables_2, TData> & {
        returnPartialData: true;
    }): TData | DeepPartial<TData> | null;
    // (undocumented)
    read<TData = unknown>(options: Cache_3.ReadOptions<OperationVariables_2, TData>): TData | null;
    // (undocumented)
    release(rootId: string, optimistic?: boolean): number;
    // (undocumented)
    removeOptimistic(idToRemove: string): void;
    // (undocumented)
    reset(options?: Cache_3.ResetOptions): Promise<void>;
    // (undocumented)
    restore(data: NormalizedCacheObject): this;
    // (undocumented)
    retain(rootId: string, optimistic?: boolean): number;
    // (undocumented)
    transformDocument(document: DocumentNode_2): DocumentNode_2;
    // (undocumented)
    watch<TData = unknown, TVariables = OperationVariables_2>(watch: Cache_3.WatchOptions<TData, TVariables>): () => void;
    // (undocumented)
    write<TData = unknown, TVariables = OperationVariables_2>(options: Cache_3.WriteOptions<TData, TVariables>): Reference | undefined;
}

export { InMemoryCacheConfig }

// @public (undocumented)
interface InMemoryCacheConfig_2 extends ApolloReducerConfig {
    // Warning: (ae-forgotten-export) The symbol "FragmentRegistryAPI" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fragments?: FragmentRegistryAPI;
    // Warning: (ae-forgotten-export) The symbol "PossibleTypesMap_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    possibleTypes?: PossibleTypesMap_2;
    // @deprecated (undocumented)
    resultCacheMaxSize?: number;
    // (undocumented)
    resultCaching?: boolean;
    // Warning: (ae-forgotten-export) The symbol "TypePolicies_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    typePolicies?: TypePolicies_2;
}

// Warning: (ae-forgotten-export) The symbol "RefetchQueriesIncludeShorthand" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type InternalRefetchQueriesInclude = InternalRefetchQueryDescriptor[] | RefetchQueriesIncludeShorthand;

// @public (undocumented)
export type InternalRefetchQueriesMap<TResult> = Map<ObservableQuery<any>, InternalRefetchQueriesResult<TResult>>;

// @public (undocumented)
export interface InternalRefetchQueriesOptions<TCache extends ApolloCache, TResult> extends Omit<RefetchQueriesOptions<TCache, TResult>, "include"> {
    // (undocumented)
    include?: InternalRefetchQueriesInclude;
    // (undocumented)
    removeOptimistic?: string;
}

// @public (undocumented)
export type InternalRefetchQueriesResult<TResult> = TResult extends boolean ? Promise<QueryResult<any>> : TResult;

// @public (undocumented)
export type InternalRefetchQueryDescriptor = RefetchQueryDescriptor | QueryOptions;

// @public (undocumented)
interface InvalidateModifier {
    // (undocumented)
    [_invalidateModifier]: true;
}

// @public (undocumented)
const _invalidateModifier: unique symbol;

// @public
export function isNetworkRequestSettled(networkStatus?: NetworkStatus): boolean;

export { isReference }

// @public (undocumented)
type KeyArgsFunction = (args: Record<string, any> | null, context: {
    typename: string;
    fieldName: string;
    field: FieldNode | null;
    variables?: Record<string, any>;
}) => KeySpecifier | false | ReturnType<IdGetter>;

// @public (undocumented)
type KeyFieldsContext = {
    typename: string | undefined;
    storeObject: StoreObject;
    readField: ReadFieldFunction;
    selectionSet?: SelectionSetNode;
    fragmentMap?: FragmentMap;
    keyObject?: Record<string, any>;
};

// Warning: (ae-forgotten-export) The symbol "KeyFieldsContext" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type KeyFieldsFunction = (object: Readonly<StoreObject>, context: KeyFieldsContext) => KeySpecifier | false | ReturnType<IdGetter>;

// @public (undocumented)
type KeySpecifier = ReadonlyArray<string | KeySpecifier>;

// @public (undocumented)
class Layer extends EntityStore {
    constructor(id: string, parent: EntityStore, replay: (layer: EntityStore) => any, group: CacheGroup);
    // (undocumented)
    addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
    // (undocumented)
    findChildRefIds(dataId: string): Record<string, true>;
    // (undocumented)
    getStorage(...args: Parameters<EntityStore["getStorage"]>): StorageType;
    // (undocumented)
    readonly group: CacheGroup;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly parent: EntityStore;
    // (undocumented)
    removeLayer(layerId: string): EntityStore;
    // (undocumented)
    readonly replay: (layer: EntityStore) => any;
    // (undocumented)
    toObject(): NormalizedCacheObject;
}

// @public (undocumented)
class LocalState {
    // Warning: (ae-forgotten-export) The symbol "LocalStateOptions" needs to be exported by the entry point index.d.ts
    constructor({ cache, client, resolvers, fragmentMatcher, }: LocalStateOptions);
    // (undocumented)
    addExportedVariables<TVars extends OperationVariables>(document: DocumentNode_2, variables?: TVars, context?: {}): Promise<TVars>;
    // (undocumented)
    addResolvers(resolvers: Resolvers | Resolvers[]): void;
    // (undocumented)
    clientQuery(document: DocumentNode_2): DocumentNode_2 | null;
    // (undocumented)
    getFragmentMatcher(): FragmentMatcher | undefined;
    // (undocumented)
    getResolvers(): Resolvers;
    // (undocumented)
    prepareContext(context?: Record<string, any>): {
        cache: ApolloCache;
        getCacheKey(obj: StoreObject): string | undefined;
    };
    // (undocumented)
    runResolvers<TData>({ document, remoteResult, context, variables, onlyRunForcedResolvers, }: {
        document: DocumentNode_2 | null;
        remoteResult: FetchResult<TData>;
        context?: Record<string, any>;
        variables?: Record<string, any>;
        onlyRunForcedResolvers?: boolean;
    }): Promise<FetchResult<TData>>;
    // (undocumented)
    serverQuery(document: DocumentNode_2): DocumentNode_2 | null;
    // (undocumented)
    setFragmentMatcher(fragmentMatcher: FragmentMatcher): void;
    // (undocumented)
    setResolvers(resolvers: Resolvers | Resolvers[]): void;
    // (undocumented)
    shouldForceResolvers(document: ASTNode): boolean;
}

// @public (undocumented)
type LocalStateOptions = {
    cache: ApolloCache;
    client?: ApolloClient;
    resolvers?: Resolvers | Resolvers[];
    fragmentMatcher?: FragmentMatcher;
};

export { makeReference }

export { makeVar }

// Warning: (ae-forgotten-export) The symbol "ReactiveVar_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function makeVar_2<T>(value: T): ReactiveVar_2<T>;

export { Masked }

export { MaskedDocumentNode }

// @public (undocumented)
interface MaskFragmentOptions<TData> {
    // (undocumented)
    data: TData;
    // (undocumented)
    fragment: DocumentNode_2;
    // (undocumented)
    fragmentName?: string;
}

// @public (undocumented)
interface MaskOperationOptions<TData> {
    // (undocumented)
    data: TData;
    // (undocumented)
    document: DocumentNode_2;
    // (undocumented)
    fetchPolicy?: WatchQueryFetchPolicy;
    // (undocumented)
    id: string;
}

export { MaybeMasked }

// @public (undocumented)
export interface MergeInfo {
    // (undocumented)
    field: FieldNode;
    // (undocumented)
    merge: FieldMergeFunction_2;
    // (undocumented)
    typename: string | undefined;
}

// @public (undocumented)
type MergeObjectsFunction = <T extends StoreObject | Reference>(existing: T, incoming: T) => T;

export { mergeOptions }

// @public (undocumented)
export interface MergeTree {
    // (undocumented)
    info?: MergeInfo;
    // (undocumented)
    map: Map<string | number, MergeTree>;
}

// @public (undocumented)
export type MethodKeys<T> = {
    [P in keyof T]: T[P] extends Function ? P : never;
}[keyof T];

export { MissingFieldError }

// @public (undocumented)
class MissingFieldError_2 extends Error {
    constructor(message: string, path: MissingTree | Array<string | number>, query: DocumentNode_2, variables?: Record<string, any> | undefined);
    // (undocumented)
    readonly message: string;
    // (undocumented)
    readonly missing: MissingTree;
    // Warning: (ae-forgotten-export) The symbol "MissingTree" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly path: MissingTree | Array<string | number>;
    // (undocumented)
    readonly query: DocumentNode_2;
    // (undocumented)
    readonly variables?: Record<string, any> | undefined;
}

// @public (undocumented)
type MissingTree = string | {
    readonly [key: string]: MissingTree;
};

// Warning: (ae-forgotten-export) The symbol "ModifierDetails" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeleteModifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "InvalidateModifier" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Modifier<T> = (value: T, details: ModifierDetails) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;

// @public (undocumented)
type ModifierDetails = {
    DELETE: DeleteModifier;
    INVALIDATE: InvalidateModifier;
    fieldName: string;
    storeFieldName: string;
    readField: ReadFieldFunction;
    canRead: CanReadFunction;
    isReference: typeof isReference;
    toReference: ToReferenceFunction;
    storage: StorageType;
};

// @public (undocumented)
type Modifiers<T extends Record<string, any> = Record<string, unknown>> = Partial<{
    [FieldName in keyof T]: Modifier<StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>>;
}>;

// @public (undocumented)
export interface MutateResult<TData = unknown> {
    data: TData | undefined;
    error?: ErrorLike;
    extensions?: Record<string, unknown>;
}

// @public (undocumented)
export type MutationFetchPolicy = Extract<FetchPolicy, "network-only" | "no-cache">;

// @public (undocumented)
export interface MutationOptions<TData = unknown, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache = ApolloCache> {
    awaitRefetchQueries?: boolean;
    context?: TContext;
    errorPolicy?: ErrorPolicy;
    fetchPolicy?: MutationFetchPolicy;
    keepRootFields?: boolean;
    mutation: DocumentNode_2 | TypedDocumentNode<TData, TVariables>;
    onQueryUpdated?: OnQueryUpdated<any>;
    // Warning: (ae-forgotten-export) The symbol "IgnoreModifier" needs to be exported by the entry point index.d.ts
    optimisticResponse?: Unmasked<NoInfer_2<TData>> | ((vars: TVariables, { IGNORE }: {
        IGNORE: IgnoreModifier;
    }) => Unmasked<NoInfer_2<TData>> | IgnoreModifier);
    refetchQueries?: ((result: FetchResult<Unmasked<TData>>) => InternalRefetchQueriesInclude) | InternalRefetchQueriesInclude;
    update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
    updateQueries?: MutationQueryReducersMap<TData>;
    variables?: TVariables;
}

// @public (undocumented)
export type MutationQueryReducer<T> = (previousResult: Record<string, any>, options: {
    mutationResult: FetchResult<Unmasked<T>>;
    queryName: string | undefined;
    queryVariables: Record<string, any>;
}) => Record<string, any>;

// @public (undocumented)
export type MutationQueryReducersMap<T = {
    [key: string]: any;
}> = {
    [queryName: string]: MutationQueryReducer<T>;
};

// @public (undocumented)
interface MutationStoreValue {
    // (undocumented)
    error: Error | null;
    // (undocumented)
    loading: boolean;
    // (undocumented)
    mutation: DocumentNode_2;
    // (undocumented)
    variables: Record<string, any>;
}

// @public @deprecated (undocumented)
export type MutationUpdaterFn<T = {
    [key: string]: any;
}> = (cache: ApolloCache, mutationResult: FetchResult<T>) => void;

// @public (undocumented)
export type MutationUpdaterFunction<TData, TVariables, TContext, TCache extends ApolloCache> = (cache: TCache, result: Omit<FetchResult<Unmasked<TData>>, "context">, options: {
    context?: TContext;
    variables?: TVariables;
}) => void;

// @public
export enum NetworkStatus {
    error = 8,
    fetchMore = 3,
    loading = 1,
    poll = 6,
    ready = 7,
    refetch = 4,
    setVariables = 2
}

// @public (undocumented)
interface NextFetchPolicyContext<TData, TVariables extends OperationVariables> {
    // (undocumented)
    initialFetchPolicy: WatchQueryFetchPolicy;
    // (undocumented)
    observable: ObservableQuery<TData, TVariables>;
    // (undocumented)
    options: WatchQueryOptions<TVariables, TData>;
    // (undocumented)
    reason: "after-fetch" | "variables-changed";
}

export { NextLink }

// @public
export interface NormalizedCache {
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    clear(): void;
    // (undocumented)
    delete(dataId: string, fieldName?: string): boolean;
    // (undocumented)
    get(dataId: string, fieldName: string): StoreValue;
    // Warning: (ae-forgotten-export) The symbol "FieldValueGetter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getFieldValue: FieldValueGetter;
    // (undocumented)
    getStorage(idOrObj: string | StoreObject, ...storeFieldNames: (string | number)[]): StorageType;
    // (undocumented)
    has(dataId: string): boolean;
    // (undocumented)
    merge(olderId: string, newerObject: StoreObject): void;
    // (undocumented)
    merge(olderObject: StoreObject, newerId: string): void;
    // (undocumented)
    modify<Entity extends Record<string, any>>(dataId: string, fields: Modifiers<Entity> | AllFieldsModifier<Entity>): boolean;
    // (undocumented)
    release(rootId: string): number;
    replace(newData: NormalizedCacheObject): void;
    retain(rootId: string): number;
    toObject(): NormalizedCacheObject;
    // (undocumented)
    toReference: ToReferenceFunction;
}

// @public
export interface NormalizedCacheObject {
    // (undocumented)
    [dataId: string]: StoreObject | undefined;
    // (undocumented)
    __META?: {
        extraRootIds: string[];
    };
}

export { Observable }

// @public (undocumented)
interface ObservableAndInfo<TData> {
    // (undocumented)
    fromLink: boolean;
    // (undocumented)
    observable: Observable_2<ApolloQueryResult<TData>>;
}

// @public (undocumented)
export class ObservableQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables> implements Subscribable<ApolloQueryResult<MaybeMasked<TData>>>, InteropObservable<ApolloQueryResult<MaybeMasked<TData>>> {
    // (undocumented)
    ["@@observable"]: () => Subscribable<ApolloQueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    [Symbol.observable]: () => Subscribable<ApolloQueryResult<MaybeMasked<TData>>>;
    constructor({ queryManager, queryInfo, options, }: {
        queryManager: QueryManager;
        queryInfo: QueryInfo;
        options: WatchQueryOptions<TVariables, TData>;
    });
    fetchMore<TFetchData = TData, TFetchVars extends OperationVariables = TVariables>(fetchMoreOptions: FetchMoreQueryOptions<TFetchVars, TFetchData> & {
        updateQuery?: (previousQueryResult: Unmasked<TData>, options: {
            fetchMoreResult: Unmasked<TFetchData>;
            variables: TFetchVars;
        }) => Unmasked<TData>;
    }): Promise<QueryResult<TFetchData>>;
    // (undocumented)
    getCurrentResult(saveAsLastResult?: boolean): ApolloQueryResult<MaybeMasked<TData>>;
    // (undocumented)
    getLastError(variablesMustMatch?: boolean): ErrorLike | undefined;
    // (undocumented)
    getLastResult(variablesMustMatch?: boolean): ApolloQueryResult<TData> | undefined;
    // (undocumented)
    hasObservers(): boolean;
    // (undocumented)
    isDifferentFromLastResult(newResult: ApolloQueryResult<TData>, variables?: TVariables): boolean | undefined;
    // (undocumented)
    readonly options: WatchQueryOptions<TVariables, TData>;
    // (undocumented)
    pipe: Observable_2<ApolloQueryResult<MaybeMasked<TData>>>["pipe"];
    // (undocumented)
    get query(): TypedDocumentNode<TData, TVariables>;
    // (undocumented)
    readonly queryId: string;
    // (undocumented)
    readonly queryName?: string;
    refetch(variables?: Partial<TVariables>): Promise<QueryResult<TData>>;
    reobserve(newOptions?: Partial<WatchQueryOptions<TVariables, TData>>): Promise<QueryResult<MaybeMasked<TData>>>;
    // @internal (undocumented)
    resetDiff(): void;
    // (undocumented)
    resetLastResults(): void;
    setVariables(variables: TVariables): Promise<QueryResult<TData>>;
    // @internal (undocumented)
    silentSetOptions(newOptions: Partial<WatchQueryOptions<TVariables, TData>>): void;
    startPolling(pollInterval: number): void;
    stopPolling(): void;
    // (undocumented)
    subscribe: (observer: Partial<Observer<ApolloQueryResult<MaybeMasked<TData>>>> | ((value: ApolloQueryResult<MaybeMasked<TData>>) => void)) => Subscription;
    subscribeToMore<TSubscriptionData = TData, TSubscriptionVariables extends OperationVariables = TVariables>(options: SubscribeToMoreOptions<TData, TSubscriptionVariables, TSubscriptionData, TVariables>): () => void;
    updateQuery(mapFn: UpdateQueryMapFn<TData, TVariables>): void;
    get variables(): TVariables | undefined;
}

// @public (undocumented)
export type OnQueryUpdated<TResult> = (observableQuery: ObservableQuery<any>, diff: Cache_2.DiffResult<any>, lastDiff: Cache_2.DiffResult<any> | undefined) => boolean | TResult;

export { Operation }

// @public (undocumented)
export type OperationVariables = Record<string, any>;

// @public (undocumented)
export type OptimisticStoreItem = {
    id: string;
    data: NormalizedCacheObject;
    transaction: Transaction_2;
};

export { parseAndCheckHttpResponse }

export { Path }

// @public (undocumented)
class Policies {
    constructor(config: {
        cache: InMemoryCache_2;
        dataIdFromObject?: KeyFieldsFunction;
        possibleTypes?: PossibleTypesMap_2;
        typePolicies?: TypePolicies_2;
    });
    // (undocumented)
    addPossibleTypes(possibleTypes: PossibleTypesMap_2): void;
    // (undocumented)
    addTypePolicies(typePolicies: TypePolicies_2): void;
    // (undocumented)
    readonly cache: InMemoryCache_2;
    // (undocumented)
    fragmentMatches(fragment: InlineFragmentNode | FragmentDefinitionNode, typename: string | undefined, result?: Record<string, any>, variables?: Record<string, any>): boolean;
    // (undocumented)
    getMergeFunction(parentTypename: string | undefined, fieldName: string, childTypename: string | undefined): FieldMergeFunction_2 | undefined;
    // (undocumented)
    getReadFunction(typename: string | undefined, fieldName: string): FieldReadFunction_2 | undefined;
    // Warning: (ae-forgotten-export) The symbol "FieldSpecifier" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getStoreFieldName(fieldSpec: FieldSpecifier): string;
    // (undocumented)
    hasKeyArgs(typename: string | undefined, fieldName: string): boolean;
    // (undocumented)
    identify(object: StoreObject, partialContext?: Partial<KeyFieldsContext>): [string?, StoreObject?];
    // Warning: (ae-forgotten-export) The symbol "ReadFieldOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readField<V = StoreValue>(options: ReadFieldOptions, context: ReadMergeModifyContext): SafeReadonly<V> | undefined;
    // (undocumented)
    readonly rootIdsByTypename: Record<string, string>;
    // (undocumented)
    readonly rootTypenamesById: Record<string, string>;
    // (undocumented)
    runMergeFunction(existing: StoreValue, incoming: StoreValue, { field, typename, merge }: MergeInfo, context: WriteContext, storage?: StorageType): any;
    // (undocumented)
    readonly usingPossibleTypes = false;
}

export { PossibleTypesMap }

// @public (undocumented)
type PossibleTypesMap_2 = {
    [supertype: string]: string[];
};

// @public (undocumented)
class QueryInfo {
    constructor(queryManager: QueryManager, queryId?: string);
    // (undocumented)
    document: DocumentNode_2 | null;
    // (undocumented)
    getDiff(): Cache_2.DiffResult<any>;
    // (undocumented)
    init(query: {
        document: DocumentNode_2;
        variables: Record<string, any> | undefined;
    }): this;
    // (undocumented)
    lastRequestId: number;
    // (undocumented)
    listeners: Set<QueryListener>;
    // Warning: (ae-forgotten-export) The symbol "CacheWriteBehavior" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    markResult<T>(result: FetchResult<T>, document: DocumentNode_2, options: Pick<WatchQueryOptions, "variables" | "fetchPolicy" | "errorPolicy">, cacheWriteBehavior: CacheWriteBehavior): void;
    // (undocumented)
    notify(): void;
    // (undocumented)
    readonly observableQuery: ObservableQuery<any, any> | null;
    // (undocumented)
    readonly queryId: string;
    // (undocumented)
    reset(): void;
    // (undocumented)
    resetDiff(): void;
    // (undocumented)
    resetLastWrite(): void;
    // (undocumented)
    setDiff(diff: Cache_2.DiffResult<any> | null): void;
    // (undocumented)
    setObservableQuery(oq: ObservableQuery<any, any> | null): void;
    // (undocumented)
    stop(): void;
    // (undocumented)
    stopped: boolean;
    // (undocumented)
    variables?: Record<string, any>;
}

// @public (undocumented)
export type QueryListener = (queryInfo: QueryInfo) => void;

// @public (undocumented)
class QueryManager {
    // Warning: (ae-forgotten-export) The symbol "QueryManagerOptions" needs to be exported by the entry point index.d.ts
    constructor(options: QueryManagerOptions);
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    // (undocumented)
    broadcastQueries(): void;
    // (undocumented)
    cache: ApolloCache;
    // (undocumented)
    clearStore(options?: Cache_2.ResetOptions): Promise<void>;
    // (undocumented)
    readonly dataMasking: boolean;
    // (undocumented)
    readonly defaultContext: Partial<DefaultContext>;
    // (undocumented)
    defaultOptions: DefaultOptions;
    // (undocumented)
    readonly documentTransform: DocumentTransform;
    // (undocumented)
    protected fetchCancelFns: Map<string, (error: any) => any>;
    // Warning: (ae-forgotten-export) The symbol "ObservableAndInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fetchObservableWithInfo<TData, TVars extends OperationVariables>(queryId: string, options: WatchQueryOptions<TVars, TData>, networkStatus?: NetworkStatus, query?: DocumentNode_2 | TypedDocumentNode<TData, TVars>, emitLoadingState?: boolean): ObservableAndInfo<TData>;
    // (undocumented)
    fetchQuery<TData, TVars extends OperationVariables>(queryId: string, options: WatchQueryOptions<TVars, TData>, networkStatus?: NetworkStatus): Promise<QueryResult<TData>>;
    // (undocumented)
    generateMutationId(): string;
    // (undocumented)
    generateQueryId(): string;
    // (undocumented)
    generateRequestId(): number;
    // Warning: (ae-forgotten-export) The symbol "TransformCacheEntry" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getDocumentInfo(document: DocumentNode_2): TransformCacheEntry;
    // Warning: (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getLocalState(): LocalState;
    // (undocumented)
    getObservableQueries(include?: InternalRefetchQueriesInclude): Map<string, ObservableQuery<any, OperationVariables>>;
    // (undocumented)
    protected inFlightLinkObservables: Trie<{
        observable?: Observable_2<FetchResult<any>>;
    }>;
    // (undocumented)
    link: ApolloLink;
    // (undocumented)
    markMutationOptimistic<TData, TVariables extends OperationVariables, TContext, TCache extends ApolloCache>(optimisticResponse: any, mutation: {
        mutationId: string;
        document: DocumentNode_2;
        variables?: TVariables;
        fetchPolicy?: MutationFetchPolicy;
        errorPolicy: ErrorPolicy;
        context?: TContext;
        updateQueries: UpdateQueries<TData>;
        update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
        keepRootFields?: boolean;
    }): boolean;
    // (undocumented)
    markMutationResult<TData, TVariables extends OperationVariables, TContext, TCache extends ApolloCache>(mutation: {
        mutationId: string;
        result: FetchResult<TData>;
        document: DocumentNode_2;
        variables?: TVariables;
        fetchPolicy?: MutationFetchPolicy;
        errorPolicy: ErrorPolicy;
        context?: TContext;
        updateQueries: UpdateQueries<TData>;
        update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
        awaitRefetchQueries?: boolean;
        refetchQueries?: InternalRefetchQueriesInclude;
        removeOptimistic?: string;
        onQueryUpdated?: OnQueryUpdated<any>;
        keepRootFields?: boolean;
    }, cache?: ApolloCache): Promise<FetchResult<TData>>;
    // Warning: (ae-forgotten-export) The symbol "MaskFragmentOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>): TData;
    // Warning: (ae-forgotten-export) The symbol "MaskOperationOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    maskOperation<TData = unknown>(options: MaskOperationOptions<TData>): MaybeMasked<TData>;
    // (undocumented)
    mutate<TData, TVariables extends OperationVariables, TContext extends Record<string, any>, TCache extends ApolloCache>({ mutation, variables, optimisticResponse, updateQueries, refetchQueries, awaitRefetchQueries, update: updateWithProxyFn, onQueryUpdated, fetchPolicy, errorPolicy, keepRootFields, context, }: MutationOptions<TData, TVariables, TContext>): Promise<MutateResult<MaybeMasked<TData>>>;
    // (undocumented)
    mutationStore?: {
        [mutationId: string]: MutationStoreValue;
    };
    prioritizeCacheValues: boolean;
    // (undocumented)
    query<TData, TVars extends OperationVariables = OperationVariables>(options: QueryOptions<TVars, TData>, queryId?: string): Promise<QueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    reFetchObservableQueries(includeStandby?: boolean): Promise<QueryResult<any>[]>;
    // (undocumented)
    refetchQueries<TResult>({ updateCache, include, optimistic, removeOptimistic, onQueryUpdated, }: InternalRefetchQueriesOptions<ApolloCache, TResult>): InternalRefetchQueriesMap<TResult>;
    // (undocumented)
    removeQuery(queryId: string): void;
    // (undocumented)
    setObservableQuery(observableQuery: ObservableQuery<any, any>): void;
    // (undocumented)
    readonly ssrMode: boolean;
    // (undocumented)
    startGraphQLSubscription<TData = unknown>(options: SubscriptionOptions): Observable_2<SubscribeResult<TData>>;
    stop(): void;
    // (undocumented)
    stopQuery(queryId: string): void;
    // (undocumented)
    transform(document: DocumentNode_2): DocumentNode_2;
    // (undocumented)
    watchQuery<T, TVariables extends OperationVariables = OperationVariables>(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables>;
}

// @public (undocumented)
interface QueryManagerOptions {
    // (undocumented)
    assumeImmutableResults: boolean;
    // (undocumented)
    cache: ApolloCache;
    // (undocumented)
    clientAwareness: Record<string, string>;
    // (undocumented)
    dataMasking: boolean;
    // (undocumented)
    defaultContext: Partial<DefaultContext> | undefined;
    // (undocumented)
    defaultOptions: DefaultOptions;
    // (undocumented)
    documentTransform: DocumentTransform | null | undefined;
    // (undocumented)
    link: ApolloLink;
    // (undocumented)
    localState: LocalState;
    // (undocumented)
    onBroadcast: undefined | (() => void);
    // (undocumented)
    queryDeduplication: boolean;
    // (undocumented)
    ssrMode: boolean;
}

// @public
interface QueryOptions<TVariables = OperationVariables, TData = unknown> {
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    fetchPolicy?: FetchPolicy;
    notifyOnNetworkStatusChange?: boolean;
    pollInterval?: number;
    query: DocumentNode_2 | TypedDocumentNode<TData, TVariables>;
    returnPartialData?: boolean;
    variables?: TVariables;
}
export { QueryOptions as PureQueryOptions }
export { QueryOptions }

// @public (undocumented)
export interface QueryResult<TData = unknown> {
    data: TData | undefined;
    error?: ErrorLike;
}

// @public (undocumented)
type ReactiveListener<T> = (value: T) => any;

export { ReactiveVar }

// @public (undocumented)
interface ReactiveVar_2<T> {
    // (undocumented)
    (newValue?: T): T;
    // (undocumented)
    attachCache(cache: ApolloCache_3): this;
    // (undocumented)
    forgetCache(cache: ApolloCache_3): boolean;
    // Warning: (ae-forgotten-export) The symbol "ReactiveListener" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    onNextChange(listener: ReactiveListener<T>): () => void;
}

// @public (undocumented)
interface ReadFieldFunction {
    // (undocumented)
    <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;
    // (undocumented)
    <V = StoreValue>(fieldName: string, from?: StoreObject | Reference): SafeReadonly<V> | undefined;
}

// @public (undocumented)
interface ReadFieldOptions extends FieldSpecifier {
    // (undocumented)
    from?: StoreObject | Reference;
}

// @public (undocumented)
export interface ReadMergeModifyContext {
    // (undocumented)
    store: NormalizedCache;
    // (undocumented)
    variables?: OperationVariables_2;
    // (undocumented)
    varString?: string;
}

// @public (undocumented)
export type ReadQueryOptions = {
    store: NormalizedCache;
    query: DocumentNode_2;
    variables?: Object;
    previousResult?: any;
    rootId?: string;
    config?: ApolloReducerConfig;
};

export { Reference }

// @public (undocumented)
export type RefetchQueriesInclude = RefetchQueryDescriptor[] | RefetchQueriesIncludeShorthand;

// @public (undocumented)
type RefetchQueriesIncludeShorthand = "all" | "active";

// @public (undocumented)
export interface RefetchQueriesOptions<TCache extends ApolloCache, TResult> {
    // (undocumented)
    include?: RefetchQueriesInclude;
    // (undocumented)
    onQueryUpdated?: OnQueryUpdated<TResult> | null;
    // (undocumented)
    optimistic?: boolean;
    // (undocumented)
    updateCache?: (cache: TCache) => void;
}

// @public (undocumented)
export type RefetchQueriesPromiseResults<TResult> = IsStrictlyAny<TResult> extends true ? any[] : TResult extends boolean ? QueryResult<any>[] : TResult extends PromiseLike<infer U> ? U[] : TResult[];

// @public (undocumented)
export interface RefetchQueriesResult<TResult> extends Promise<RefetchQueriesPromiseResults<TResult>> {
    // (undocumented)
    queries: ObservableQuery<any>[];
    // (undocumented)
    results: InternalRefetchQueriesResult<TResult>[];
}

// @public (undocumented)
export type RefetchQueryDescriptor = string | DocumentNode_2;

// @public (undocumented)
export type RefetchWritePolicy = "merge" | "overwrite";

export { RequestHandler }

export { resetCaches }

// @public (undocumented)
export type Resolver = (rootValue?: any, args?: any, context?: any, info?: {
    field: FieldNode;
    fragmentMap: FragmentMap;
}) => any;

// @public (undocumented)
export interface Resolvers {
    // (undocumented)
    [key: string]: {
        [field: string]: Resolver;
    };
}

export { rewriteURIForGET }

// @public (undocumented)
type SafeReadonly<T> = T extends object ? Readonly<T> : T;

export { selectHttpOptionsAndBody }

export { selectHttpOptionsAndBodyInternal }

export { selectURI }

export { serializeFetchParameter }

export { ServerError }

export { ServerParseError }

export { setLogVerbosity }

export { SingleExecutionResult }

export { split }

// @public (undocumented)
type StorageType = Record<string, any>;

export { StoreObject }

// @public (undocumented)
type StoreObjectValueMaybeReference<StoreVal> = StoreVal extends Array<Record<string, any>> ? StoreVal extends Array<infer Item> ? [
Item
] extends [Record<string, any>] ? ReadonlyArray<AsStoreObject<Item> | Reference> : never : never : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference : StoreVal;

export { StoreValue }

// @public (undocumented)
class Stump extends Layer {
    constructor(root: EntityStore.Root);
    // (undocumented)
    merge(older: string | StoreObject, newer: string | StoreObject): void;
    // (undocumented)
    removeLayer(): this;
}

// @public (undocumented)
export interface SubscribeResult<TData = unknown> {
    data: TData | undefined;
    error?: ErrorLike;
    extensions?: Record<string, unknown>;
}

// @public (undocumented)
export interface SubscribeToMoreFunction<TData, TVariables extends OperationVariables = OperationVariables> {
    // (undocumented)
    <TSubscriptionData = TData, TSubscriptionVariables extends OperationVariables = TVariables>(options: SubscribeToMoreOptions<TData, TSubscriptionVariables, TSubscriptionData, TVariables>): () => void;
}

// @public (undocumented)
export interface SubscribeToMoreOptions<TData = unknown, TSubscriptionVariables extends OperationVariables = OperationVariables, TSubscriptionData = TData, TVariables extends OperationVariables = TSubscriptionVariables> {
    // (undocumented)
    context?: DefaultContext;
    // (undocumented)
    document: DocumentNode_2 | TypedDocumentNode<TSubscriptionData, TSubscriptionVariables>;
    // (undocumented)
    onError?: (error: Error) => void;
    // (undocumented)
    updateQuery?: SubscribeToMoreUpdateQueryFn<TData, TVariables, TSubscriptionData>;
    // (undocumented)
    variables?: TSubscriptionVariables;
}

// @public (undocumented)
export type SubscribeToMoreUpdateQueryFn<TData = unknown, TVariables extends OperationVariables = OperationVariables, TSubscriptionData = TData> = {
    (
    unsafePreviousData: Unmasked<TData>, options: UpdateQueryOptions<TData, TVariables> & {
        subscriptionData: {
            data: Unmasked<TSubscriptionData>;
        };
    }): Unmasked<TData> | void;
};

// @public (undocumented)
export interface SubscriptionOptions<TVariables = OperationVariables, TData = unknown> {
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    extensions?: Record<string, any>;
    fetchPolicy?: FetchPolicy;
    query: DocumentNode_2 | TypedDocumentNode<TData, TVariables>;
    variables?: TVariables;
}

// @public (undocumented)
type ToReferenceFunction = (objOrIdOrRef: StoreObject | string | Reference, mergeIntoStore?: boolean) => Reference | undefined;

export { Transaction }

// @public (undocumented)
type Transaction_2 = (c: ApolloCache_2) => void;

// @public (undocumented)
interface TransformCacheEntry {
    // (undocumented)
    asQuery: DocumentNode_2;
    // (undocumented)
    clientQuery: DocumentNode_2 | null;
    // (undocumented)
    defaultVars: OperationVariables;
    // (undocumented)
    hasClientExports: boolean;
    // (undocumented)
    hasForcedResolvers: boolean;
    // (undocumented)
    hasNonreactiveDirective: boolean;
    // (undocumented)
    nonReactiveQuery: DocumentNode_2;
    // (undocumented)
    serverQuery: DocumentNode_2 | null;
}

export { TypedDocumentNode }

export { TypePolicies }

// @public (undocumented)
type TypePolicies_2 = {
    [__typename: string]: TypePolicy_2;
};

export { TypePolicy }

// @public (undocumented)
type TypePolicy_2 = {
    keyFields?: KeySpecifier | KeyFieldsFunction | false;
    merge?: FieldMergeFunction_2 | boolean;
    queryType?: true;
    mutationType?: true;
    subscriptionType?: true;
    fields?: {
        [fieldName: string]: FieldPolicy_2<any> | FieldReadFunction_2<any>;
    };
};

export { UnconventionalError }

export { Unmasked }

// @public (undocumented)
type UpdateQueries<TData> = MutationOptions<TData, any, any>["updateQueries"];

// @public (undocumented)
export interface UpdateQueryMapFn<TData = unknown, TVariables = OperationVariables> {
    // (undocumented)
    (
    unsafePreviousData: Unmasked<TData>, options: UpdateQueryOptions<TData, TVariables>): Unmasked<TData> | void;
}

// @public (undocumented)
export type UpdateQueryOptions<TData, TVariables> = {
    variables?: TVariables;
} & ({
    complete: true;
    previousData: Unmasked<TData>;
} | {
    complete: false;
    previousData: DeepPartial<Unmasked<TData>> | undefined;
});

export { UriFunction }

// @public (undocumented)
export const version: string;

export { WatchFragmentOptions }

// @public
interface WatchFragmentOptions_2<TData, TVars> {
    fragment: DocumentNode_2 | TypedDocumentNode_2<TData, TVars>;
    fragmentName?: string;
    from: StoreObject | Reference | FragmentType<NoInfer_2<TData>> | string;
    optimistic?: boolean;
    variables?: TVars;
}

export { WatchFragmentResult }

// @public
type WatchFragmentResult_2<TData> = {
    data: MaybeMasked<TData>;
    complete: true;
    missing?: never;
} | {
    data: DeepPartial<MaybeMasked<TData>>;
    complete: false;
    missing: MissingTree;
};

// @public (undocumented)
export type WatchQueryFetchPolicy = FetchPolicy | "cache-and-network";

// @public
export interface WatchQueryOptions<TVariables extends OperationVariables = OperationVariables, TData = unknown> {
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    fetchPolicy?: WatchQueryFetchPolicy;
    initialFetchPolicy?: WatchQueryFetchPolicy;
    // Warning: (ae-forgotten-export) The symbol "NextFetchPolicyContext" needs to be exported by the entry point index.d.ts
    nextFetchPolicy?: WatchQueryFetchPolicy | ((this: WatchQueryOptions<TVariables, TData>, currentFetchPolicy: WatchQueryFetchPolicy, context: NextFetchPolicyContext<TData, TVariables>) => WatchQueryFetchPolicy);
    notifyOnNetworkStatusChange?: boolean;
    pollInterval?: number;
    query: DocumentNode_2 | TypedDocumentNode<TData, TVariables>;
    refetchWritePolicy?: RefetchWritePolicy;
    returnPartialData?: boolean;
    skipPollAttempt?: () => boolean;
    variables?: TVariables;
}

// @public (undocumented)
interface WriteContext extends ReadMergeModifyContext {
    // (undocumented)
    clientOnly: boolean;
    // (undocumented)
    deferred: boolean;
    // Warning: (ae-forgotten-export) The symbol "FlavorableWriteContext" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    flavors: Map<string, FlavorableWriteContext>;
    // (undocumented)
    readonly fragmentMap: FragmentMap;
    // (undocumented)
    incomingById: Map<string, {
        storeObject: StoreObject;
        mergeTree?: MergeTree;
        fieldNodeSet: Set<FieldNode>;
    }>;
    // (undocumented)
    lookupFragment: FragmentMapFunction;
    // (undocumented)
    merge<T>(existing: T, incoming: T): T;
    // (undocumented)
    overwrite: boolean;
    // (undocumented)
    readonly written: {
        [dataId: string]: SelectionSetNode[];
    };
}

// Warnings were encountered during analysis:
//
// src/cache/core/types/DataProxy.ts:139:9 - (ae-forgotten-export) The symbol "MissingFieldError_2" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:62:3 - (ae-forgotten-export) The symbol "TypePolicy_2" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:135:5 - (ae-forgotten-export) The symbol "FieldPolicy_2" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:166:3 - (ae-forgotten-export) The symbol "KeySpecifier" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:166:3 - (ae-forgotten-export) The symbol "KeyArgsFunction" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:167:3 - (ae-forgotten-export) The symbol "FieldReadFunction_2" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:168:3 - (ae-forgotten-export) The symbol "FieldMergeFunction_2" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/types.ts:133:3 - (ae-forgotten-export) The symbol "KeyFieldsFunction" needs to be exported by the entry point index.d.ts
// src/core/ObservableQuery.ts:130:5 - (ae-forgotten-export) The symbol "QueryManager" needs to be exported by the entry point index.d.ts
// src/core/ObservableQuery.ts:131:5 - (ae-forgotten-export) The symbol "QueryInfo" needs to be exported by the entry point index.d.ts
// src/core/QueryManager.ts:185:5 - (ae-forgotten-export) The symbol "MutationStoreValue" needs to be exported by the entry point index.d.ts
// src/core/QueryManager.ts:455:7 - (ae-forgotten-export) The symbol "UpdateQueries" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
