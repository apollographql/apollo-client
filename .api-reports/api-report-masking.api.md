## API Report File for "@apollo/client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { ApolloCache } from '@apollo/client';
import type { ApplyHKTImplementationWithDefault } from '@apollo/client/utilities/internal';
import type { DocumentNode } from '@apollo/client';
import type { HKT } from '@apollo/client/utilities';
import type { IsAny } from '@apollo/client/utilities/internal';
import type { Prettify } from '@apollo/client/utilities/internal';
import type { Primitive } from '@apollo/client/utilities/internal';
import type { RemoveIndexSignature } from '@apollo/client/utilities/internal';
import type { TypedDocumentNode } from '@apollo/client';
import type { TypeOverrides } from '@apollo/client';

// Warning: (ae-forgotten-export) The symbol "MergeUnions" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExtractByMatchingTypeNames" needs to be exported by the entry point index.d.ts
//
// @public
type CombineByTypeName<T extends {
    __typename?: string;
}> = {
    [TypeName in NonNullable<T["__typename"]>]: Prettify<MergeUnions<ExtractByMatchingTypeNames<T, TypeName>>>;
}[NonNullable<T["__typename"]>];

// Warning: (ae-forgotten-export) The symbol "CombineByTypeName" needs to be exported by the entry point index.d.ts
//
// @public
type CombineIntersection<T> = Exclude<T, {
    __typename?: string;
}> | CombineByTypeName<Extract<T, {
    __typename?: string;
}>>;

// Warning: (ae-forgotten-export) The symbol "Exact" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ContainsFragmentsRefs<TData, Seen = never> = true extends (IsAny<TData>) ? false : TData extends object ? Exact<TData> extends Seen ? false : " $fragmentRefs" extends keyof RemoveIndexSignature<TData> ? true : ContainsFragmentsRefs<TData[keyof TData], Seen | Exact<TData>> : false;

// @public (undocumented)
export interface DataMasking {
}

// @internal @deprecated (undocumented)
export const disableWarningsSlot: {
    readonly id: string;
    hasValue(): boolean;
    getValue(): boolean | undefined;
    withValue<TResult, TArgs extends any[], TThis = any>(value: boolean, callback: (this: TThis, ...args: TArgs) => TResult, args?: TArgs | undefined, thisArg?: TThis | undefined): TResult;
};

// @public (undocumented)
type DistributedRequiredExclude<T, U> = T extends any ? Required<T> extends Required<U> ? Required<U> extends Required<T> ? never : T : T : T;

// @public (undocumented)
type Exact<in out T> = (x: T) => T;

// @public
type ExtractByMatchingTypeNames<Union extends {
    __typename?: string;
}, TypeName extends string> = Union extends any ? TypeName extends NonNullable<Union["__typename"]> ? Omit<Union, "__typename"> & {
    [K in keyof Union as K extends "__typename" ? K : never]: TypeName;
} : never : never;

// Warning: (ae-forgotten-export) The symbol "PreserveTypes" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type FragmentType<TData> = ApplyHKTImplementationWithDefault<TypeOverrides, "FragmentType", PreserveTypes.Implementation, TData>;

// @public (undocumented)
export namespace GraphQLCodegenDataMasking {
    // (undocumented)
    export type FragmentType<TData> = [
    TData
    ] extends [{
        " $fragmentName"?: infer TKey;
    }] ? TKey extends string ? {
        " $fragmentRefs"?: {
            [key in TKey]: TData;
        };
    } : never : never;
    // (undocumented)
    export namespace HKTImplementation {
        // (undocumented)
        export interface FragmentType extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: GraphQLCodegenDataMasking.FragmentType<this["arg1"]>;
        }
        // (undocumented)
        export interface IsMasked extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: GraphQLCodegenDataMasking.IsMasked<this["arg1"]>;
        }
        // (undocumented)
        export interface Mask extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: GraphQLCodegenDataMasking.Mask<this["arg1"]>;
        }
        // (undocumented)
        export interface Unmask extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: GraphQLCodegenDataMasking.Unmask<this["arg1"]>;
        }
    }
    // (undocumented)
    export interface Implementation {
        // (undocumented)
        FragmentType: HKTImplementation.FragmentType;
        // (undocumented)
        IsMasked: HKTImplementation.IsMasked;
        // (undocumented)
        Mask: HKTImplementation.Mask;
        // (undocumented)
        Unmask: HKTImplementation.Unmask;
    }
    export type IsMasked<_TData> = true;
    export type Mask<TData> = TData;
    // Warning: (ae-forgotten-export) The symbol "ContainsFragmentsRefs" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "UnwrapFragmentRefs" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "RemoveFragmentName" needs to be exported by the entry point index.d.ts
    export type Unmask<TData> = true extends IsAny<TData> ? TData : TData extends object ? true extends ContainsFragmentsRefs<TData> ? UnwrapFragmentRefs<RemoveFragmentName<TData>> : TData : TData;
}

// @public
export type IsMasked<TData> = ApplyHKTImplementationWithDefault<TypeOverrides, "IsMasked", PreserveTypes.Implementation, TData>;

// @public
export type Mask<TData> = ApplyHKTImplementationWithDefault<TypeOverrides, "Mask", PreserveTypes.Implementation, TData>;

// @internal @deprecated (undocumented)
export function maskFragment<TData = unknown>(data: TData, document: TypedDocumentNode<TData> | DocumentNode, cache: ApolloCache, fragmentName?: string): TData;

// @internal @deprecated (undocumented)
export function maskOperation<TData = unknown>(data: TData, document: DocumentNode | TypedDocumentNode<TData>, cache: ApolloCache): TData;

// @public (undocumented)
export type MaybeMasked<TData> = true extends IsMasked<TData> ? Mask<TData> : Unmask<TData>;

// Warning: (ae-forgotten-export) The symbol "CombineIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeObjects<T, U> = Prettify<{
    [k in keyof T]: k extends keyof U ? [
    NonNullable<T[k]>,
    NonNullable<U[k]>
    ] extends ([
    infer TK extends object,
    infer UK extends object
    ]) ? TK extends unknown[] ? UK extends unknown[] ? CombineIntersection<TK[number] | UK[number]>[] | Extract<T[k] | U[k], undefined | null> : T[k] : CombineIntersection<TK | UK> | Extract<T[k] | U[k], undefined | null> : T[k] : T[k];
} & Pick<U, Exclude<keyof U, keyof T>>>;

// Warning: (ae-forgotten-export) The symbol "MergeUnionsAcc" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "takeOneFromUnion" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnions<TUnion> = MergeUnionsAcc<TUnion, takeOneFromUnion<TUnion>, never>;

// Warning: (ae-forgotten-export) The symbol "DistributedRequiredExclude" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MergeObjects" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MergeUnionsAcc<TUnion, Curr, Merged> = [
Curr
] extends [never] ? Merged : MergeUnionsAcc<DistributedRequiredExclude<TUnion, Curr>, takeOneFromUnion<DistributedRequiredExclude<TUnion, Curr>>, [
Merged
] extends [never] ? Curr : MergeObjects<Curr, Merged>>;

// @public (undocumented)
namespace PreserveTypes {
    // (undocumented)
    type FragmentType<_TData> = never;
    // (undocumented)
    namespace HKTImplementation {
        // (undocumented)
        interface FragmentType extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: PreserveTypes.FragmentType<this["arg1"]>;
        }
        // (undocumented)
        interface IsMasked extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: PreserveTypes.IsMasked<this["arg1"]>;
        }
        // (undocumented)
        interface Mask extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: PreserveTypes.Mask<this["arg1"]>;
        }
        // (undocumented)
        interface Unmask extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: PreserveTypes.Unmask<this["arg1"]>;
        }
    }
    // (undocumented)
    interface Implementation {
        // Warning: (ae-forgotten-export) The symbol "PreserveTypes" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        FragmentType: HKTImplementation.FragmentType;
        // (undocumented)
        IsMasked: HKTImplementation.IsMasked;
        // (undocumented)
        Mask: HKTImplementation.Mask;
        // (undocumented)
        Unmask: HKTImplementation.Unmask;
    }
    // (undocumented)
    type IsMasked<_TData> = false;
    // (undocumented)
    type Mask<TData> = TData;
    // (undocumented)
    type Unmask<TData> = TData;
}

// @public (undocumented)
type RemoveFragmentName<T> = T extends any ? Omit<T, " $fragmentName"> : T;

// Warning: (ae-forgotten-export) The symbol "unionToIntersection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type takeOneFromUnion<T> = unionToIntersection<T extends T ? (x: T) => 0 : never> extends ((x: infer U) => 0) ? U : never;

// @public (undocumented)
type unionToIntersection<T> = (T extends unknown ? (x: T) => unknown : never) extends ((x: infer U) => unknown) ? U : never;

// @public
export type Unmask<TData> = ApplyHKTImplementationWithDefault<TypeOverrides, "Unmask", PreserveTypes.Implementation, TData>;

// @public @deprecated (undocumented)
export type Unmasked<TData> = Unmask<TData>;

// @public (undocumented)
type UnwrapFragmentRefs<TData> = true extends IsAny<TData> ? TData : TData extends any ? TData extends Primitive ? TData : string extends keyof TData ? TData : keyof TData extends never ? TData : TData extends {
    " $fragmentRefs"?: infer FragmentRefs;
} ? UnwrapFragmentRefs<CombineIntersection<Omit<TData, " $fragmentRefs"> | RemoveFragmentName<NonNullable<NonNullable<FragmentRefs>[keyof NonNullable<FragmentRefs>]>>>> : TData extends object ? {
    [K in keyof TData]: UnwrapFragmentRefs<TData[K]>;
} : TData : never;

// (No @packageDocumentation comment for this package)

```
