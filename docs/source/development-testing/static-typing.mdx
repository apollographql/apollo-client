---
title: TypeScript with Apollo Client
descriptions: How to generate and use TypeScript types in your application
---

As your application grows, a type system can become an essential tool for catching bugs early and improving your overall developer experience.

GraphQL uses a type system to clearly define the available data for each type and field in a GraphQL schema. Given that a GraphQL server's schema is strongly typed, we can generate TypeScript definitions automatically using a tool like [GraphQL Code Generator](https://www.the-guild.dev/graphql/codegen). We'll use our generated types to ensure type safety for the _inputs_ and _results_ of our GraphQL operations.

Below, we'll guide you through installing and configuring GraphQL Code Generator to generate types for your hooks and components.

## Setting up your project

> This article assumes your project already uses TypeScript.

To get started using GraphQL Code Generator, begin by installing the following packages (using Yarn or NPM):

```bash
npm install -D @graphql-codegen/cli @graphql-codegen/client-preset
```

<Note>

This installation assumes you have already [installed `@apollo/client` and its dependencies](../get-started#step-2-install-dependencies).

</Note>

Next, we'll create a configuration file for GraphQL Code Generator, named [`codegen.ts`](https://www.the-guild.dev/graphql/codegen/docs/config-reference/codegen-config), at the root of our project:

```ts title="codegen.ts"
import { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
  schema: "<URL_OF_YOUR_GRAPHQL_API>",
  // this assumes that all your source files are in a top-level `src/` directory - you might need to adjust this to your file structure
  documents: ["src/**/*.{ts,tsx}"],
  generates: {
    "./src/__generated__/": {
      preset: "client",
      plugins: [],
      presetConfig: {
        gqlTagName: "gql",
      },
    },
  },
  ignoreNoDocuments: true,
};

export default config;
```

> There are multiple ways to [specify a schema](https://www.the-guild.dev/graphql/codegen/docs/config-reference/schema-field#root-level) in your `codegen.ts`, so pick whichever way works best for your project setup.

Finally, we'll add the following scripts to our `package.json` file:

```json title="package.json"
{
  "scripts": {
    "compile": "graphql-codegen",
    "watch": "graphql-codegen -w"
  }
}
```

Running either of the scripts above generates types based on the schema file or GraphQL API you provided in `codegen.ts`:

```bash
$ yarn run compile
✔ Parse Configuration
✔ Generate outputs
```

## Typing hooks

GraphQL Code Generator automatically creates a `gql` function (from the `src/__generated__/gql.ts` file). This function enables us to type the variables that go into our React hooks, along with the results from those hooks.

### `useQuery`

Below we use the `gql` function to define our query, which automatically generates types for our `useQuery` hook:

```tsx
import React from "react";
import { useQuery } from "@apollo/client/react";

import { gql } from "../src/__generated__/gql";

const GET_ROCKET_INVENTORY = gql(/* GraphQL */ `
  query GetRocketInventory($year: Int!) {
    rocketInventory(year: $year) {
      id
      model
      year
      stock
    }
  }
`);

export function RocketInventoryList() {
  // our query's result, data, is typed!
  const { loading, data } = useQuery(
    GET_ROCKET_INVENTORY,
    // variables are also typed!
    { variables: { year: 2019 } }
  );
  return (
    <div>
      <h3>Available Inventory</h3>
      {loading ?
        <p>Loading ...</p>
      : <table>
          <thead>
            <tr>
              <th>Model</th>
              <th>Stock</th>
            </tr>
          </thead>
          <tbody>
            {data &&
              data.rocketInventory.map((inventory) => (
                <tr>
                  <td>{inventory.model}</td>
                  <td>{inventory.stock}</td>
                </tr>
              ))}
          </tbody>
        </table>
      }
    </div>
  );
}
```

#### `fetchMore` and `subscribeToMore`

The `useQuery` hook returns an instance of `QueryResult`, which includes the `fetchMore` and `subscribeToMore` functions. See [Queries for detailed type information](../data/queries#result). Because these functions execute GraphQL operations, they accept type parameters.

By default, the type parameters for `fetchMore` are the same as those for `useQuery`. Because both `fetchMore` and `useQuery` encapsulate a query operation, it's unlikely that you'll need to pass any type arguments to `fetchMore`.

Expanding our previous example, notice that we don't explicitly type `fetchMore`, because it defaults to using the same type parameters as `useQuery`:

```tsx
// ...
export function RocketInventoryList() {
  const { fetchMore, loading, data } = useQuery(
    GET_ROCKET_INVENTORY,
    // variables are typed!
    { variables: { year: 2019 } }
  );

  return (
    //...
    <button
      onClick={() => {
        // variables are typed!
        fetchMore({ variables: { year: 2020 } });
      }}
    >
      Add 2020 Inventory
    </button>
    //...
  );
}
```

The type parameters and defaults for `subscribeToMore` are identical to those for `fetchMore`. Keep in mind that `subscribeToMore` executes a _subscription_, whereas `fetchMore` executes follow-up queries.

Using `subscribeToMore`, you usually pass at least one typed argument, like so:

```tsx
// ...
const ROCKET_STOCK_SUBSCRIPTION = gql(/* GraphQL */ `
  subscription OnRocketStockUpdated {
    rocketStockAdded {
      id
      stock
    }
  }
`);

export function RocketInventoryList() {
  const { subscribeToMore, loading, data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { year: 2019 },
  });

  React.useEffect(() => {
    subscribeToMore(
      // variables are typed!
      { document: ROCKET_STOCK_SUBSCRIPTION, variables: { year: 2019 } }
    );
  }, [subscribeToMore]);

  // ...
}
```

### `useMutation`

We can type `useMutation` hooks the same way we type `useQuery` hooks. Using the generated `gql` function to define our GraphQL mutations, we ensure that we type our mutation's variables and return data:

```tsx
import React, { useState } from "react";
import { useMutation } from "@apollo/client/react";

import { gql } from "../src/__generated__/gql";

const SAVE_ROCKET = gql(/* GraphQL */ `
  mutation saveRocket($rocket: RocketInput!) {
    saveRocket(rocket: $rocket) {
      model
    }
  }
`);

export function NewRocketForm() {
  const [model, setModel] = useState("");
  const [year, setYear] = useState(0);
  const [stock, setStock] = useState(0);

  // our mutation's result, data, is typed!
  const [saveRocket, { error, data }] = useMutation(SAVE_ROCKET, {
    // variables are also typed!
    variables: { rocket: { model, year: +year, stock: +stock } },
  });

  return (
    <div>
      <h3>Add a Rocket</h3>
      {error ?
        <p>Oh no! {error.message}</p>
      : null}
      {data && data.saveRocket ?
        <p>Saved!</p>
      : null}
      <form>
        <p>
          <label>Model</label>
          <input name="model" onChange={(e) => setModel(e.target.value)} />
        </p>
        <p>
          <label>Year</label>
          <input
            type="number"
            name="year"
            onChange={(e) => setYear(+e.target.value)}
          />
        </p>
        <p>
          <label>Stock</label>
          <input
            type="number"
            name="stock"
            onChange={(e) => setStock(e.target.value)}
          />
        </p>
        <button onClick={() => model && year && stock && saveRocket()}>
          Add
        </button>
      </form>
    </div>
  );
}
```

### `useSubscription`

We can type our `useSubscription` hooks the same way we typed our `useQuery` and `useMutation` hooks. Using the generated `gql` function to define our GraphQL subscriptions, we ensure that we type our subscription variables and return data:

```tsx
import React from "react";
import { useSubscription } from "@apollo/client/react";

import { gql } from "../src/gql";

const LATEST_NEWS = gql(/* GraphQL */ `
  subscription getLatestNews {
    latestNews {
      content
    }
  }
`);

export function LatestNews() {
  // our returned data is typed!
  const { loading, data } = useSubscription(LATEST_NEWS);
  return (
    <div>
      <h5>Latest News</h5>
      <p>{loading ? "Loading..." : data!.latestNews.content}</p>
    </div>
  );
}
```

## Using `TypedDocumentNode`

In TypeScript, all APIs that intake `DocumentNode` can alternatively take `TypedDocumentNode<Data, Variables>`. This type has the same JavaScript representation but enables APIs to infer the data and variable types (instead of making you specify types upon invocation).

This technique enables us to modify the [`useQuery` example](#usequery) above to use a type inference:

```tsx
import React from "react";
import { gql, TypedDocumentNode } from "@apollo/client";
import { useQuery } from "@apollo/client/react";
import {
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables,
} from "./path/to/types/file.ts";

const GET_ROCKET_INVENTORY: TypedDocumentNode<
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables
> = gql`
  query GetRocketInventory($year: Int!) {
    rocketInventory(year: $year) {
      id
      model
      year
      stock
    }
  }
`;

export function RocketInventoryList() {
  const { loading, data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { year: 2019 },
  });
  return (
    <div>
      <h3>Available Inventory</h3>
      {loading ?
        <p>Loading ...</p>
      : <table>
          <thead>
            <tr>
              <th>Model</th>
              <th>Stock</th>
            </tr>
          </thead>
          <tbody>
            {data &&
              data.rocketInventory.map((inventory) => (
                <tr>
                  <td>{inventory.model}</td>
                  <td>{inventory.stock}</td>
                </tr>
              ))}
          </tbody>
        </table>
      }
    </div>
  );
}
```

## Data masking

Learn more about integrating TypeScript with data masking in the [data masking docs](../data/fragments#using-with-typescript).
