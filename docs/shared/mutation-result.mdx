**Mutate function:**

<table class="field-table api-ref">
  <thead>
    <tr>
      <th>Name /<br/>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
<td>

###### `mutate`

`(options?: MutationOptions) => Promise<FetchResult>`
</td>

<td>

A function to trigger the mutation from your UI. You can optionally pass this function any of the following options:

* `awaitRefetchQueries`
* `context`
* `fetchPolicy`
* `optimisticResponse`
* `refetchQueries`
* `update`
* `variables`

Any option you pass here overrides any existing value for that option that you passed to `useMutation`.

The mutate function returns a promise that fulfills with your mutation result.
</td>
</tr>
  </tbody>
</table>

**Mutation result:**

<table class="field-table api-ref">
  <thead>
    <tr>
      <th>Name /<br/>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
<td>

###### `data`

`TData`
</td>

<td>

The data returned from your mutation. Can be `undefined` if `ignoreResults` is `true`.
</td>
</tr>

<tr>
<td>

###### `loading`

`boolean`
</td>

<td>

If `true`, the mutation is currently in flight.
</td>
</tr>

<tr>
<td>

###### `error`

`ApolloError`
</td>

<td>

If the mutation produces one or more errors, this object contains either an array of `graphQLErrors` or a single `networkError`. Otherwise, this value is `undefined`.

For more information, see [Handling operation errors](/react/data/error-handling/).

</td>
</tr>

<tr>
<td>

###### `called`

`boolean`
</td>

<td>

If `true`, the mutation's mutate function has been called.

</td>
</tr>

<tr>
<td>

###### `client`

`ApolloClient`
</td>

<td>

The instance of Apollo Client that executed the mutation.

Can be useful for manually executing followup operations or writing data to the cache.

</td>
</tr>

<tr>
<td>

###### `reset`

`() => void`
</td>

<td>

A function that you can call to reset the mutation's result to its initial, uncalled state.

</td>
</tr>
  </tbody>
</table>
