---
title: Apollo Link overview
description: Customize Apollo Client's data flow
---

The **Apollo Link** library helps you customize the flow of data between Apollo Client and your GraphQL server. You can define your client's network behavior as a chain of **link** objects that execute in a sequence:

```mermaid
flowchart LR
  subgraph Apollo Client
  operation(GraphQL operation)
  link1(Link)
  link2(Link)
  link3(Terminating Link)
  operation--"Initiated"-->link1
  link1--down-->link2
  link2--down-->link3
  link3--up-->link2
  link2--up-->link1
  link1--"Completed"-->operation
  end
  server(GraphQL server)
  link3--Request-->server
  server--Response-->link3
  class server secondary;
```

Each link should represent either a self-contained modification to a GraphQL operation or a side effect (such as logging).

**In the above diagram:**

1.  The first link might log the details of the operation for debugging purposes.
2.  The second link might add an HTTP header to the outgoing operation request for authentication purposes.
3.  The final (terminating) link sends the operation to its destination (usually a GraphQL server over HTTP).
4.  The server's response is passed back up each link in reverse order, enabling links to [modify the response](#handling-a-response) or take other actions before the data is cached.

## Your first link chain

The following example demonstrates a basic link chain with two Apollo-provided links:

- An [`ErrorLink`](./apollo-link-error) link that checks for errors in the server's response. It logs the details of whichever error(s) it finds.
- An [`HttpLink`](./apollo-link-http) that sends each GraphQL operation to your server. This is the chain's _[terminating link](#the-terminating-link)._

```js title="index.js"
import {
  ApolloClient,
  CombinedGraphQLErrors,
  InMemoryCache,
  HttpLink,
  from,
} from "@apollo/client";
import { ErrorLink } from "@apollo/client/link/error";

const httpLink = new HttpLink({
  uri: "http://localhost:4000/graphql",
});

const errorLink = new ErrorLink(({ error }) => {
  if (CombinedGraphQLErrors.is(error)) {
    error.errors.forEach(({ message, locations, path }) =>
      console.log(
        `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`
      )
    );
  } else {
    console.log(`[Network error]:`, networkError);
  }
});

const client = new ApolloClient({
  // The `from` function combines an array of individual links
  // into a link chain
  link: from([errorLink, httpLink]),
  cache: new InMemoryCache(),
});
```

## Creating a custom link

A link object is an instance of the [`ApolloLink` class](https://github.com/apollographql/apollo-client/blob/main/src/link/core/ApolloLink.ts) (or a subclass of it). Each link must define a method named `request`, which is known as the link's **request handler**. You can provide this method's definition to the `ApolloLink` constructor.

### Example

The following custom link defines a request handler that adds a GraphQL operation's approximate start time to the operation's [context](#managing-context):

```js
import { ApolloLink } from "@apollo/client";

const timeStartLink = new ApolloLink((operation, forward) => {
  operation.setContext({ start: new Date() });
  return forward(operation);
});
```

This request handler then calls `return forward(operation)`, which is the syntax for calling the next link down the chain.

### The request handler

Every link must define a `request` method, also known as its **request handler**. This method is passed the following arguments:

- `operation`: The GraphQL operation that's being passed through the link.
  - For details, see [The `Operation` object](#the-operation-object).
- `forward`: A function for executing the next link in the chain (unless this is a [terminating link](#the-terminating-link)).

Whenever Apollo Client prepares to execute a GraphQL operation, it calls the request handler of the first link in the chain. Each link is responsible for executing its logic and then passing execution to the _next_ link by calling the [`forward` function](#the-forward-function) and returning its result.

#### The `Operation` object

The `Operation` object includes the following fields:

<PropertySignatureTable
  canonicalReference="@apollo/client!Operation:interface"
  idPrefix="operation"
/>

#### The `forward` function

When your custom link's request handler is done executing its logic, it should return a call to the `forward` function that's passed to it (unless it's the chain's [terminating link](#the-terminating-link)). Calling `return forward(operation)` passes execution along to the next link in the chain.

> If a non-terminating custom link's request handler _doesn't_ `return forward(operation)`, the link chain ends and the associated GraphQL operation is not executed.

The `forward` function's return type is an [`Observable`](https://rxjs.dev/guide/observable) provided by the [RxJS](https://rxjs.dev/) library. See the RxJS documentation for details.

### Handling a response

When your GraphQL server responds with an operation result, that result is passed back up through each link in your link chain before it's cached:

```mermaid
flowchart LR
  subgraph Apollo Client
  operation(GraphQL operation)
  link1(Link)
  link2(Link)
  link3(Terminating Link)
  operation--"Initiated"-->link1
  link1--down-->link2
  link2--down-->link3
  link3--up-->link2
  link2--up-->link1
  link1--"Completed"-->operation
  end
  server(GraphQL server)
  link3--Request-->server
  server--Response-->link3
  class server secondary;
```

Each link can execute logic while the result is being passed back by modifying their request handler's `return` statement, like so:

```js
import { map } from "rxjs";

return forward(operation).pipe(
  map((result) => {
    // ...modify result as desired here...
    return result;
  })
);
```

Whatever the function provided to `map` returns is passed to the next link up the chain.

You can also perform logic here that has nothing to do with the result. This request handler uses the [request context](#managing-context) to estimate the round-trip time for each operation:

```js
import { ApolloLink } from "@apollo/client";
import { tap } from "rxjs";

const roundTripLink = new ApolloLink((operation, forward) => {
  // Called before operation is sent to server
  operation.setContext({ start: new Date() });

  return forward(operation).pipe(
    tap(() => {
      // Called after server responds
      const time = new Date() - operation.getContext().start;
      console.log(
        `Operation ${operation.operationName} took ${time} to complete`
      );
    })
  );
});
```

<Note>

This example uses the [`tap` operator](https://rxjs.dev/api/index/function/tap) from RxJS. See the RxJS [operators](https://rxjs.dev/guide/operators) documentation for more details on the available operators.

</Note>

## Composing a link chain

Each link represents either a self-contained modification to a GraphQL operation or a side effect (such as logging). By composing these links into a chain, you can create an arbitrarily complex model for your client's data flow.

There are two forms of link composition: additive and directional.

- [Additive composition](#additive-composition) involves combining a set of links into a serially executed chain:

  ```mermaid
  flowchart LR
    link1(Link)
    link2(Link)
    link3(Terminating Link)
    link1-->link2
    link2-->link3
  ```

- [Directional composition](#directional-composition) involves branching to one of two links, depending on the details of an operation:

  ```mermaid
  flowchart LR
    link1(Link)
    link2(Link)
    link3(Terminating Link)
    link4(Terminating Link)
    link1-->link2
    link1-->link3
    link2-->link4
  ```

Note that no matter how your chain branches, each branch always ends in a [terminating link](#the-terminating-link).

### The terminating link

The _terminating link_ is the last link in a link chain. Instead of calling the `forward` function, the terminating link is responsible for sending your composed GraphQL operation to the destination that executes it (usually a GraphQL server) and returning an `ExecutionResult`.

[`HttpLink`](./apollo-link-http/) and [`BatchHttpLink`](./apollo-link-batch-http/) are both examples of terminating links.

### Additive composition

If you have a collection of two or more links that should always be executed in serial order, use the `ApolloLink.from` helper method to combine those links into a _single_ link, like so:

```js
import { from, HttpLink } from "@apollo/client";
import { RetryLink } from "@apollo/client/link/retry";
import MyAuthLink from "../auth";

const additiveLink = from([
  new RetryLink(),
  new MyAuthLink(),
  new HttpLink({ uri: "http://localhost:4000/graphql" }),
]);
```

### Directional composition

You might want your link chain's execution to branch, depending on the details of the operation being performed.

To support this, the `@apollo/client` library provides a `split` function that lets you use one of two different `Link`s, according to the result of a boolean check. You can also use the `split` method of an `ApolloLink` instance.

| Name    | Description                                                                                                                                              |
| ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `test`  | A function that takes in the current `Operation` and returns either `true` or `false` depending on its details.                                          |
| `left`  | The link to execute next if the `test` function returns `true`.                                                                                          |
| `right` | An **optional** link to execute next if the `test` function returns `false`. If this is not provided, the request handler's `forward` parameter is used. |

In the following example, a `RetryLink` passes execution along to one of two different `HttpLink`s depending on the associated context's `version`:

```js
import { ApolloLink, HttpLink } from "@apollo/client";
import { RetryLink } from "@apollo/client/link/retry";

const directionalLink = new RetryLink().split(
  (operation) => operation.getContext().version === 1,
  new HttpLink({ uri: "http://localhost:4000/v1/graphql" }),
  new HttpLink({ uri: "http://localhost:4000/v2/graphql" })
);
```

Other uses for the `split` method include:

- Customizing the number of allowed retry attempts depending on the operation type
- Using different transport methods depending on the operation type (such as HTTP for queries and WebSocket for subscriptions)
- Customizing logic depending on whether a user is logged in

In the following example, all subscription operations are sent to `GraphQLWsLink`, with all other operations sent to `HttpLink`:

```js
import { split, HttpLink } from "@apollo/client";
import { GraphQLWsLink } from "@apollo/client/link/subscriptions";
import { OperationTypeNode } from "graphql";
import { createClient } from "graphql-ws";

export const link = split(
  ({ operationType }) => {
    return operationType === OperationTypeNode.SUBSCRIPTION;
  },
  new GraphQLWsLink(createClient({ url: "ws://localhost:3000/subscriptions" })),
  new HttpLink({ uri: "http://localhost:4000/graphql" })
);
```

### Providing to Apollo Client

After you finish composing your entire link chain, you provide the resulting link to the constructor of `ApolloClient`, like so:

```js {12}
import { ApolloClient, HttpLink, InMemoryCache } from "@apollo/client";
import { RetryLink } from "@apollo/client/link/retry";

const directionalLink = new RetryLink().split(
  (operation) => operation.getContext().version === 1,
  new HttpLink({ uri: "http://localhost:4000/v1/graphql" }),
  new HttpLink({ uri: "http://localhost:4000/v2/graphql" })
);

const client = new ApolloClient({
  cache: new InMemoryCache(),
  link: directionalLink,
});
```

## Link types

### Stateless links

Most links perform the same logic for every operation they process, and they don't need to know anything about operations that have been executed previously. These links are **stateless**.

You can define the request handler for a stateless link in the constructor of an `ApolloLink` object, like so:

```js
import { ApolloLink } from "@apollo/client";
import { tap } from "rxjs";

const consoleLink = new ApolloLink((operation, forward) => {
  console.log(`starting request for ${operation.operationName}`);
  return forward(operation).pipe(
    tap(() => {
      console.log(`ending request for ${operation.operationName}`);
    })
  );
});
```

Stateless links are great for implementing middleware and even network requests. The following link adds an `Authorization` header to every outgoing request:

```js
import { ApolloLink } from "@apollo/client";

const authLink = new ApolloLink((operation, forward) => {
  operation.setContext(({ headers }) => ({
    headers: {
      authorization: Auth.userId(), // however you get your token
      ...headers,
    },
  }));

  return forward(operation);
});
```

This style of link also composes well for customization using a function:

```js
import { ApolloLink } from "@apollo/client";

function reportErrors(errorCallback) {
  return new ApolloLink((operation, forward) => {
    return new Observable((observer) => {
      const observable = forward(operation);
      const subscription = observable.subscribe({
        next(value) {
          observer.next(value);
        },
        error(networkError) {
          errorCallback({ networkError, operation });
          observer.error(networkError);
        },
        complete() {
          observer.complete();
        },
      });

      return () => subscription.unsubscribe();
    });
  });
}

const link = reportErrors(console.error);
```

#### Extending `ApolloLink`

You can also create a stateless link by extending the `ApolloLink` class and overwriting its constructor and request handler. For example, here's the same `reportErrors` link written as an extension of `ApolloLink`:

```js
import { ApolloLink } from "@apollo/client";
import { tap } from "rxjs";

class ReportErrorLink extends ApolloLink {
  constructor(errorCallback) {
    super();
    this.errorCallback = errorCallback;
  }
  request(operation, forward) {
    return forward(operation).pipe(
      tap({
        // errors will be sent to the errorCallback
        error: this.errorCallback,
      })
    );
  }
}

const link = new ReportErrorLink(console.error);
```

### Stateful links

When it's useful, links can maintain state between operations. These links are **stateful**.

Stateful links are usually defined as subclasses of `ApolloLink`. They override the constructor of `ApolloLink` and implement a `request` function with the same signature as a stateless link. For example:

```js
import { ApolloLink } from "@apollo/client";

class OperationCountLink extends ApolloLink {
  constructor() {
    super();
    this.operationCount = 0;
  }
  request(operation, forward) {
    this.operationCount += 1;
    return forward(operation);
  }
}

const link = new OperationCountLink();
```

This stateful link maintains a counter called `operationCount` as an instance variable. Every time a request is passed through the link, `operationCount` is incremented.

## Managing context

As an operation moves along your link chain, it maintains a `context` that each link can read and modify. This allows links to pass metadata along the chain that _other_ links use in their execution logic.

- Obtain the current context object by calling `operation.getContext()`.
- Modify the context object and then write it back with `operation.setContext(newContext)` or `operation.setContext((prevContext) => newContext)`.

Note that this context is _not_ included in the terminating link's request to the GraphQL server or other destination.

Here's an example:

```js
import { ApolloLink, from } from "@apollo/client";
import { tap } from "rxjs";

const timeStartLink = new ApolloLink((operation, forward) => {
  operation.setContext({ start: new Date() });
  return forward(operation);
});

const logTimeLink = new ApolloLink((operation, forward) => {
  return forward(operation).pipe(
    tap(() => {
      // data from a previous link
      const time = new Date() - operation.getContext().start;
      console.log(
        `operation ${operation.operationName} took ${time} to complete`
      );
    })
  );
});

const additiveLink = from([timeStartLink, logTimeLink]);
```

This example defines two links, `timeStartLink` and `logTimeLink`. The `timeStartLink` assigns the current time to the context's `start` field. When the operation completes, the `logTimeLink` then subtracts the value of `start` from the current time to determine the total duration of the operation.

You can set the context object's initial value for a particular operation by providing the `context` parameter to the [`useQuery` hook](../react/hooks/#usequery) (or `useMutation`, `useSubscription`, etc.).
