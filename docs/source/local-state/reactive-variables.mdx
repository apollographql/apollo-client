---
title: Reactive variables
description: State containers integrated into Apollo Client's reactivity model
---

New in Apollo Client 3, **reactive variables** are a useful mechanism for representing local state outside of the Apollo Client cache. Because they're separate from the cache, reactive variables can store data of any type and structure, and you can interact with them anywhere in your application without using GraphQL syntax.

**Most importantly, modifying a reactive variable triggers an update of every active query that depends on that variable.** Additionally, this updates the React state for components that use the `useReactiveVar` React hook.

> A query "depends on" a reactive variable if any of the query's requested fields defines a [`read` function](../caching/cache-field-behavior/#the-read-function) that reads the variable's value.

## Creating

Create a reactive variable with the `makeVar` method, like so:

```js
import { makeVar } from '@apollo/client';

const cartItemsVar = makeVar([]);
```

This code creates a reactive variable with an empty array as its initial value.

> **Important:** The return value of `makeVar` is a _function_ that you call to read or modify your reactive variable's value.

## Reading

To read the value of your reactive variable, call the function returned by `makeVar` with zero arguments:

```js
const cartItemsVar = makeVar([]);

// Output: []
console.log(cartItemsVar());
```

## Modifying

To modify the value of your reactive variable, call the function returned by `makeVar` with one argument (the variable's new value):

```js
const cartItemsVar = makeVar([]);

cartItemsVar([100, 101, 102]);

// Output: [100, 101, 102]
console.log(cartItemsVar());

cartItemsVar([456]);

// Output: [456]
console.log(cartItemsVar());
```

In the above example note that a new array is passed in every time to the reactive variable. Currently `useReactiveVar` only triggers component updates when new values are passed to the reactive variable. It uses strict equality checks (the `===` operator) to determine if the value has changed. Make sure you are always passing new values when performing an update.

This will *not* trigger an update:

```ts
const cartItemsVar = makeVar([1, 2]);
const cartItems = cartItemsVar();

cartItems.push(3);
cartItemsVarVar(cartItems);
```

This will trigger an update:

```ts
const cartItemsVar = makeVar([1, 2]);
const cartItems = cartItemsVar();

cartItemsVar([...cartItems, 3]); // spread operator to use existing values
cartItemsVar(cartItems.concat(4)); // Array.concat creates a new array
```

## Reacting

As their name suggests, reactive variables can trigger reactive changes in your application. Whenever you modify the value of a reactive variable, queries that depend on that variable refresh, and your application's UI updates accordingly.

With the `useReactiveVar` hook, React components can also include reactive variable values in their state directly, _without_ wrapping them in a query.

For more information, see [Storing local state in reactive variables](./managing-state-with-field-policies/#storing-local-state-in-reactive-variables).

### useReactiveVar hook

The `useReactiveVar` hook can be used to read from a reactive variable in a way that allows the React component to re-render if/when the variable is next updated.

Previously, the only way for a reactive variable to trigger a React component re-render was through the use of `useQuery`. Now you don't have to be using `useQuery` to benefit from the reactivity that `ReactiveVar<T>` provides.

```tsx
import { makeVar, useReactiveVar } from "@apollo/client";
export const cartItemsVar = makeVar([]);

export function Cart() {
  const cartItems = useReactiveVar(cartItemsVar);
  // ...
```

## Troubleshooting

### Updates Outside of Components

If you are making updates to a reactive variable outside of a React component and your components that use `useReactiveVar` are not updating, try deferring the update to the next tick of the event loop.

Here's an example that tracks GraphQL errors using the [onError Link](../api/link/apollo-link-error.md).

```ts
const errorsVar = makeVar<Error[]>([]);

const errorLink = onError((error: ErrorResponse) => {
  const errors = errorsVar();

  // making a copy of the current array value will trigger an update
  const nextErrors = [...errors];

  if (error.graphQLErrors) {
    error.graphQLErrors.forEach((e) => nextErrors.push(e));
  }

  if (error.networkError) {
    nextErrors.push(error.networkError);
  }

  // deferring the update to next tick will allow the update to reliably trigger a new component render
  setTimeout(() => errorsVar(nextErrors));
});
```

## Example application

[This example to-do list application](https://github.com/apollographql/ac3-state-management-examples/tree/master/apollo-local-state) uses reactive variables to track both the current list of to-do items and the filter that determines which items to display. See [`cache.tsx`](https://github.com/apollographql/ac3-state-management-examples/blob/master/apollo-local-state/src/cache.tsx) in particular.
