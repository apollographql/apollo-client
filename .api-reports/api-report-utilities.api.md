## API Report File for "@apollo/client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { ArgumentNode } from 'graphql';
import type { ASTNode } from 'graphql';
import type { DirectiveNode } from 'graphql';
import type { DocumentNode } from 'graphql';
import type { FieldNode } from 'graphql';
import type { FormattedExecutionResult } from 'graphql';
import type { FragmentDefinitionNode } from 'graphql';
import type { FragmentSpreadNode } from 'graphql';
import type { GraphQLErrorExtensions } from 'graphql';
import { GraphQLFormattedError } from 'graphql';
import type { InlineFragmentNode } from 'graphql';
import type { NameNode } from 'graphql';
import { Observable } from 'zen-observable-ts';
import type { Subscription as ObservableSubscription } from 'zen-observable-ts';
import type { Observer } from 'zen-observable-ts';
import type { OperationDefinitionNode } from 'graphql';
import type { SelectionNode } from 'graphql';
import type { SelectionSetNode } from 'graphql';
import { StrongCache } from '@wry/caches';
import type { Subscriber } from 'zen-observable-ts';
import { Trie } from '@wry/trie';
import { TypedDocumentNode } from '@graphql-typed-document-node/core';
import type { ValueNode } from 'graphql';
import type { VariableDefinitionNode } from 'graphql';
import type { VariableNode } from 'graphql';
import { WeakCache } from '@wry/caches';

// @public (undocumented)
export const addTypenameToDocument: (<TNode extends ASTNode>(doc: TNode) => TNode) & {
    added(field: FieldNode): boolean;
};

// Warning: (ae-forgotten-export) The symbol "Modifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "StoreObjectValueMaybeReference" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<Entity[keyof Entity] extends infer Value ? StoreObjectValueMaybeReference<Exclude<Value, undefined>> : never>;

// Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
abstract class ApolloCache<TSerialized> implements DataProxy {
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    // (undocumented)
    batch<U>(options: Cache_2.BatchOptions<this, U>): U;
    // (undocumented)
    abstract diff<T>(query: Cache_2.DiffOptions): Cache_2.DiffResult<T>;
    // (undocumented)
    abstract evict(options: Cache_2.EvictOptions): boolean;
    abstract extract(optimistic?: boolean): TSerialized;
    // (undocumented)
    gc(): string[];
    // Warning: (ae-forgotten-export) The symbol "getApolloCacheMemoryInternals" needs to be exported by the entry point index.d.ts
    //
    // @internal
    getMemoryInternals?: typeof getApolloCacheMemoryInternals;
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_2.ModifyOptions<Entity>): boolean;
    // Warning: (ae-forgotten-export) The symbol "Transaction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract performTransaction(transaction: Transaction<TSerialized>, optimisticId?: string | null): void;
    // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract read<TData = any, TVariables = any>(query: Cache_2.ReadOptions<TVariables, TData>): TData | null;
    // (undocumented)
    readFragment<FragmentType, TVariables = any>(options: Cache_2.ReadFragmentOptions<FragmentType, TVariables>, optimistic?: boolean): FragmentType | null;
    // (undocumented)
    readQuery<QueryType, TVariables = any>(options: Cache_2.ReadQueryOptions<QueryType, TVariables>, optimistic?: boolean): QueryType | null;
    // (undocumented)
    recordOptimisticTransaction(transaction: Transaction<TSerialized>, optimisticId: string): void;
    // (undocumented)
    abstract removeOptimistic(id: string): void;
    // (undocumented)
    abstract reset(options?: Cache_2.ResetOptions): Promise<void>;
    abstract restore(serializedState: TSerialized): ApolloCache<TSerialized>;
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
    // (undocumented)
    transformForLink(document: DocumentNode): DocumentNode;
    // (undocumented)
    updateFragment<TData = any, TVariables = any>(options: Cache_2.UpdateFragmentOptions<TData, TVariables>, update: (data: TData | null) => TData | null | void): TData | null;
    // (undocumented)
    updateQuery<TData = any, TVariables = any>(options: Cache_2.UpdateQueryOptions<TData, TVariables>, update: (data: TData | null) => TData | null | void): TData | null;
    // (undocumented)
    abstract watch<TData = any, TVariables = any>(watch: Cache_2.WatchOptions<TData, TVariables>): () => void;
    // Warning: (ae-forgotten-export) The symbol "OperationVariables" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "WatchFragmentOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "WatchFragmentResult" needs to be exported by the entry point index.d.ts
    watchFragment<TData = any, TVars = OperationVariables>(options: WatchFragmentOptions<TData, TVars>): Observable<WatchFragmentResult<TData>>;
    // (undocumented)
    abstract write<TData = any, TVariables = any>(write: Cache_2.WriteOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeFragment<TData = any, TVariables = any>({ id, data, fragment, fragmentName, ...options }: Cache_2.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeQuery<TData = any, TVariables = any>({ id, data, ...options }: Cache_2.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public
class ApolloClient<TCacheShape> implements DataProxy {
    // (undocumented)
    __actionHookForDevTools(cb: () => any): void;
    constructor(options: ApolloClientOptions<TCacheShape>);
    // Warning: (ae-forgotten-export) The symbol "GraphQLRequest" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    __requestRaw(payload: GraphQLRequest): Observable<FormattedExecutionResult>;
    // Warning: (ae-forgotten-export) The symbol "Resolvers" needs to be exported by the entry point index.d.ts
    addResolvers(resolvers: Resolvers | Resolvers[]): void;
    // Warning: (ae-forgotten-export) The symbol "ApolloCache" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    cache: ApolloCache<TCacheShape>;
    clearStore(): Promise<any[]>;
    // (undocumented)
    get defaultContext(): Partial<DefaultContext>;
    // (undocumented)
    defaultOptions: DefaultOptions;
    // Warning: (ae-forgotten-export) The symbol "DevtoolsOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly devtoolsConfig: DevtoolsOptions;
    // (undocumented)
    disableNetworkFetches: boolean;
    get documentTransform(): DocumentTransform;
    extract(optimistic?: boolean): TCacheShape;
    // Warning: (ae-forgotten-export) The symbol "getApolloClientMemoryInternals" needs to be exported by the entry point index.d.ts
    getMemoryInternals?: typeof getApolloClientMemoryInternals;
    // Warning: (ae-forgotten-export) The symbol "RefetchQueriesInclude" needs to be exported by the entry point index.d.ts
    getObservableQueries(include?: RefetchQueriesInclude): Map<string, ObservableQuery<any>>;
    getResolvers(): Resolvers;
    // Warning: (ae-forgotten-export) The symbol "ApolloLink" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    link: ApolloLink;
    // Warning: (ae-forgotten-export) The symbol "DefaultContext" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "MutationOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "FetchResult" needs to be exported by the entry point index.d.ts
    mutate<TData = any, TVariables extends OperationVariables = OperationVariables, TContext extends Record<string, any> = DefaultContext, TCache extends ApolloCache<any> = ApolloCache<any>>(options: MutationOptions<TData, TVariables, TContext>): Promise<FetchResult<TData>>;
    onClearStore(cb: () => Promise<any>): () => void;
    onResetStore(cb: () => Promise<any>): () => void;
    // Warning: (ae-forgotten-export) The symbol "QueryOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ApolloQueryResult" needs to be exported by the entry point index.d.ts
    query<T = any, TVariables extends OperationVariables = OperationVariables>(options: QueryOptions<TVariables, T>): Promise<ApolloQueryResult<T>>;
    // (undocumented)
    queryDeduplication: boolean;
    readFragment<T = any, TVariables = OperationVariables>(options: DataProxy.Fragment<TVariables, T>, optimistic?: boolean): T | null;
    readQuery<T = any, TVariables = OperationVariables>(options: DataProxy.Query<TVariables, T>, optimistic?: boolean): T | null;
    reFetchObservableQueries(includeStandby?: boolean): Promise<ApolloQueryResult<any>[]>;
    // Warning: (ae-forgotten-export) The symbol "RefetchQueriesOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "RefetchQueriesResult" needs to be exported by the entry point index.d.ts
    refetchQueries<TCache extends ApolloCache<any> = ApolloCache<TCacheShape>, TResult = Promise<ApolloQueryResult<any>>>(options: RefetchQueriesOptions<TCache, TResult>): RefetchQueriesResult<TResult>;
    resetStore(): Promise<ApolloQueryResult<any>[] | null>;
    restore(serializedState: TCacheShape): ApolloCache<TCacheShape>;
    setLink(newLink: ApolloLink): void;
    // Warning: (ae-forgotten-export) The symbol "FragmentMatcher" needs to be exported by the entry point index.d.ts
    setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher): void;
    setResolvers(resolvers: Resolvers | Resolvers[]): void;
    stop(): void;
    // Warning: (ae-forgotten-export) The symbol "SubscriptionOptions" needs to be exported by the entry point index.d.ts
    subscribe<T = any, TVariables extends OperationVariables = OperationVariables>(options: SubscriptionOptions<TVariables, T>): Observable<FetchResult<T>>;
    // Warning: (ae-forgotten-export) The symbol "ApolloClientOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly typeDefs: ApolloClientOptions<TCacheShape>["typeDefs"];
    // (undocumented)
    version: string;
    watchFragment<TFragmentData = unknown, TVariables = OperationVariables>(options: WatchFragmentOptions<TFragmentData, TVariables>): Observable<WatchFragmentResult<TFragmentData>>;
    // Warning: (ae-forgotten-export) The symbol "WatchQueryOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ObservableQuery" needs to be exported by the entry point index.d.ts
    watchQuery<T = any, TVariables extends OperationVariables = OperationVariables>(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables>;
    writeFragment<TData = any, TVariables = OperationVariables>(options: DataProxy.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    writeQuery<TData = any, TVariables = OperationVariables>(options: DataProxy.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public (undocumented)
interface ApolloClientOptions<TCacheShape> {
    assumeImmutableResults?: boolean;
    cache: ApolloCache<TCacheShape>;
    // @deprecated
    connectToDevTools?: boolean;
    // (undocumented)
    credentials?: string;
    // (undocumented)
    defaultContext?: Partial<DefaultContext>;
    defaultOptions?: DefaultOptions;
    devtools?: DevtoolsOptions;
    // (undocumented)
    documentTransform?: DocumentTransform;
    // (undocumented)
    fragmentMatcher?: FragmentMatcher;
    headers?: Record<string, string>;
    link?: ApolloLink;
    name?: string;
    queryDeduplication?: boolean;
    // (undocumented)
    resolvers?: Resolvers | Resolvers[];
    ssrForceFetchDelay?: number;
    ssrMode?: boolean;
    // (undocumented)
    typeDefs?: string | string[] | DocumentNode | DocumentNode[];
    // Warning: (ae-forgotten-export) The symbol "UriFunction" needs to be exported by the entry point index.d.ts
    uri?: string | UriFunction;
    version?: string;
}

// @public (undocumented)
class ApolloError extends Error {
    // Warning: (ae-forgotten-export) The symbol "ApolloErrorOptions" needs to be exported by the entry point index.d.ts
    constructor({ graphQLErrors, protocolErrors, clientErrors, networkError, errorMessage, extraInfo, }: ApolloErrorOptions);
    cause: ({
        readonly message: string;
        extensions?: GraphQLErrorExtensions[] | GraphQLFormattedError["extensions"];
    } & Omit<Partial<Error> & Partial<GraphQLFormattedError>, "extensions">) | null;
    // (undocumented)
    clientErrors: ReadonlyArray<Error>;
    // (undocumented)
    extraInfo: any;
    // (undocumented)
    graphQLErrors: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    message: string;
    // (undocumented)
    name: string;
    // Warning: (ae-forgotten-export) The symbol "ServerParseError" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ServerError" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    networkError: Error | ServerParseError | ServerError | null;
    // (undocumented)
    protocolErrors: ReadonlyArray<{
        message: string;
        extensions?: GraphQLErrorExtensions[];
    }>;
}

// @public (undocumented)
interface ApolloErrorOptions {
    // (undocumented)
    clientErrors?: ReadonlyArray<Error>;
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    extraInfo?: any;
    // (undocumented)
    graphQLErrors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    networkError?: Error | ServerParseError | ServerError | null;
    // (undocumented)
    protocolErrors?: ReadonlyArray<{
        message: string;
        extensions?: GraphQLErrorExtensions[];
    }>;
}

// @public (undocumented)
class ApolloLink {
    constructor(request?: RequestHandler);
    // (undocumented)
    static concat(first: ApolloLink | RequestHandler, second: ApolloLink | RequestHandler): ApolloLink;
    // (undocumented)
    concat(next: ApolloLink | RequestHandler): ApolloLink;
    // (undocumented)
    static empty(): ApolloLink;
    // (undocumented)
    static execute(link: ApolloLink, operation: GraphQLRequest): Observable<FetchResult>;
    // Warning: (ae-forgotten-export) The symbol "RequestHandler" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static from(links: (ApolloLink | RequestHandler)[]): ApolloLink;
    // @internal
    getMemoryInternals?: () => unknown;
    // @internal
    readonly left?: ApolloLink;
    // (undocumented)
    protected onError(error: any, observer?: Observer<FetchResult>): false | void;
    // Warning: (ae-forgotten-export) The symbol "NextLink" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    request(operation: Operation, forward?: NextLink): Observable<FetchResult> | null;
    // @internal
    readonly right?: ApolloLink;
    // (undocumented)
    setOnError(fn: ApolloLink["onError"]): this;
    // Warning: (ae-forgotten-export) The symbol "Operation" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static split(test: (op: Operation) => boolean, left: ApolloLink | RequestHandler, right?: ApolloLink | RequestHandler): ApolloLink;
    // (undocumented)
    split(test: (op: Operation) => boolean, left: ApolloLink | RequestHandler, right?: ApolloLink | RequestHandler): ApolloLink;
}

// @public (undocumented)
interface ApolloPayloadResult<TData = Record<string, any>, TExtensions = Record<string, any>> {
    // (undocumented)
    errors?: ReadonlyArray<Error | string>;
    // Warning: (ae-forgotten-export) The symbol "SingleExecutionResult" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ExecutionPatchResult" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    payload: SingleExecutionResult | ExecutionPatchResult | null;
}

// @public (undocumented)
interface ApolloQueryResult<T> {
    // (undocumented)
    data: T;
    // Warning: (ae-forgotten-export) The symbol "ApolloError" needs to be exported by the entry point index.d.ts
    error?: ApolloError;
    errors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    loading: boolean;
    // Warning: (ae-forgotten-export) The symbol "NetworkStatus" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    networkStatus: NetworkStatus;
    // (undocumented)
    partial?: boolean;
}

// @public (undocumented)
type ApolloReducerConfig = {
    dataIdFromObject?: KeyFieldsFunction;
    addTypename?: boolean;
};

// @public (undocumented)
export function argumentsObjectFromField(field: FieldNode | DirectiveNode, variables?: Record<string, any>): Object | null;

// @public
export type AsStoreObject<T extends {
    __typename?: string;
}> = {
    [K in keyof T]: T[K];
};

// @public (undocumented)
export function asyncMap<V, R>(observable: Observable<V>, mapFn: (value: V) => R | PromiseLike<R>, catchFn?: (error: any) => R | PromiseLike<R>): Observable<R>;

// @internal
export const AutoCleanedStrongCache: typeof StrongCache;

// @internal (undocumented)
export type AutoCleanedStrongCache<K, V> = StrongCache<K, V>;

// @internal
export const AutoCleanedWeakCache: typeof WeakCache;

// @internal (undocumented)
export type AutoCleanedWeakCache<K extends object, V> = WeakCache<K, V>;

// Warning: (ae-forgotten-export) The symbol "InMemoryCache" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type BroadcastOptions = Pick<Cache_2.BatchOptions<InMemoryCache>, "optimistic" | "onWatchUpdated">;

// @public (undocumented)
export function buildQueryFromSelectionSet(document: DocumentNode): DocumentNode;

// @public (undocumented)
namespace Cache_2 {
    // (undocumented)
    interface BatchOptions<TCache extends ApolloCache<any>, TUpdateResult = void> {
        // (undocumented)
        onWatchUpdated?: (this: TCache, watch: Cache_2.WatchOptions, diff: Cache_2.DiffResult<any>, lastDiff?: Cache_2.DiffResult<any> | undefined) => any;
        // (undocumented)
        optimistic?: string | boolean;
        // (undocumented)
        removeOptimistic?: string;
        // (undocumented)
        update(cache: TCache): TUpdateResult;
    }
    // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface DiffOptions<TData = any, TVariables = any> extends Omit<ReadOptions<TVariables, TData>, "rootId"> {
    }
    // (undocumented)
    interface EvictOptions {
        // (undocumented)
        args?: Record<string, any>;
        // (undocumented)
        broadcast?: boolean;
        // (undocumented)
        fieldName?: string;
        // (undocumented)
        id?: string;
    }
    // (undocumented)
    interface ModifyOptions<Entity extends Record<string, any> = Record<string, any>> {
        // (undocumented)
        broadcast?: boolean;
        // Warning: (ae-forgotten-export) The symbol "Modifiers" needs to be exported by the entry point index.d.ts
        // Warning: (ae-forgotten-export) The symbol "AllFieldsModifier" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        fields: Modifiers<Entity> | AllFieldsModifier<Entity>;
        // (undocumented)
        id?: string;
        // (undocumented)
        optimistic?: boolean;
    }
    // (undocumented)
    interface ReadOptions<TVariables = any, TData = any> extends DataProxy.Query<TVariables, TData> {
        // @deprecated (undocumented)
        canonizeResults?: boolean;
        // (undocumented)
        optimistic: boolean;
        // (undocumented)
        previousResult?: any;
        // (undocumented)
        returnPartialData?: boolean;
        // (undocumented)
        rootId?: string;
    }
    // (undocumented)
    interface ResetOptions {
        // (undocumented)
        discardWatches?: boolean;
    }
    // (undocumented)
    type WatchCallback<TData = any> = (diff: Cache_2.DiffResult<TData>, lastDiff?: Cache_2.DiffResult<TData>) => void;
    // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface WatchOptions<TData = any, TVariables = any> extends DiffOptions<TData, TVariables> {
        // Warning: (ae-forgotten-export) The symbol "Cache_2" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        callback: WatchCallback<TData>;
        // (undocumented)
        immediate?: boolean;
        // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        lastDiff?: DiffResult<TData>;
        // (undocumented)
        watcher?: object;
    }
    // (undocumented)
    interface WriteOptions<TResult = any, TVariables = any> extends Omit<DataProxy.Query<TVariables, TResult>, "id">, Omit<DataProxy.WriteOptions<TResult>, "data"> {
        // (undocumented)
        dataId?: string;
        // (undocumented)
        result: TResult;
    }
    import DiffResult = DataProxy.DiffResult;
    import ReadQueryOptions = DataProxy.ReadQueryOptions;
    import ReadFragmentOptions = DataProxy.ReadFragmentOptions;
    import WriteQueryOptions = DataProxy.WriteQueryOptions;
    import WriteFragmentOptions = DataProxy.WriteFragmentOptions;
    import UpdateQueryOptions = DataProxy.UpdateQueryOptions;
    import UpdateFragmentOptions = DataProxy.UpdateFragmentOptions;
    import Fragment = DataProxy.Fragment;
}

// @public (undocumented)
class CacheGroup {
    constructor(caching: boolean, parent?: CacheGroup | null);
    // (undocumented)
    readonly caching: boolean;
    // (undocumented)
    depend(dataId: string, storeFieldName: string): void;
    // (undocumented)
    dirty(dataId: string, storeFieldName: string): void;
    // (undocumented)
    keyMaker: Trie<object>;
    // (undocumented)
    resetCaching(): void;
}

// @public
export interface CacheSizes {
    "cache.fragmentQueryDocuments": number;
    "documentTransform.cache": number;
    "fragmentRegistry.findFragmentSpreads": number;
    "fragmentRegistry.lookup": number;
    "fragmentRegistry.transform": number;
    "inMemoryCache.executeSelectionSet": number;
    "inMemoryCache.executeSubSelectedArray": number;
    "inMemoryCache.maybeBroadcastWatch": number;
    "PersistedQueryLink.persistedQueryHashes": number;
    "queryManager.getDocumentInfo": number;
    "removeTypenameFromVariables.getVariableDefinitions": number;
    canonicalStringify: number;
    parser: number;
    print: number;
}

// @public
export const cacheSizes: Partial<CacheSizes>;

// @public (undocumented)
const enum CacheWriteBehavior {
    // (undocumented)
    FORBID = 0,
    // (undocumented)
    MERGE = 2,
    // (undocumented)
    OVERWRITE = 1
}

// @public
export const canonicalStringify: ((value: any) => string) & {
    reset(): void;
};

// @public (undocumented)
type CanReadFunction = (value: StoreValue) => boolean;

// @public (undocumented)
export const canUseAsyncIteratorSymbol: false | typeof Symbol.asyncIterator;

// @public (undocumented)
export const canUseDOM: boolean;

// @public (undocumented)
export const canUseLayoutEffect: boolean;

// @public (undocumented)
export const canUseSymbol: boolean;

// @public (undocumented)
export const canUseWeakMap: boolean;

// @public (undocumented)
export const canUseWeakSet: boolean;

// @public (undocumented)
export function checkDocument(doc: DocumentNode): DocumentNode;

// @public
export function cloneDeep<T>(value: T): T;

// @public
export function compact<TArgs extends any[]>(...objects: TArgs): TupleToIntersection<TArgs>;

// @public (undocumented)
export class Concast<T> extends Observable<T> {
    // Warning: (ae-forgotten-export) The symbol "MaybeAsync" needs to be exported by the entry point index.d.ts
    constructor(sources: MaybeAsync<ConcastSourcesIterable<T>> | Subscriber<T>);
    // (undocumented)
    addObserver(observer: Observer<T>): void;
    // Warning: (ae-forgotten-export) The symbol "NextResultListener" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    beforeNext(callback: NextResultListener): void;
    // (undocumented)
    cancel: (reason: any) => void;
    // (undocumented)
    readonly promise: Promise<T | undefined>;
    // (undocumented)
    removeObserver(observer: Observer<T>): void;
}

// Warning: (ae-forgotten-export) The symbol "Source" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ConcastSourcesArray<T> = Array<Source<T>>;

// @public (undocumented)
export type ConcastSourcesIterable<T> = Iterable<Source<T>>;

// Warning: (ae-forgotten-export) The symbol "KeyArgs" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FieldPolicy" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function concatPagination<T = Reference>(keyArgs?: KeyArgs): FieldPolicy<T[]>;

// @public (undocumented)
export function createFragmentMap(fragments?: FragmentDefinitionNode[]): FragmentMap;

// Warning: (ae-forgotten-export) The symbol "FulfilledPromise" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function createFulfilledPromise<TValue>(value: TValue): FulfilledPromise<TValue>;

// Warning: (ae-forgotten-export) The symbol "RejectedPromise" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function createRejectedPromise<TValue = unknown>(reason: unknown): RejectedPromise<TValue>;

// @public (undocumented)
namespace DataProxy {
    // (undocumented)
    type DiffResult<T> = {
        result?: T;
        complete?: boolean;
        missing?: MissingFieldError[];
        fromOptimisticTransaction?: boolean;
    };
    // (undocumented)
    interface Fragment<TVariables, TData> {
        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        id?: string;
        variables?: TVariables;
    }
    // (undocumented)
    interface Query<TVariables, TData> {
        id?: string;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        variables?: TVariables;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface ReadFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData> {
        // @deprecated
        canonizeResults?: boolean;
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface ReadQueryOptions<TData, TVariables> extends Query<TVariables, TData> {
        // @deprecated
        canonizeResults?: boolean;
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface UpdateFragmentOptions<TData, TVariables> extends Omit<ReadFragmentOptions<TData, TVariables> & WriteFragmentOptions<TData, TVariables>, "data"> {
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface UpdateQueryOptions<TData, TVariables> extends Omit<ReadQueryOptions<TData, TVariables> & WriteQueryOptions<TData, TVariables>, "data"> {
    }
    // (undocumented)
    interface WriteFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData>, WriteOptions<TData> {
    }
    // (undocumented)
    interface WriteOptions<TData> {
        broadcast?: boolean;
        data: TData;
        overwrite?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "DataProxy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    interface WriteQueryOptions<TData, TVariables> extends Query<TVariables, TData>, WriteOptions<TData> {
    }
}

// @public
interface DataProxy {
    readFragment<FragmentType, TVariables = any>(options: DataProxy.ReadFragmentOptions<FragmentType, TVariables>, optimistic?: boolean): FragmentType | null;
    readQuery<QueryType, TVariables = any>(options: DataProxy.ReadQueryOptions<QueryType, TVariables>, optimistic?: boolean): QueryType | null;
    writeFragment<TData = any, TVariables = any>(options: DataProxy.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    writeQuery<TData = any, TVariables = any>(options: DataProxy.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public (undocumented)
export class DeepMerger<TContextArgs extends any[]> {
    constructor(reconciler?: ReconcilerFunction<TContextArgs>);
    // (undocumented)
    isObject: typeof isNonNullObject;
    // (undocumented)
    merge(target: any, source: any, ...context: TContextArgs): any;
    // (undocumented)
    shallowCopyForMerge<T>(value: T): T;
}

// Warning: (ae-forgotten-export) The symbol "DeepOmitPrimitive" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepOmitArray" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type DeepOmit<T, K> = T extends DeepOmitPrimitive ? T : {
    [P in Exclude<keyof T, K>]: T[P] extends infer TP ? TP extends DeepOmitPrimitive ? TP : TP extends any[] ? DeepOmitArray<TP, K> : DeepOmit<TP, K> : never;
};

// @public (undocumented)
type DeepOmitArray<T extends any[], K> = {
    [P in keyof T]: DeepOmit<T[P], K>;
};

// Warning: (ae-forgotten-export) The symbol "Primitive" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepOmitPrimitive = Primitive | Function;

// Warning: (ae-forgotten-export) The symbol "DeepPartialPrimitive" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialReadonlyMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialSet" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialReadonlySet" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type DeepPartial<T> = T extends DeepPartialPrimitive ? T : T extends Map<infer TKey, infer TValue> ? DeepPartialMap<TKey, TValue> : T extends ReadonlyMap<infer TKey, infer TValue> ? DeepPartialReadonlyMap<TKey, TValue> : T extends Set<infer TItem> ? DeepPartialSet<TItem> : T extends ReadonlySet<infer TItem> ? DeepPartialReadonlySet<TItem> : T extends (...args: any[]) => unknown ? T | undefined : T extends object ? T extends (ReadonlyArray<infer TItem>) ? TItem[] extends (T) ? readonly TItem[] extends T ? ReadonlyArray<DeepPartial<TItem | undefined>> : Array<DeepPartial<TItem | undefined>> : DeepPartialObject<T> : DeepPartialObject<T> : unknown;

// @public (undocumented)
type DeepPartialMap<TKey, TValue> = {} & Map<DeepPartial<TKey>, DeepPartial<TValue>>;

// @public (undocumented)
type DeepPartialObject<T extends object> = {
    [K in keyof T]?: DeepPartial<T[K]>;
};

// @public (undocumented)
type DeepPartialPrimitive = Primitive | Date | RegExp;

// @public (undocumented)
type DeepPartialReadonlyMap<TKey, TValue> = {} & ReadonlyMap<DeepPartial<TKey>, DeepPartial<TValue>>;

// @public (undocumented)
type DeepPartialReadonlySet<T> = {} & ReadonlySet<DeepPartial<T>>;

// @public (undocumented)
type DeepPartialSet<T> = {} & Set<DeepPartial<T>>;

// @public (undocumented)
export const enum defaultCacheSizes {
    // (undocumented)
    "cache.fragmentQueryDocuments" = 1000,
    // (undocumented)
    "documentTransform.cache" = 2000,
    // (undocumented)
    "fragmentRegistry.findFragmentSpreads" = 4000,
    // (undocumented)
    "fragmentRegistry.lookup" = 1000,
    // (undocumented)
    "fragmentRegistry.transform" = 2000,
    // (undocumented)
    "inMemoryCache.executeSelectionSet" = 50000,
    // (undocumented)
    "inMemoryCache.executeSubSelectedArray" = 10000,
    // (undocumented)
    "inMemoryCache.maybeBroadcastWatch" = 5000,
    // (undocumented)
    "PersistedQueryLink.persistedQueryHashes" = 2000,
    // (undocumented)
    "queryManager.getDocumentInfo" = 2000,
    // (undocumented)
    "removeTypenameFromVariables.getVariableDefinitions" = 2000,
    // (undocumented)
    canonicalStringify = 1000,
    // (undocumented)
    parser = 1000,
    // (undocumented)
    print = 2000
}

// @public (undocumented)
interface DefaultContext extends Record<string, any> {
}

// @public (undocumented)
interface DefaultOptions {
    // (undocumented)
    mutate?: Partial<MutationOptions<any, any, any>>;
    // (undocumented)
    query?: Partial<QueryOptions<any, any>>;
    // (undocumented)
    watchQuery?: Partial<WatchQueryOptions<any, any>>;
}

// @public (undocumented)
interface DeleteModifier {
    // (undocumented)
    [_deleteModifier]: true;
}

// @public (undocumented)
const _deleteModifier: unique symbol;

// @public @deprecated (undocumented)
export const DEV: boolean;

// @public (undocumented)
interface DevtoolsOptions {
    enabled?: boolean;
    name?: string;
}

// @public (undocumented)
export type DirectiveInfo = {
    [fieldName: string]: {
        [argName: string]: any;
    };
};

// @public (undocumented)
export type Directives = {
    [directiveName: string]: {
        [argName: string]: any;
    };
};

// @public (undocumented)
export class DocumentTransform {
    // Warning: (ae-forgotten-export) The symbol "TransformFn" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DocumentTransformOptions" needs to be exported by the entry point index.d.ts
    constructor(transform: TransformFn, options?: DocumentTransformOptions);
    // (undocumented)
    concat(otherTransform: DocumentTransform): DocumentTransform;
    // (undocumented)
    static identity(): DocumentTransform;
    // @internal
    readonly left?: DocumentTransform;
    resetCache(): void;
    // @internal
    readonly right?: DocumentTransform;
    // (undocumented)
    static split(predicate: (document: DocumentNode) => boolean, left: DocumentTransform, right?: DocumentTransform): DocumentTransform & {
        left: DocumentTransform;
        right: DocumentTransform;
    };
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
}

// @public (undocumented)
export type DocumentTransformCacheKey = ReadonlyArray<unknown>;

// @public (undocumented)
interface DocumentTransformOptions {
    cache?: boolean;
    getCacheKey?: (document: DocumentNode) => DocumentTransformCacheKey | undefined;
}

// Warning: (ae-forgotten-export) The symbol "NormalizedCache" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
abstract class EntityStore implements NormalizedCache {
    constructor(policies: Policies, group: CacheGroup);
    // Warning: (ae-forgotten-export) The symbol "Layer" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
    // Warning: (ae-forgotten-export) The symbol "CanReadFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    clear(): void;
    // Warning: (ae-forgotten-export) The symbol "NormalizedCacheObject" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected data: NormalizedCacheObject;
    // (undocumented)
    delete(dataId: string, fieldName?: string, args?: Record<string, any>): boolean;
    // (undocumented)
    evict(options: Cache_2.EvictOptions, limit: EntityStore): boolean;
    // (undocumented)
    extract(): NormalizedCacheObject;
    // (undocumented)
    findChildRefIds(dataId: string): Record<string, true>;
    // (undocumented)
    gc(): string[];
    // (undocumented)
    get(dataId: string, fieldName: string): StoreValue;
    // Warning: (ae-forgotten-export) The symbol "SafeReadonly" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getFieldValue: <T = StoreValue>(objectOrReference: StoreObject | Reference | undefined, storeFieldName: string) => SafeReadonly<T>;
    // (undocumented)
    getRootIdSet(ids?: Set<string>): Set<string>;
    // Warning: (ae-forgotten-export) The symbol "StorageType" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract getStorage(idOrObj: string | StoreObject, ...storeFieldNames: (string | number)[]): StorageType;
    // Warning: (ae-forgotten-export) The symbol "CacheGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly group: CacheGroup;
    // (undocumented)
    has(dataId: string): boolean;
    // (undocumented)
    protected lookup(dataId: string, dependOnExistence?: boolean): StoreObject | undefined;
    makeCacheKey(document: DocumentNode, callback: Cache_2.WatchCallback<any>, details: string): object;
    makeCacheKey(selectionSet: SelectionSetNode, parent: string | StoreObject, varString: string | undefined, canonizeResults: boolean): object;
    makeCacheKey(field: FieldNode, array: readonly any[], varString: string | undefined): object;
    // @deprecated (undocumented)
    makeCacheKey(...args: any[]): object;
    // (undocumented)
    merge(older: string | StoreObject, newer: StoreObject | string): void;
    // (undocumented)
    modify(dataId: string, fields: Modifier<any> | Modifiers<Record<string, any>>): boolean;
    // Warning: (ae-forgotten-export) The symbol "Policies" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly policies: Policies;
    // (undocumented)
    release(rootId: string): number;
    // (undocumented)
    abstract removeLayer(layerId: string): EntityStore;
    // (undocumented)
    replace(newData: NormalizedCacheObject | null): void;
    // (undocumented)
    retain(rootId: string): number;
    // (undocumented)
    toObject(): NormalizedCacheObject;
    // Warning: (ae-forgotten-export) The symbol "ToReferenceFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    toReference: ToReferenceFunction;
}

// @public (undocumented)
namespace EntityStore {
    // (undocumented)
    class Root extends EntityStore {
        constructor({ policies, resultCaching, seed, }: {
            policies: Policies;
            resultCaching?: boolean;
            seed?: NormalizedCacheObject;
        });
        // (undocumented)
        addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
        // (undocumented)
        getStorage(): StorageType;
        // (undocumented)
        removeLayer(): Root;
        // (undocumented)
        readonly storageTrie: Trie<StorageType>;
        // Warning: (ae-forgotten-export) The symbol "Stump" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        readonly stump: Stump;
    }
}

// @public
type ErrorPolicy = "none" | "ignore" | "all";

// Warning: (ae-forgotten-export) The symbol "ExecutionPatchResultBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface ExecutionPatchIncrementalResult<TData = Record<string, any>, TExtensions = Record<string, any>> extends ExecutionPatchResultBase {
    // (undocumented)
    data?: never;
    // (undocumented)
    errors?: never;
    // (undocumented)
    extensions?: never;
    // Warning: (ae-forgotten-export) The symbol "IncrementalPayload" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    incremental?: IncrementalPayload<TData, TExtensions>[];
}

// @public (undocumented)
interface ExecutionPatchInitialResult<TData = Record<string, any>, TExtensions = Record<string, any>> extends ExecutionPatchResultBase {
    // (undocumented)
    data: TData | null | undefined;
    // (undocumented)
    errors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    extensions?: TExtensions;
    // (undocumented)
    incremental?: never;
}

// Warning: (ae-forgotten-export) The symbol "ExecutionPatchInitialResult" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExecutionPatchIncrementalResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ExecutionPatchResult<TData = Record<string, any>, TExtensions = Record<string, any>> = ExecutionPatchInitialResult<TData, TExtensions> | ExecutionPatchIncrementalResult<TData, TExtensions>;

// @public (undocumented)
interface ExecutionPatchResultBase {
    // (undocumented)
    hasNext?: boolean;
}

// @public (undocumented)
interface FetchMoreQueryOptions<TVariables, TData = any> {
    // (undocumented)
    context?: DefaultContext;
    query?: DocumentNode | TypedDocumentNode<TData, TVariables>;
    variables?: Partial<TVariables>;
}

// @public
type FetchPolicy = "cache-first" | "network-only" | "cache-only" | "no-cache" | "standby";

// @public (undocumented)
type FetchResult<TData = Record<string, any>, TContext = Record<string, any>, TExtensions = Record<string, any>> = SingleExecutionResult<TData, TContext, TExtensions> | ExecutionPatchResult<TData, TExtensions>;

// @public (undocumented)
interface FieldFunctionOptions<TArgs = Record<string, any>, TVars = Record<string, any>> {
    // (undocumented)
    args: TArgs | null;
    // (undocumented)
    cache: InMemoryCache;
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    field: FieldNode | null;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    isReference: typeof isReference;
    // Warning: (ae-forgotten-export) The symbol "MergeObjectsFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mergeObjects: MergeObjectsFunction;
    // Warning: (ae-forgotten-export) The symbol "ReadFieldFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readField: ReadFieldFunction;
    // (undocumented)
    storage: StorageType;
    // (undocumented)
    storeFieldName: string;
    // (undocumented)
    toReference: ToReferenceFunction;
    // (undocumented)
    variables?: TVars;
}

// Warning: (ae-forgotten-export) The symbol "FieldFunctionOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FieldMergeFunction<TExisting = any, TIncoming = TExisting, TOptions extends FieldFunctionOptions = FieldFunctionOptions> = (existing: SafeReadonly<TExisting> | undefined, incoming: SafeReadonly<TIncoming>, options: TOptions) => SafeReadonly<TExisting>;

// @public (undocumented)
type FieldPolicy<TExisting = any, TIncoming = TExisting, TReadResult = TIncoming, TOptions extends FieldFunctionOptions = FieldFunctionOptions> = {
    keyArgs?: KeySpecifier | KeyArgsFunction | false;
    read?: FieldReadFunction<TExisting, TReadResult, TOptions>;
    merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;
};

// @public (undocumented)
type FieldReadFunction<TExisting = any, TReadResult = TExisting, TOptions extends FieldFunctionOptions = FieldFunctionOptions> = (existing: SafeReadonly<TExisting> | undefined, options: TOptions) => TReadResult | undefined;

// @public (undocumented)
interface FieldSpecifier {
    // (undocumented)
    args?: Record<string, any>;
    // (undocumented)
    field?: FieldNode;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    typename?: string;
    // (undocumented)
    variables?: Record<string, any>;
}

// Warning: (ae-forgotten-export) The symbol "EntityStore" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FieldValueGetter = EntityStore["getFieldValue"];

// @public (undocumented)
export function fixObservableSubclass<S extends new (...args: any[]) => Observable<any>>(subclass: S): S;

// Warning: (ae-forgotten-export) The symbol "WriteContext" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FlavorableWriteContext = Pick<WriteContext, "clientOnly" | "deferred" | "flavors">;

// @public
export interface FragmentMap {
    // (undocumented)
    [fragmentName: string]: FragmentDefinitionNode;
}

// @public (undocumented)
export type FragmentMapFunction = (fragmentName: string) => FragmentDefinitionNode | null;

// @public (undocumented)
type FragmentMatcher = (rootValue: any, typeCondition: string, context: any) => boolean;

// @public (undocumented)
interface FragmentRegistryAPI {
    // (undocumented)
    lookup(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    register(...fragments: DocumentNode[]): this;
    // (undocumented)
    resetCaches(): void;
    // (undocumented)
    transform<D extends DocumentNode>(document: D): D;
}

// @public (undocumented)
interface FulfilledPromise<TValue> extends Promise<TValue> {
    // (undocumented)
    status: "fulfilled";
    // (undocumented)
    value: TValue;
}

// @internal
const getApolloCacheMemoryInternals: (() => {
    cache: {
        fragmentQueryDocuments: number | undefined;
    };
}) | undefined;

// @internal
const getApolloClientMemoryInternals: (() => {
    limits: {
        [k: string]: number;
    };
    sizes: {
        cache?: {
            fragmentQueryDocuments: number | undefined;
        } | undefined;
        addTypenameDocumentTransform?: {
            cache: number;
        }[] | undefined;
        inMemoryCache?: {
            executeSelectionSet: number | undefined;
            executeSubSelectedArray: number | undefined;
            maybeBroadcastWatch: number | undefined;
        } | undefined;
        fragmentRegistry?: {
            findFragmentSpreads: number | undefined;
            lookup: number | undefined;
            transform: number | undefined;
        } | undefined;
        print: number | undefined;
        parser: number | undefined;
        canonicalStringify: number | undefined;
        links: unknown[];
        queryManager: {
            getDocumentInfo: number;
            documentTransforms: {
                cache: number;
            }[];
        };
    };
}) | undefined;

// @public (undocumented)
export function getDefaultValues(definition: OperationDefinitionNode | undefined): Record<string, any>;

// @public (undocumented)
export type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;

// @public (undocumented)
export function getDirectiveNames(root: ASTNode): string[];

// @public (undocumented)
export function getFragmentDefinition(doc: DocumentNode): FragmentDefinitionNode;

// @public (undocumented)
export function getFragmentDefinitions(doc: DocumentNode): FragmentDefinitionNode[];

// @public (undocumented)
export function getFragmentFromSelection(selection: SelectionNode, fragmentMap?: FragmentMap | FragmentMapFunction): InlineFragmentNode | FragmentDefinitionNode | null;

// @public
export function getFragmentQueryDocument(document: DocumentNode, fragmentName?: string): DocumentNode;

// @public (undocumented)
export type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;

// @public (undocumented)
export function getGraphQLErrorsFromResult<T>(result: FetchResult<T>): GraphQLFormattedError[];

// @public (undocumented)
export function getInclusionDirectives(directives: ReadonlyArray<DirectiveNode>): InclusionDirectives;

// @internal
const getInMemoryCacheMemoryInternals: (() => {
    addTypenameDocumentTransform: {
        cache: number;
    }[];
    inMemoryCache: {
        executeSelectionSet: number | undefined;
        executeSubSelectedArray: number | undefined;
        maybeBroadcastWatch: number | undefined;
    };
    fragmentRegistry: {
        findFragmentSpreads: number | undefined;
        lookup: number | undefined;
        transform: number | undefined;
    };
    cache: {
        fragmentQueryDocuments: number | undefined;
    };
}) | undefined;

// @public
export function getMainDefinition(queryDoc: DocumentNode): OperationDefinitionNode | FragmentDefinitionNode;

// @public (undocumented)
export type GetNodeConfig<N> = {
    name?: string;
    test?: (node: N) => boolean;
};

// @public (undocumented)
export function getOperationDefinition(doc: DocumentNode): OperationDefinitionNode | undefined;

// @public (undocumented)
export function getOperationName(doc: DocumentNode): string | null;

// @public (undocumented)
export function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode;

// @public (undocumented)
export const getStoreKeyName: ((fieldName: string, args?: Record<string, any> | null, directives?: Directives) => string) & {
    setStringify(s: typeof storeKeyNameStringify): (value: any) => string;
};

// @public (undocumented)
export function getTypenameFromResult(result: Record<string, any>, selectionSet: SelectionSetNode, fragmentMap?: FragmentMap): string | undefined;

// @public (undocumented)
interface GraphQLRequest<TVariables = Record<string, any>> {
    // (undocumented)
    context?: DefaultContext;
    // (undocumented)
    extensions?: Record<string, any>;
    // (undocumented)
    operationName?: string;
    // (undocumented)
    query: DocumentNode;
    // (undocumented)
    variables?: TVariables;
}

// @public (undocumented)
export function graphQLResultHasError<T>(result: FetchResult<T>): boolean;

// @public (undocumented)
export const hasAllDirectives: (names: string[], root: ASTNode) => boolean;

// @public (undocumented)
export const hasAnyDirectives: (names: string[], root: ASTNode) => boolean;

// @public (undocumented)
export function hasClientExports(document: DocumentNode): boolean;

// @public (undocumented)
export function hasDirectives(names: string[], root: ASTNode, all?: boolean): boolean;

// Warning: (ae-forgotten-export) The symbol "IdGetterObj" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type IdGetter = (value: IdGetterObj) => string | undefined;

// @public (undocumented)
interface IdGetterObj extends Object {
    // (undocumented)
    __typename?: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    _id?: string;
}

// @public (undocumented)
interface IgnoreModifier {
    // (undocumented)
    [_ignoreModifier]: true;
}

// @public (undocumented)
const _ignoreModifier: unique symbol;

// @public (undocumented)
export type InclusionDirectives = Array<{
    directive: DirectiveNode;
    ifArgument: ArgumentNode;
}>;

// @public (undocumented)
interface IncrementalPayload<TData, TExtensions> {
    // (undocumented)
    data: TData | null;
    // (undocumented)
    errors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    extensions?: TExtensions;
    // (undocumented)
    label?: string;
    // Warning: (ae-forgotten-export) The symbol "Path" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    path: Path;
}

// @public (undocumented)
class InMemoryCache extends ApolloCache<NormalizedCacheObject> {
    constructor(config?: InMemoryCacheConfig);
    // (undocumented)
    readonly assumeImmutableResults = true;
    // (undocumented)
    batch<TUpdateResult>(options: Cache_2.BatchOptions<InMemoryCache, TUpdateResult>): TUpdateResult;
    // Warning: (ae-forgotten-export) The symbol "BroadcastOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected broadcastWatches(options?: BroadcastOptions): void;
    // Warning: (ae-forgotten-export) The symbol "InMemoryCacheConfig" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected config: InMemoryCacheConfig;
    // (undocumented)
    diff<TData, TVariables extends OperationVariables = any>(options: Cache_2.DiffOptions<TData, TVariables>): Cache_2.DiffResult<TData>;
    // (undocumented)
    evict(options: Cache_2.EvictOptions): boolean;
    // (undocumented)
    extract(optimistic?: boolean): NormalizedCacheObject;
    // (undocumented)
    gc(options?: {
        resetResultCache?: boolean;
        resetResultIdentities?: boolean;
    }): string[];
    // Warning: (ae-forgotten-export) The symbol "getInMemoryCacheMemoryInternals" needs to be exported by the entry point index.d.ts
    //
    // @internal
    getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // Warning: (ae-forgotten-export) The symbol "makeVar" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly makeVar: typeof makeVar;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_2.ModifyOptions<Entity>): boolean;
    // (undocumented)
    performTransaction(update: (cache: InMemoryCache) => any, optimisticId?: string | null): any;
    // (undocumented)
    readonly policies: Policies;
    // (undocumented)
    read<T>(options: Cache_2.ReadOptions): T | null;
    // (undocumented)
    release(rootId: string, optimistic?: boolean): number;
    // (undocumented)
    removeOptimistic(idToRemove: string): void;
    // (undocumented)
    reset(options?: Cache_2.ResetOptions): Promise<void>;
    // (undocumented)
    restore(data: NormalizedCacheObject): this;
    // (undocumented)
    retain(rootId: string, optimistic?: boolean): number;
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
    // (undocumented)
    watch<TData = any, TVariables = any>(watch: Cache_2.WatchOptions<TData, TVariables>): () => void;
    // (undocumented)
    write(options: Cache_2.WriteOptions): Reference | undefined;
}

// Warning: (ae-forgotten-export) The symbol "ApolloReducerConfig" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface InMemoryCacheConfig extends ApolloReducerConfig {
    // @deprecated (undocumented)
    canonizeResults?: boolean;
    // Warning: (ae-forgotten-export) The symbol "FragmentRegistryAPI" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fragments?: FragmentRegistryAPI;
    // Warning: (ae-forgotten-export) The symbol "PossibleTypesMap" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    possibleTypes?: PossibleTypesMap;
    // @deprecated (undocumented)
    resultCacheMaxSize?: number;
    // (undocumented)
    resultCaching?: boolean;
    // Warning: (ae-forgotten-export) The symbol "TypePolicies" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    typePolicies?: TypePolicies;
}

// Warning: (ae-forgotten-export) The symbol "InternalRefetchQueryDescriptor" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RefetchQueriesIncludeShorthand" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type InternalRefetchQueriesInclude = InternalRefetchQueryDescriptor[] | RefetchQueriesIncludeShorthand;

// Warning: (ae-forgotten-export) The symbol "InternalRefetchQueriesResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type InternalRefetchQueriesMap<TResult> = Map<ObservableQuery<any>, InternalRefetchQueriesResult<TResult>>;

// @public (undocumented)
interface InternalRefetchQueriesOptions<TCache extends ApolloCache<any>, TResult> extends Omit<RefetchQueriesOptions<TCache, TResult>, "include"> {
    // Warning: (ae-forgotten-export) The symbol "InternalRefetchQueriesInclude" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    include?: InternalRefetchQueriesInclude;
    // (undocumented)
    removeOptimistic?: string;
}

// @public (undocumented)
type InternalRefetchQueriesResult<TResult> = TResult extends boolean ? Promise<ApolloQueryResult<any>> : TResult;

// Warning: (ae-forgotten-export) The symbol "RefetchQueryDescriptor" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type InternalRefetchQueryDescriptor = RefetchQueryDescriptor | QueryOptions;

// @public (undocumented)
interface InvalidateModifier {
    // (undocumented)
    [_invalidateModifier]: true;
}

// @public (undocumented)
const _invalidateModifier: unique symbol;

// Warning: (ae-forgotten-export) The symbol "ApolloPayloadResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function isApolloPayloadResult(value: unknown): value is ApolloPayloadResult;

// @public (undocumented)
export const isArray: (a: any) => a is any[] | readonly any[];

// @public (undocumented)
export function isDocumentNode(value: any): value is DocumentNode;

// @public (undocumented)
export function isExecutionPatchIncrementalResult<T>(value: FetchResult<T>): value is ExecutionPatchIncrementalResult;

// @public (undocumented)
export function isExecutionPatchInitialResult<T>(value: FetchResult<T>): value is ExecutionPatchInitialResult<T>;

// @public (undocumented)
export function isExecutionPatchResult<T>(value: FetchResult<T>): value is ExecutionPatchResult<T>;

// @public (undocumented)
export function isField(selection: SelectionNode): selection is FieldNode;

// @public (undocumented)
export function isInlineFragment(selection: SelectionNode): selection is InlineFragmentNode;

// @public (undocumented)
export function isMutationOperation(document: DocumentNode): boolean;

// @public (undocumented)
export function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T>;

// @public (undocumented)
export function isNonNullObject(obj: any): obj is Record<string | number, any>;

// @public (undocumented)
export function isPlainObject(obj: any): obj is Record<string | number, any>;

// @public (undocumented)
export function isQueryOperation(document: DocumentNode): boolean;

// @public (undocumented)
export function isReference(obj: any): obj is Reference;

// @public (undocumented)
export function isStatefulPromise<TValue>(promise: Promise<TValue>): promise is PromiseWithState<TValue>;

// Warning: (ae-forgotten-export) The symbol "UnionToIntersection" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "UnionForAny" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type IsStrictlyAny<T> = UnionToIntersection<UnionForAny<T>> extends never ? true : false;

// @public (undocumented)
export function isSubscriptionOperation(document: DocumentNode): boolean;

// @public (undocumented)
export function iterateObserversSafely<E, A>(observers: Set<Observer<E>>, method: keyof Observer<E>, argument?: A): void;

// @public (undocumented)
type KeyArgs = FieldPolicy<any>["keyArgs"];

// Warning: (ae-forgotten-export) The symbol "IdGetter" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type KeyArgsFunction = (args: Record<string, any> | null, context: {
    typename: string;
    fieldName: string;
    field: FieldNode | null;
    variables?: Record<string, any>;
}) => KeySpecifier | false | ReturnType<IdGetter>;

// @public (undocumented)
type KeyFieldsContext = {
    typename: string | undefined;
    storeObject: StoreObject;
    readField: ReadFieldFunction;
    selectionSet?: SelectionSetNode;
    fragmentMap?: FragmentMap;
    keyObject?: Record<string, any>;
};

// Warning: (ae-forgotten-export) The symbol "KeyFieldsContext" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type KeyFieldsFunction = (object: Readonly<StoreObject>, context: KeyFieldsContext) => KeySpecifier | false | ReturnType<IdGetter>;

// @public (undocumented)
type KeySpecifier = ReadonlyArray<string | KeySpecifier>;

// @public (undocumented)
class Layer extends EntityStore {
    constructor(id: string, parent: EntityStore, replay: (layer: EntityStore) => any, group: CacheGroup);
    // (undocumented)
    addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
    // (undocumented)
    findChildRefIds(dataId: string): Record<string, true>;
    // (undocumented)
    getStorage(): StorageType;
    // (undocumented)
    readonly group: CacheGroup;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly parent: EntityStore;
    // (undocumented)
    removeLayer(layerId: string): EntityStore;
    // (undocumented)
    readonly replay: (layer: EntityStore) => any;
    // (undocumented)
    toObject(): NormalizedCacheObject;
}

// @public (undocumented)
class LocalState<TCacheShape> {
    // Warning: (ae-forgotten-export) The symbol "LocalStateOptions" needs to be exported by the entry point index.d.ts
    constructor({ cache, client, resolvers, fragmentMatcher, }: LocalStateOptions<TCacheShape>);
    // (undocumented)
    addExportedVariables<TVars extends OperationVariables>(document: DocumentNode, variables?: TVars, context?: {}): Promise<TVars>;
    // (undocumented)
    addResolvers(resolvers: Resolvers | Resolvers[]): void;
    // (undocumented)
    clientQuery(document: DocumentNode): DocumentNode | null;
    // (undocumented)
    getFragmentMatcher(): FragmentMatcher | undefined;
    // (undocumented)
    getResolvers(): Resolvers;
    // (undocumented)
    prepareContext(context?: Record<string, any>): {
        cache: ApolloCache<TCacheShape>;
        getCacheKey(obj: StoreObject): string | undefined;
    };
    // (undocumented)
    runResolvers<TData>({ document, remoteResult, context, variables, onlyRunForcedResolvers, }: {
        document: DocumentNode | null;
        remoteResult: FetchResult<TData>;
        context?: Record<string, any>;
        variables?: Record<string, any>;
        onlyRunForcedResolvers?: boolean;
    }): Promise<FetchResult<TData>>;
    // (undocumented)
    serverQuery(document: DocumentNode): DocumentNode | null;
    // (undocumented)
    setFragmentMatcher(fragmentMatcher: FragmentMatcher): void;
    // (undocumented)
    setResolvers(resolvers: Resolvers | Resolvers[]): void;
    // (undocumented)
    shouldForceResolvers(document: ASTNode): boolean;
}

// @public (undocumented)
type LocalStateOptions<TCacheShape> = {
    cache: ApolloCache<TCacheShape>;
    client?: ApolloClient<TCacheShape>;
    resolvers?: Resolvers | Resolvers[];
    fragmentMatcher?: FragmentMatcher;
};

// @public (undocumented)
export function makeReference(id: string): Reference;

// @public (undocumented)
export function makeUniqueId(prefix: string): string;

// Warning: (ae-forgotten-export) The symbol "ReactiveVar" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function makeVar<T>(value: T): ReactiveVar<T>;

// @public (undocumented)
export function maybe<T>(thunk: () => T): T | undefined;

// @public (undocumented)
type MaybeAsync<T> = T | PromiseLike<T>;

// @public (undocumented)
export function maybeDeepFreeze<T>(obj: T): T;

// @public (undocumented)
export function mergeDeep<T extends any[]>(...sources: T): TupleToIntersection<T>;

// @public (undocumented)
export function mergeDeepArray<T>(sources: T[]): T;

// @public (undocumented)
export function mergeIncrementalData<TData extends object>(prevResult: TData, result: ExecutionPatchResult<TData>): TData;

// @public (undocumented)
interface MergeInfo {
    // (undocumented)
    field: FieldNode;
    // (undocumented)
    merge: FieldMergeFunction;
    // (undocumented)
    typename: string | undefined;
}

// @public (undocumented)
type MergeObjectsFunction = <T extends StoreObject | Reference>(existing: T, incoming: T) => T;

// Warning: (ae-forgotten-export) The symbol "OptionsUnion" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function mergeOptions<TDefaultOptions extends Partial<OptionsUnion<any, any, any>>, TOptions extends TDefaultOptions>(defaults: TDefaultOptions | Partial<TDefaultOptions> | undefined, options: TOptions | Partial<TOptions>): TOptions & TDefaultOptions;

// @public (undocumented)
interface MergeTree {
    // Warning: (ae-forgotten-export) The symbol "MergeInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    info?: MergeInfo;
    // (undocumented)
    map: Map<string | number, MergeTree>;
}

// @public (undocumented)
class MissingFieldError extends Error {
    constructor(message: string, path: MissingTree | Array<string | number>, query: DocumentNode, variables?: Record<string, any> | undefined);
    // (undocumented)
    readonly message: string;
    // (undocumented)
    readonly missing: MissingTree;
    // Warning: (ae-forgotten-export) The symbol "MissingTree" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly path: MissingTree | Array<string | number>;
    // (undocumented)
    readonly query: DocumentNode;
    // (undocumented)
    readonly variables?: Record<string, any> | undefined;
}

// @public (undocumented)
type MissingTree = string | {
    readonly [key: string]: MissingTree;
};

// Warning: (ae-forgotten-export) The symbol "ModifierDetails" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeleteModifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "InvalidateModifier" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Modifier<T> = (value: T, details: ModifierDetails) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;

// @public (undocumented)
type ModifierDetails = {
    DELETE: DeleteModifier;
    INVALIDATE: InvalidateModifier;
    fieldName: string;
    storeFieldName: string;
    readField: ReadFieldFunction;
    canRead: CanReadFunction;
    isReference: typeof isReference;
    toReference: ToReferenceFunction;
    storage: StorageType;
};

// @public (undocumented)
type Modifiers<T extends Record<string, any> = Record<string, unknown>> = Partial<{
    [FieldName in keyof T]: Modifier<StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>>;
}>;

// @public (undocumented)
interface MutationBaseOptions<TData = any, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache<any> = ApolloCache<any>> {
    awaitRefetchQueries?: boolean;
    context?: TContext;
    // Warning: (ae-forgotten-export) The symbol "ErrorPolicy" needs to be exported by the entry point index.d.ts
    errorPolicy?: ErrorPolicy;
    // Warning: (ae-forgotten-export) The symbol "OnQueryUpdated" needs to be exported by the entry point index.d.ts
    onQueryUpdated?: OnQueryUpdated<any>;
    // Warning: (ae-forgotten-export) The symbol "IgnoreModifier" needs to be exported by the entry point index.d.ts
    optimisticResponse?: TData | ((vars: TVariables, { IGNORE }: {
        IGNORE: IgnoreModifier;
    }) => TData | IgnoreModifier);
    refetchQueries?: ((result: FetchResult<TData>) => InternalRefetchQueriesInclude) | InternalRefetchQueriesInclude;
    // Warning: (ae-forgotten-export) The symbol "MutationUpdaterFunction" needs to be exported by the entry point index.d.ts
    update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
    // Warning: (ae-forgotten-export) The symbol "MutationQueryReducersMap" needs to be exported by the entry point index.d.ts
    updateQueries?: MutationQueryReducersMap<TData>;
    variables?: TVariables;
}

// Warning: (ae-forgotten-export) The symbol "FetchPolicy" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MutationFetchPolicy = Extract<FetchPolicy, "network-only" | "no-cache">;

// Warning: (ae-forgotten-export) The symbol "MutationSharedOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface MutationOptions<TData = any, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache<any> = ApolloCache<any>> extends MutationSharedOptions<TData, TVariables, TContext, TCache> {
    mutation: DocumentNode | TypedDocumentNode<TData, TVariables>;
}

// @public (undocumented)
type MutationQueryReducer<T> = (previousResult: Record<string, any>, options: {
    mutationResult: FetchResult<T>;
    queryName: string | undefined;
    queryVariables: Record<string, any>;
}) => Record<string, any>;

// @public (undocumented)
type MutationQueryReducersMap<T = {
    [key: string]: any;
}> = {
    [queryName: string]: MutationQueryReducer<T>;
};

// Warning: (ae-forgotten-export) The symbol "MutationBaseOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface MutationSharedOptions<TData = any, TVariables = OperationVariables, TContext = DefaultContext, TCache extends ApolloCache<any> = ApolloCache<any>> extends MutationBaseOptions<TData, TVariables, TContext, TCache> {
    // Warning: (ae-forgotten-export) The symbol "MutationFetchPolicy" needs to be exported by the entry point index.d.ts
    fetchPolicy?: MutationFetchPolicy;
    keepRootFields?: boolean;
}

// @public (undocumented)
interface MutationStoreValue {
    // (undocumented)
    error: Error | null;
    // (undocumented)
    loading: boolean;
    // (undocumented)
    mutation: DocumentNode;
    // (undocumented)
    variables: Record<string, any>;
}

// @public (undocumented)
type MutationUpdaterFunction<TData, TVariables, TContext, TCache extends ApolloCache<any>> = (cache: TCache, result: Omit<FetchResult<TData>, "context">, options: {
    context?: TContext;
    variables?: TVariables;
}) => void;

// @public
enum NetworkStatus {
    error = 8,
    fetchMore = 3,
    loading = 1,
    poll = 6,
    ready = 7,
    refetch = 4,
    setVariables = 2
}

// @public (undocumented)
interface NextFetchPolicyContext<TData, TVariables extends OperationVariables> {
    // Warning: (ae-forgotten-export) The symbol "WatchQueryFetchPolicy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    initialFetchPolicy: WatchQueryFetchPolicy;
    // (undocumented)
    observable: ObservableQuery<TData, TVariables>;
    // (undocumented)
    options: WatchQueryOptions<TVariables, TData>;
    // (undocumented)
    reason: "after-fetch" | "variables-changed";
}

// @public (undocumented)
type NextLink = (operation: Operation) => Observable<FetchResult>;

// @public (undocumented)
type NextResultListener = (method: "next" | "error" | "complete", arg?: any) => any;

// @public
interface NormalizedCache {
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    clear(): void;
    // (undocumented)
    delete(dataId: string, fieldName?: string): boolean;
    // (undocumented)
    get(dataId: string, fieldName: string): StoreValue;
    // Warning: (ae-forgotten-export) The symbol "FieldValueGetter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getFieldValue: FieldValueGetter;
    // (undocumented)
    getStorage(idOrObj: string | StoreObject, ...storeFieldNames: (string | number)[]): StorageType;
    // (undocumented)
    has(dataId: string): boolean;
    // (undocumented)
    merge(olderId: string, newerObject: StoreObject): void;
    // (undocumented)
    merge(olderObject: StoreObject, newerId: string): void;
    // (undocumented)
    modify<Entity extends Record<string, any>>(dataId: string, fields: Modifiers<Entity> | AllFieldsModifier<Entity>): boolean;
    // (undocumented)
    release(rootId: string): number;
    replace(newData: NormalizedCacheObject): void;
    retain(rootId: string): number;
    toObject(): NormalizedCacheObject;
    // (undocumented)
    toReference: ToReferenceFunction;
}

// @public
interface NormalizedCacheObject {
    // (undocumented)
    [dataId: string]: StoreObject | undefined;
    // (undocumented)
    __META?: {
        extraRootIds: string[];
    };
}

export { Observable }

// @public (undocumented)
class ObservableQuery<TData = any, TVariables extends OperationVariables = OperationVariables> extends Observable<ApolloQueryResult<TData>> {
    constructor({ queryManager, queryInfo, options, }: {
        queryManager: QueryManager<any>;
        queryInfo: QueryInfo;
        options: WatchQueryOptions<TVariables, TData>;
    });
    // Warning: (ae-forgotten-export) The symbol "FetchMoreQueryOptions" needs to be exported by the entry point index.d.ts
    fetchMore<TFetchData = TData, TFetchVars extends OperationVariables = TVariables>(fetchMoreOptions: FetchMoreQueryOptions<TFetchVars, TFetchData> & {
        updateQuery?: (previousQueryResult: TData, options: {
            fetchMoreResult: TFetchData;
            variables: TFetchVars;
        }) => TData;
    }): Promise<ApolloQueryResult<TFetchData>>;
    // (undocumented)
    getCurrentResult(saveAsLastResult?: boolean): ApolloQueryResult<TData>;
    // (undocumented)
    getLastError(variablesMustMatch?: boolean): ApolloError | undefined;
    // (undocumented)
    getLastResult(variablesMustMatch?: boolean): ApolloQueryResult<TData> | undefined;
    // (undocumented)
    hasObservers(): boolean;
    // (undocumented)
    isDifferentFromLastResult(newResult: ApolloQueryResult<TData>, variables?: TVariables): boolean | undefined;
    // (undocumented)
    readonly options: WatchQueryOptions<TVariables, TData>;
    // (undocumented)
    get query(): TypedDocumentNode<TData, TVariables>;
    // (undocumented)
    readonly queryId: string;
    // (undocumented)
    readonly queryName?: string;
    refetch(variables?: Partial<TVariables>): Promise<ApolloQueryResult<TData>>;
    // (undocumented)
    reobserve(newOptions?: Partial<WatchQueryOptions<TVariables, TData>>, newNetworkStatus?: NetworkStatus): Promise<ApolloQueryResult<TData>>;
    // (undocumented)
    reobserveAsConcast(newOptions?: Partial<WatchQueryOptions<TVariables, TData>>, newNetworkStatus?: NetworkStatus): Concast<ApolloQueryResult<TData>>;
    // @internal (undocumented)
    resetDiff(): void;
    // (undocumented)
    resetLastResults(): void;
    // (undocumented)
    resetQueryStoreErrors(): void;
    // (undocumented)
    resubscribeAfterError(onNext: (value: ApolloQueryResult<TData>) => void, onError?: (error: any) => void, onComplete?: () => void): ObservableSubscription;
    // (undocumented)
    resubscribeAfterError(observer: Observer<ApolloQueryResult<TData>>): ObservableSubscription;
    // (undocumented)
    result(): Promise<ApolloQueryResult<TData>>;
    // (undocumented)
    setOptions(newOptions: Partial<WatchQueryOptions<TVariables, TData>>): Promise<ApolloQueryResult<TData>>;
    setVariables(variables: TVariables): Promise<ApolloQueryResult<TData> | void>;
    // (undocumented)
    silentSetOptions(newOptions: Partial<WatchQueryOptions<TVariables, TData>>): void;
    startPolling(pollInterval: number): void;
    stopPolling(): void;
    // Warning: (ae-forgotten-export) The symbol "SubscribeToMoreOptions" needs to be exported by the entry point index.d.ts
    subscribeToMore<TSubscriptionData = TData, TSubscriptionVariables extends OperationVariables = TVariables>(options: SubscribeToMoreOptions<TData, TSubscriptionVariables, TSubscriptionData>): () => void;
    updateQuery<TVars extends OperationVariables = TVariables>(mapFn: (previousQueryResult: TData, options: Pick<WatchQueryOptions<TVars, TData>, "variables">) => TData): void;
    get variables(): TVariables | undefined;
}

export { ObservableSubscription }

export { Observer }

// @public (undocumented)
export function offsetLimitPagination<T = Reference>(keyArgs?: KeyArgs): FieldPolicy<T[]>;

// @public (undocumented)
export function omitDeep<T, K extends string>(value: T, key: K): DeepOmit<T, K>;

// @public
export type OnlyRequiredProperties<T> = {
    [K in keyof T as {} extends Pick<T, K> ? never : K]: T[K];
};

// @public (undocumented)
type OnQueryUpdated<TResult> = (observableQuery: ObservableQuery<any>, diff: Cache_2.DiffResult<any>, lastDiff: Cache_2.DiffResult<any> | undefined) => boolean | TResult;

// @public (undocumented)
interface Operation {
    // (undocumented)
    extensions: Record<string, any>;
    // (undocumented)
    getContext: () => DefaultContext;
    // (undocumented)
    operationName: string;
    // (undocumented)
    query: DocumentNode;
    // (undocumented)
    setContext: {
        (context: Partial<DefaultContext>): void;
        (updateContext: (previousContext: DefaultContext) => Partial<DefaultContext>): void;
    };
    // (undocumented)
    variables: Record<string, any>;
}

// @public (undocumented)
type OperationVariables = Record<string, any>;

// @public (undocumented)
type OptionsUnion<TData, TVariables extends OperationVariables, TContext> = WatchQueryOptions<TVariables, TData> | QueryOptions<TVariables, TData> | MutationOptions<TData, TVariables, TContext, any>;

// @public (undocumented)
type Path = ReadonlyArray<string | number>;

// @public (undocumented)
interface PendingPromise<TValue> extends Promise<TValue> {
    // (undocumented)
    status: "pending";
}

// @public (undocumented)
class Policies {
    constructor(config: {
        cache: InMemoryCache;
        dataIdFromObject?: KeyFieldsFunction;
        possibleTypes?: PossibleTypesMap;
        typePolicies?: TypePolicies;
    });
    // (undocumented)
    addPossibleTypes(possibleTypes: PossibleTypesMap): void;
    // (undocumented)
    addTypePolicies(typePolicies: TypePolicies): void;
    // (undocumented)
    readonly cache: InMemoryCache;
    // (undocumented)
    fragmentMatches(fragment: InlineFragmentNode | FragmentDefinitionNode, typename: string | undefined, result?: Record<string, any>, variables?: Record<string, any>): boolean;
    // (undocumented)
    getMergeFunction(parentTypename: string | undefined, fieldName: string, childTypename: string | undefined): FieldMergeFunction | undefined;
    // (undocumented)
    getReadFunction(typename: string | undefined, fieldName: string): FieldReadFunction | undefined;
    // Warning: (ae-forgotten-export) The symbol "FieldSpecifier" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getStoreFieldName(fieldSpec: FieldSpecifier): string;
    // (undocumented)
    hasKeyArgs(typename: string | undefined, fieldName: string): boolean;
    // (undocumented)
    identify(object: StoreObject, partialContext?: Partial<KeyFieldsContext>): [string?, StoreObject?];
    // Warning: (ae-forgotten-export) The symbol "ReadFieldOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ReadMergeModifyContext" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readField<V = StoreValue>(options: ReadFieldOptions, context: ReadMergeModifyContext): SafeReadonly<V> | undefined;
    // (undocumented)
    readonly rootIdsByTypename: Record<string, string>;
    // (undocumented)
    readonly rootTypenamesById: Record<string, string>;
    // (undocumented)
    runMergeFunction(existing: StoreValue, incoming: StoreValue, { field, typename, merge }: MergeInfo, context: WriteContext, storage?: StorageType): any;
    // (undocumented)
    readonly usingPossibleTypes = false;
}

// @public (undocumented)
type PossibleTypesMap = {
    [supertype: string]: string[];
};

// @public (undocumented)
type Primitive = null | undefined | string | number | boolean | symbol | bigint;

// @public (undocumented)
const print_2: ((ast: ASTNode) => string) & {
    reset(): void;
};
export { print_2 as print }

// Warning: (ae-forgotten-export) The symbol "PendingPromise" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type PromiseWithState<TValue> = PendingPromise<TValue> | FulfilledPromise<TValue> | RejectedPromise<TValue>;

// @public (undocumented)
class QueryInfo {
    constructor(queryManager: QueryManager<any>, queryId?: string);
    // (undocumented)
    document: DocumentNode | null;
    // (undocumented)
    getDiff(): Cache_2.DiffResult<any>;
    // (undocumented)
    graphQLErrors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    init(query: {
        document: DocumentNode;
        variables: Record<string, any> | undefined;
        networkStatus?: NetworkStatus;
        observableQuery?: ObservableQuery<any, any>;
        lastRequestId?: number;
    }): this;
    // (undocumented)
    lastRequestId: number;
    // Warning: (ae-forgotten-export) The symbol "QueryListener" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    listeners: Set<QueryListener>;
    // (undocumented)
    markError(error: ApolloError): ApolloError;
    // (undocumented)
    markReady(): NetworkStatus;
    // Warning: (ae-forgotten-export) The symbol "CacheWriteBehavior" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    markResult<T>(result: FetchResult<T>, document: DocumentNode, options: Pick<WatchQueryOptions, "variables" | "fetchPolicy" | "errorPolicy">, cacheWriteBehavior: CacheWriteBehavior): void;
    // (undocumented)
    networkError?: Error | null;
    // (undocumented)
    networkStatus?: NetworkStatus;
    // (undocumented)
    notify(): void;
    // (undocumented)
    readonly observableQuery: ObservableQuery<any, any> | null;
    // (undocumented)
    readonly queryId: string;
    // (undocumented)
    reset(): void;
    // (undocumented)
    resetDiff(): void;
    // (undocumented)
    resetLastWrite(): void;
    // (undocumented)
    setDiff(diff: Cache_2.DiffResult<any> | null): void;
    // (undocumented)
    setObservableQuery(oq: ObservableQuery<any, any> | null): void;
    // (undocumented)
    stop(): void;
    // (undocumented)
    stopped: boolean;
    // (undocumented)
    variables?: Record<string, any>;
}

// @public (undocumented)
type QueryListener = (queryInfo: QueryInfo) => void;

// @public (undocumented)
class QueryManager<TStore> {
    // Warning: (ae-forgotten-export) The symbol "QueryManagerOptions" needs to be exported by the entry point index.d.ts
    constructor(options: QueryManagerOptions<TStore>);
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    // (undocumented)
    broadcastQueries(): void;
    // (undocumented)
    cache: ApolloCache<TStore>;
    // (undocumented)
    clearStore(options?: Cache_2.ResetOptions): Promise<void>;
    // (undocumented)
    readonly defaultContext: Partial<DefaultContext>;
    // Warning: (ae-forgotten-export) The symbol "DefaultOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    defaultOptions: DefaultOptions;
    // (undocumented)
    readonly documentTransform: DocumentTransform;
    // (undocumented)
    protected fetchCancelFns: Map<string, (error: any) => any>;
    // (undocumented)
    fetchQuery<TData, TVars extends OperationVariables>(queryId: string, options: WatchQueryOptions<TVars, TData>, networkStatus?: NetworkStatus): Promise<ApolloQueryResult<TData>>;
    // (undocumented)
    generateMutationId(): string;
    // (undocumented)
    generateQueryId(): string;
    // (undocumented)
    generateRequestId(): number;
    // Warning: (ae-forgotten-export) The symbol "TransformCacheEntry" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getDocumentInfo(document: DocumentNode): TransformCacheEntry;
    // Warning: (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getLocalState(): LocalState<TStore>;
    // (undocumented)
    getObservableQueries(include?: InternalRefetchQueriesInclude): Map<string, ObservableQuery<any, OperationVariables>>;
    // Warning: (ae-forgotten-export) The symbol "QueryStoreValue" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getQueryStore(): Record<string, QueryStoreValue>;
    // (undocumented)
    protected inFlightLinkObservables: Trie<{
        observable?: Observable<FetchResult<any>>;
    }>;
    // (undocumented)
    link: ApolloLink;
    // (undocumented)
    markMutationOptimistic<TData, TVariables, TContext, TCache extends ApolloCache<any>>(optimisticResponse: any, mutation: {
        mutationId: string;
        document: DocumentNode;
        variables?: TVariables;
        fetchPolicy?: MutationFetchPolicy;
        errorPolicy: ErrorPolicy;
        context?: TContext;
        updateQueries: UpdateQueries<TData>;
        update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
        keepRootFields?: boolean;
    }): boolean;
    // (undocumented)
    markMutationResult<TData, TVariables, TContext, TCache extends ApolloCache<any>>(mutation: {
        mutationId: string;
        result: FetchResult<TData>;
        document: DocumentNode;
        variables?: TVariables;
        fetchPolicy?: MutationFetchPolicy;
        errorPolicy: ErrorPolicy;
        context?: TContext;
        updateQueries: UpdateQueries<TData>;
        update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;
        awaitRefetchQueries?: boolean;
        refetchQueries?: InternalRefetchQueriesInclude;
        removeOptimistic?: string;
        onQueryUpdated?: OnQueryUpdated<any>;
        keepRootFields?: boolean;
    }, cache?: ApolloCache<TStore>): Promise<FetchResult<TData>>;
    // (undocumented)
    mutate<TData, TVariables extends OperationVariables, TContext extends Record<string, any>, TCache extends ApolloCache<any>>({ mutation, variables, optimisticResponse, updateQueries, refetchQueries, awaitRefetchQueries, update: updateWithProxyFn, onQueryUpdated, fetchPolicy, errorPolicy, keepRootFields, context, }: MutationOptions<TData, TVariables, TContext>): Promise<FetchResult<TData>>;
    // (undocumented)
    mutationStore?: {
        [mutationId: string]: MutationStoreValue;
    };
    // (undocumented)
    query<TData, TVars extends OperationVariables = OperationVariables>(options: QueryOptions<TVars, TData>, queryId?: string): Promise<ApolloQueryResult<TData>>;
    // (undocumented)
    reFetchObservableQueries(includeStandby?: boolean): Promise<ApolloQueryResult<any>[]>;
    // Warning: (ae-forgotten-export) The symbol "InternalRefetchQueriesOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "InternalRefetchQueriesMap" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    refetchQueries<TResult>({ updateCache, include, optimistic, removeOptimistic, onQueryUpdated, }: InternalRefetchQueriesOptions<ApolloCache<TStore>, TResult>): InternalRefetchQueriesMap<TResult>;
    // (undocumented)
    removeQuery(queryId: string): void;
    // (undocumented)
    resetErrors(queryId: string): void;
    // (undocumented)
    setObservableQuery(observableQuery: ObservableQuery<any, any>): void;
    // (undocumented)
    readonly ssrMode: boolean;
    // (undocumented)
    startGraphQLSubscription<T = any>({ query, fetchPolicy, errorPolicy, variables, context, extensions, }: SubscriptionOptions): Observable<FetchResult<T>>;
    stop(): void;
    // (undocumented)
    stopQuery(queryId: string): void;
    // (undocumented)
    stopQueryInStore(queryId: string): void;
    // (undocumented)
    transform(document: DocumentNode): DocumentNode;
    // (undocumented)
    watchQuery<T, TVariables extends OperationVariables = OperationVariables>(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables>;
}

// @public (undocumented)
interface QueryManagerOptions<TStore> {
    // (undocumented)
    assumeImmutableResults: boolean;
    // (undocumented)
    cache: ApolloCache<TStore>;
    // (undocumented)
    clientAwareness: Record<string, string>;
    // (undocumented)
    defaultContext: Partial<DefaultContext> | undefined;
    // (undocumented)
    defaultOptions: DefaultOptions;
    // (undocumented)
    documentTransform: DocumentTransform | null | undefined;
    // (undocumented)
    link: ApolloLink;
    // (undocumented)
    localState: LocalState<TStore>;
    // (undocumented)
    onBroadcast: undefined | (() => void);
    // (undocumented)
    queryDeduplication: boolean;
    // (undocumented)
    ssrMode: boolean;
}

// @public
interface QueryOptions<TVariables = OperationVariables, TData = any> {
    // @deprecated
    canonizeResults?: boolean;
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    fetchPolicy?: FetchPolicy;
    notifyOnNetworkStatusChange?: boolean;
    // @deprecated
    partialRefetch?: boolean;
    pollInterval?: number;
    query: DocumentNode | TypedDocumentNode<TData, TVariables>;
    returnPartialData?: boolean;
    variables?: TVariables;
}

// @public (undocumented)
type QueryStoreValue = Pick<QueryInfo, "variables" | "networkStatus" | "networkError" | "graphQLErrors">;

// @public (undocumented)
type ReactiveListener<T> = (value: T) => any;

// @public (undocumented)
interface ReactiveVar<T> {
    // (undocumented)
    (newValue?: T): T;
    // (undocumented)
    attachCache(cache: ApolloCache<any>): this;
    // (undocumented)
    forgetCache(cache: ApolloCache<any>): boolean;
    // Warning: (ae-forgotten-export) The symbol "ReactiveListener" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    onNextChange(listener: ReactiveListener<T>): () => void;
}

// @public (undocumented)
interface ReadFieldFunction {
    // (undocumented)
    <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;
    // (undocumented)
    <V = StoreValue>(fieldName: string, from?: StoreObject | Reference): SafeReadonly<V> | undefined;
}

// @public (undocumented)
interface ReadFieldOptions extends FieldSpecifier {
    // (undocumented)
    from?: StoreObject | Reference;
}

// @public (undocumented)
interface ReadMergeModifyContext {
    // (undocumented)
    store: NormalizedCache;
    // (undocumented)
    variables?: Record<string, any>;
    // (undocumented)
    varString?: string;
}

// @public (undocumented)
export type ReconcilerFunction<TContextArgs extends any[]> = (this: DeepMerger<TContextArgs>, target: Record<string | number, any>, source: Record<string | number, any>, property: string | number, ...context: TContextArgs) => any;

// @public (undocumented)
export interface Reference {
    // (undocumented)
    readonly __ref: string;
}

// @public (undocumented)
type RefetchQueriesInclude = RefetchQueryDescriptor[] | RefetchQueriesIncludeShorthand;

// @public (undocumented)
type RefetchQueriesIncludeShorthand = "all" | "active";

// @public (undocumented)
interface RefetchQueriesOptions<TCache extends ApolloCache<any>, TResult> {
    // (undocumented)
    include?: RefetchQueriesInclude;
    // (undocumented)
    onQueryUpdated?: OnQueryUpdated<TResult> | null;
    // (undocumented)
    optimistic?: boolean;
    // (undocumented)
    updateCache?: (cache: TCache) => void;
}

// @public (undocumented)
type RefetchQueriesPromiseResults<TResult> = IsStrictlyAny<TResult> extends true ? any[] : TResult extends boolean ? ApolloQueryResult<any>[] : TResult extends PromiseLike<infer U> ? U[] : TResult[];

// Warning: (ae-forgotten-export) The symbol "RefetchQueriesPromiseResults" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface RefetchQueriesResult<TResult> extends Promise<RefetchQueriesPromiseResults<TResult>> {
    // (undocumented)
    queries: ObservableQuery<any>[];
    // (undocumented)
    results: InternalRefetchQueriesResult<TResult>[];
}

// @public (undocumented)
type RefetchQueryDescriptor = string | DocumentNode;

// @public (undocumented)
type RefetchWritePolicy = "merge" | "overwrite";

// @public (undocumented)
interface RejectedPromise<TValue> extends Promise<TValue> {
    // (undocumented)
    reason: unknown;
    // (undocumented)
    status: "rejected";
}

// Warning: (ae-forgotten-export) The symbol "TExistingRelay" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TIncomingRelay" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type RelayFieldPolicy<TNode> = FieldPolicy<TExistingRelay<TNode> | null, TIncomingRelay<TNode> | null, TIncomingRelay<TNode> | null>;

// Warning: (ae-forgotten-export) The symbol "RelayFieldPolicy" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function relayStylePagination<TNode extends Reference = Reference>(keyArgs?: KeyArgs): RelayFieldPolicy<TNode>;

// @public (undocumented)
export type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;

// @public (undocumented)
export function removeArgumentsFromDocument(config: RemoveArgumentsConfig[], doc: DocumentNode): DocumentNode | null;

// @public (undocumented)
export function removeClientSetsFromDocument(document: DocumentNode): DocumentNode | null;

// @public (undocumented)
export function removeConnectionDirectiveFromDocument(doc: DocumentNode): DocumentNode | null;

// @public (undocumented)
export type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;

// @public (undocumented)
export function removeDirectivesFromDocument(directives: RemoveDirectiveConfig[], doc: DocumentNode): DocumentNode | null;

// @public (undocumented)
export type RemoveFragmentDefinitionConfig = RemoveNodeConfig<FragmentDefinitionNode>;

// @public (undocumented)
export type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;

// @public (undocumented)
export function removeFragmentSpreadFromDocument(config: RemoveFragmentSpreadConfig[], doc: DocumentNode): DocumentNode | null;

// @public (undocumented)
export type RemoveNodeConfig<N> = {
    name?: string;
    test?: (node: N) => boolean;
    remove?: boolean;
};

// @public (undocumented)
export type RemoveVariableDefinitionConfig = RemoveNodeConfig<VariableDefinitionNode>;

// @public (undocumented)
type RequestHandler = (operation: Operation, forward: NextLink) => Observable<FetchResult> | null;

// @public (undocumented)
type Resolver = (rootValue?: any, args?: any, context?: any, info?: {
    field: FieldNode;
    fragmentMap: FragmentMap;
}) => any;

// @public (undocumented)
interface Resolvers {
    // (undocumented)
    [key: string]: {
        [field: string]: Resolver;
    };
}

// @public (undocumented)
export function resultKeyNameFromField(field: FieldNode): string;

// @public (undocumented)
type SafeReadonly<T> = T extends object ? Readonly<T> : T;

// @public (undocumented)
type ServerError = Error & {
    response: Response;
    result: Record<string, any> | string;
    statusCode: number;
};

// @public (undocumented)
type ServerParseError = Error & {
    response: Response;
    statusCode: number;
    bodyText: string;
};

// @public (undocumented)
interface SharedWatchQueryOptions<TVariables extends OperationVariables, TData> {
    // @deprecated
    canonizeResults?: boolean;
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    fetchPolicy?: WatchQueryFetchPolicy;
    initialFetchPolicy?: WatchQueryFetchPolicy;
    // Warning: (ae-forgotten-export) The symbol "NextFetchPolicyContext" needs to be exported by the entry point index.d.ts
    nextFetchPolicy?: WatchQueryFetchPolicy | ((this: WatchQueryOptions<TVariables, TData>, currentFetchPolicy: WatchQueryFetchPolicy, context: NextFetchPolicyContext<TData, TVariables>) => WatchQueryFetchPolicy);
    notifyOnNetworkStatusChange?: boolean;
    // @deprecated
    partialRefetch?: boolean;
    pollInterval?: number;
    // Warning: (ae-forgotten-export) The symbol "RefetchWritePolicy" needs to be exported by the entry point index.d.ts
    refetchWritePolicy?: RefetchWritePolicy;
    returnPartialData?: boolean;
    skipPollAttempt?: () => boolean;
    variables?: TVariables;
}

// @public (undocumented)
export function shouldInclude({ directives }: SelectionNode, variables?: Record<string, any>): boolean;

// @public (undocumented)
interface SingleExecutionResult<TData = Record<string, any>, TContext = DefaultContext, TExtensions = Record<string, any>> {
    // (undocumented)
    context?: TContext;
    // (undocumented)
    data?: TData | null;
    // (undocumented)
    errors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    extensions?: TExtensions;
}

// @public (undocumented)
type Source<T> = MaybeAsync<Observable<T>>;

// @public (undocumented)
type StorageType = Record<string, any>;

// @public (undocumented)
export function storeKeyNameFromField(field: FieldNode, variables?: Object): string;

// @public (undocumented)
let storeKeyNameStringify: (value: any) => string;

// @public (undocumented)
export interface StoreObject {
    // (undocumented)
    [storeFieldName: string]: StoreValue;
    // (undocumented)
    __typename?: string;
}

// @public (undocumented)
type StoreObjectValueMaybeReference<StoreVal> = StoreVal extends Array<Record<string, any>> ? StoreVal extends Array<infer Item> ? [
Item
] extends [Record<string, any>] ? ReadonlyArray<AsStoreObject<Item> | Reference> : never : never : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference : StoreVal;

// @public (undocumented)
export type StoreValue = number | string | string[] | Reference | Reference[] | null | undefined | void | Object;

// @public (undocumented)
export function stringifyForDisplay(value: any, space?: number): string;

// @public (undocumented)
export function stripTypename<T>(value: T): DeepOmit<T, "__typename">;

// @public (undocumented)
class Stump extends Layer {
    constructor(root: EntityStore.Root);
    // (undocumented)
    merge(older: string | StoreObject, newer: string | StoreObject): void;
    // (undocumented)
    removeLayer(): this;
}

// @public (undocumented)
type SubscribeToMoreOptions<TData = any, TSubscriptionVariables = OperationVariables, TSubscriptionData = TData> = {
    document: DocumentNode | TypedDocumentNode<TSubscriptionData, TSubscriptionVariables>;
    variables?: TSubscriptionVariables;
    updateQuery?: UpdateQueryFn<TData, TSubscriptionVariables, TSubscriptionData>;
    onError?: (error: Error) => void;
    context?: DefaultContext;
};

// @public (undocumented)
interface SubscriptionOptions<TVariables = OperationVariables, TData = any> {
    context?: DefaultContext;
    errorPolicy?: ErrorPolicy;
    extensions?: Record<string, any>;
    fetchPolicy?: FetchPolicy;
    query: DocumentNode | TypedDocumentNode<TData, TVariables>;
    variables?: TVariables;
}

// @public (undocumented)
type TExistingRelay<TNode> = Readonly<{
    edges: TRelayEdge<TNode>[];
    pageInfo: TRelayPageInfo;
}>;

// @public (undocumented)
type TIncomingRelay<TNode> = {
    edges?: TRelayEdge<TNode>[];
    pageInfo?: TRelayPageInfo;
};

// @public (undocumented)
type ToReferenceFunction = (objOrIdOrRef: StoreObject | string | Reference, mergeIntoStore?: boolean) => Reference | undefined;

// @public (undocumented)
type Transaction<T> = (c: ApolloCache<T>) => void;

// @public (undocumented)
interface TransformCacheEntry {
    // (undocumented)
    asQuery: DocumentNode;
    // (undocumented)
    clientQuery: DocumentNode | null;
    // (undocumented)
    defaultVars: OperationVariables;
    // (undocumented)
    hasClientExports: boolean;
    // (undocumented)
    hasForcedResolvers: boolean;
    // (undocumented)
    hasNonreactiveDirective: boolean;
    // (undocumented)
    serverQuery: DocumentNode | null;
}

// @public (undocumented)
type TransformFn = (document: DocumentNode) => DocumentNode;

// @public (undocumented)
type TRelayEdge<TNode> = {
    cursor?: string;
    node: TNode;
} | (Reference & {
    cursor?: string;
});

// @public (undocumented)
type TRelayPageInfo = {
    hasPreviousPage: boolean;
    hasNextPage: boolean;
    startCursor: string;
    endCursor: string;
};

// @public (undocumented)
export type TupleToIntersection<T extends any[]> = T extends [infer A] ? A : T extends [infer A, infer B] ? A & B : T extends [infer A, infer B, infer C] ? A & B & C : T extends [infer A, infer B, infer C, infer D] ? A & B & C & D : T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E : T extends (infer U)[] ? U : any;

// @public (undocumented)
type TypePolicies = {
    [__typename: string]: TypePolicy;
};

// @public (undocumented)
type TypePolicy = {
    keyFields?: KeySpecifier | KeyFieldsFunction | false;
    merge?: FieldMergeFunction | boolean;
    queryType?: true;
    mutationType?: true;
    subscriptionType?: true;
    fields?: {
        [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;
    };
};

// @public (undocumented)
type UnionForAny<T> = T extends never ? "a" : 1;

// @public (undocumented)
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

// @public (undocumented)
type UpdateQueries<TData> = MutationOptions<TData, any, any>["updateQueries"];

// @public (undocumented)
type UpdateQueryFn<TData = any, TSubscriptionVariables = OperationVariables, TSubscriptionData = TData> = (previousQueryResult: TData, options: {
    subscriptionData: {
        data: TSubscriptionData;
    };
    variables?: TSubscriptionVariables;
}) => TData;

// @public (undocumented)
interface UriFunction {
    // (undocumented)
    (operation: Operation): string;
}

// @public (undocumented)
export function valueToObjectRepresentation(argObj: any, name: NameNode, value: ValueNode, variables?: Object): void;

// @public (undocumented)
export type VariableValue = (node: VariableNode) => any;

// @public
interface WatchFragmentOptions<TData, TVars> {
    fragment: DocumentNode | TypedDocumentNode<TData, TVars>;
    fragmentName?: string;
    from: StoreObject | Reference | string;
    optimistic?: boolean;
    variables?: TVars;
}

// @public
type WatchFragmentResult<TData> = {
    data: TData;
    complete: true;
    missing?: never;
} | {
    data: DeepPartial<TData>;
    complete: false;
    missing: MissingTree;
};

// @public (undocumented)
type WatchQueryFetchPolicy = FetchPolicy | "cache-and-network";

// Warning: (ae-forgotten-export) The symbol "SharedWatchQueryOptions" needs to be exported by the entry point index.d.ts
//
// @public
interface WatchQueryOptions<TVariables extends OperationVariables = OperationVariables, TData = any> extends SharedWatchQueryOptions<TVariables, TData> {
    query: DocumentNode | TypedDocumentNode<TData, TVariables>;
}

// @public (undocumented)
export function wrapPromiseWithState<TValue>(promise: Promise<TValue>): PromiseWithState<TValue>;

// @public (undocumented)
interface WriteContext extends ReadMergeModifyContext {
    // (undocumented)
    clientOnly: boolean;
    // (undocumented)
    deferred: boolean;
    // Warning: (ae-forgotten-export) The symbol "FlavorableWriteContext" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    flavors: Map<string, FlavorableWriteContext>;
    // (undocumented)
    readonly fragmentMap: FragmentMap;
    // (undocumented)
    incomingById: Map<string, {
        storeObject: StoreObject;
        mergeTree?: MergeTree;
        fieldNodeSet: Set<FieldNode>;
    }>;
    // (undocumented)
    lookupFragment: FragmentMapFunction;
    // (undocumented)
    merge<T>(existing: T, incoming: T): T;
    // (undocumented)
    overwrite: boolean;
    // (undocumented)
    readonly written: {
        [dataId: string]: SelectionSetNode[];
    };
}

// Warnings were encountered during analysis:
//
// src/cache/core/types/DataProxy.ts:146:7 - (ae-forgotten-export) The symbol "MissingFieldError" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:57:3 - (ae-forgotten-export) The symbol "TypePolicy" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:161:3 - (ae-forgotten-export) The symbol "KeySpecifier" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:161:3 - (ae-forgotten-export) The symbol "KeyArgsFunction" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:162:3 - (ae-forgotten-export) The symbol "FieldReadFunction" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:163:3 - (ae-forgotten-export) The symbol "FieldMergeFunction" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/types.ts:139:3 - (ae-forgotten-export) The symbol "KeyFieldsFunction" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/writeToStore.ts:65:7 - (ae-forgotten-export) The symbol "MergeTree" needs to be exported by the entry point index.d.ts
// src/core/LocalState.ts:71:3 - (ae-forgotten-export) The symbol "ApolloClient" needs to be exported by the entry point index.d.ts
// src/core/ObservableQuery.ts:116:5 - (ae-forgotten-export) The symbol "QueryManager" needs to be exported by the entry point index.d.ts
// src/core/ObservableQuery.ts:117:5 - (ae-forgotten-export) The symbol "QueryInfo" needs to be exported by the entry point index.d.ts
// src/core/QueryManager.ts:138:5 - (ae-forgotten-export) The symbol "MutationStoreValue" needs to be exported by the entry point index.d.ts
// src/core/QueryManager.ts:382:7 - (ae-forgotten-export) The symbol "UpdateQueries" needs to be exported by the entry point index.d.ts
// src/core/types.ts:174:3 - (ae-forgotten-export) The symbol "MutationQueryReducer" needs to be exported by the entry point index.d.ts
// src/core/types.ts:203:5 - (ae-forgotten-export) The symbol "Resolver" needs to be exported by the entry point index.d.ts
// src/core/watchQueryOptions.ts:275:2 - (ae-forgotten-export) The symbol "UpdateQueryFn" needs to be exported by the entry point index.d.ts
// src/utilities/graphql/storeUtils.ts:226:12 - (ae-forgotten-export) The symbol "storeKeyNameStringify" needs to be exported by the entry point index.d.ts
// src/utilities/policies/pagination.ts:76:3 - (ae-forgotten-export) The symbol "TRelayEdge" needs to be exported by the entry point index.d.ts
// src/utilities/policies/pagination.ts:77:3 - (ae-forgotten-export) The symbol "TRelayPageInfo" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
