---
title: Hooks
description: Apollo Client react hooks API reference
minVersion: 3.0.0
api_doc:
  - "@apollo/client!SuspenseQueryHookOptions:interface"
  - "@apollo/client!useQuery:function(1)"
  - "@apollo/client!useLazyQuery:function(1)"
  - "@apollo/client!useMutation:function(1)"
  - "@apollo/client!useSubscription:function(1)"
  - "@apollo/client!useApolloClient:function(1)"
  - "@apollo/client!useReactiveVar:function(1)"
---

import UseFragmentOptions from '../../../shared/useFragment-options.mdx';
import UseFragmentResult from '../../../shared/useFragment-result.mdx';
import UseBackgroundQueryOptions from '../../../shared/useBackgroundQuery-options.mdx';
import UseSuspenseQueryResult from '../../../shared/useSuspenseQuery-result.mdx';
import UseBackgroundQueryResult from '../../../shared/useBackgroundQuery-result.mdx';
import UseReadQueryResult from '../../../shared/useReadQuery-result.mdx';
import { FunctionDetails, PropertySignatureTable, ManualTuple, InterfaceDetails } from '../../../shared/ApiDoc';

## The `ApolloProvider` component

The `ApolloProvider` component leverages [React's Context API](https://react.dev/reference/react/useContext) to make a configured Apollo Client instance available throughout a React component tree. This component can be imported directly from the `@apollo/client` package.

```js
import { ApolloProvider } from '@apollo/client';
```

### Props

| Option   | Type                       | Description                 |
| -------- | -------------------------- | --------------------------- |
| `client` | ApolloClient&lt;TCache&gt; | An `ApolloClient` instance. |

### Example

```jsx {7-9}
const client = new ApolloClient({
  cache: new InMemoryCache(),
  uri: "http://localhost:4000/graphql"
});

ReactDOM.render(
  <ApolloProvider client={client}>
    <MyRootComponent />
  </ApolloProvider>,
  document.getElementById('root'),
);
```

## The `ApolloConsumer` component

One way to access the configured Apollo Client instance directly is to create an `ApolloConsumer` component and provide a render prop function as its child. The render prop function will be called with your `ApolloClient` instance as its only argument. You can think of the `ApolloConsumer` component as similar to the `Consumer` component from the [React Context API](https://react.dev/reference/react/useContext).

### Example

```jsx
import { ApolloConsumer } from '@apollo/client';

function WithApolloClient() {
  return (
    <ApolloConsumer>
      {client => 'We have access to the client!' /* do stuff here */}
    </ApolloConsumer>
  );
}
```

<FunctionDetails canonicalReference="@apollo/client!useQuery:function(1)" headingLevel={2} />

<FunctionDetails canonicalReference="@apollo/client!useLazyQuery:function(1)" headingLevel={2}
result={<div>
<pre><code class="language-ts">
[execute: LazyQueryExecFunction&lt;TData, TVariables&gt;, result: QueryResult&lt;TData, TVariables&gt;]
</code></pre>

A tuple of two values:

<ManualTuple idPrefix="uselazyquery-result" elements={[
  {
    name: "execute",
    type: "(options?: LazyQueryHookOptions<TVariables>) => Promise<LazyQueryResult<TData, TVariables>>",
    description: "Function that can be triggered to execute the suspended query. After being called, `useLazyQuery` behaves just like `useQuery`. The `useLazyQuery` function returns a promise that fulfills with a query result when the query succeeds or fails."
  },
  {
    name: "result",
    type: "QueryResult<TData, TVariables>",
    description: "The result of the query. See the `useQuery` hook for more details.",
    canonicalReference: "@apollo/client!QueryResult:interface"
  }
]}/>
</div>}
/>

<FunctionDetails
  canonicalReference="@apollo/client!useMutation:function(1)"
  headingLevel={2}
  result={
    <div>
      <pre>
        <code class="language-ts">
        {`[
  mutate: (options?: MutationFunctionOptions<TData, TVariables>) => Promise<FetchResult<TData>>,
  result: MutationResult<TData>
]`}
        </code>
      </pre>
      A tuple of two values:
      <ManualTuple
        idPrefix="usemutation-result"
        elements={[
          {
            name: "mutate",
            type: `(
    options?: MutationFunctionOptions<TData, TVariables>
  ) => Promise<FetchResult<TData>>`,
            description: <div>
A function to trigger the mutation from your UI. You can optionally pass this function any of the following options:

<ul>
<li><code>awaitRefetchQueries</code></li>
<li><code>context</code></li>
<li><code>fetchPolicy</code></li>
<li><code>onCompleted</code></li>
<li><code>onError</code></li>
<li><code>optimisticResponse</code></li>
<li><code>refetchQueries</code></li>
<li><code>onQueryUpdated</code></li>
<li><code>update</code></li>
<li><code>variables</code></li>
<li><code>client</code></li>
</ul>

Any option you pass here overrides any existing value for that option that you passed to <code>useMutation</code>.

The mutate function returns a promise that fulfills with your mutation result.
</div>,
          },
          {
            name: "result",
            type: "MutationResult<TData>",
            description: "The result of the mutation.",
            canonicalReference: "@apollo/client!MutationResult:interface",
          },
        ]}
      />
    </div>
  }
/>

<FunctionDetails canonicalReference="@apollo/client!useSubscription:function(1)" headingLevel={2} />

<FunctionDetails canonicalReference="@apollo/client!useApolloClient:function(1)" headingLevel={2} />

<FunctionDetails canonicalReference="@apollo/client!useReactiveVar:function(1)" headingLevel={2} />

<MinVersion version="3.8.0">

## `useFragment`

</MinVersion>

`useFragment` represents a lightweight live binding into the Apollo Client Cache and enables Apollo Client to broadcast very specific fragment results to individual components. This hook returns an always-up-to-date view of whatever data the cache currently contains for a given fragment. `useFragment` never triggers network requests of its own.

Note that the `useQuery` hook remains the primary hook responsible for querying and populating data in the cache ([see the API reference](./hooks#usequery)). As a result, the component reading the fragment data via `useFragment` is still subscribed to all changes in the query data, but receives updates only when that fragment's specific data change.

> **Note**: this hook was introduced in `3.7.0` as experimental but stabilized in `3.8.0`. In `3.7.x` and `3.8.0-alpha.x` releases, this hook is exported as `useFragment_experimental`. Starting with `3.8.0-beta.0` and greater the `_experimental` suffix was removed in its named export.

### Example

To view a `useFragment` example, see the [Fragments](../../data/fragments#usefragment) page.

### Function Signature

```ts
function useFragment<
  TData = any,
  TVars = OperationVariables
>({
  from: string | StoreObject | Reference;
  fragment: DocumentNode | TypedDocumentNode<TData, TVars>;
  fragmentName?: string;
  optimistic?: boolean;
  variables?: TVars;
  returnPartialData?: boolean;
}): UseFragmentResult<TData> {}
```

### Params

#### `options`

<UseFragmentOptions />

### Result

<UseFragmentResult />

<MinVersion version="3.8.0">

## `useSuspenseQuery`

</MinVersion>

For a detailed explanation of `useSuspenseQuery`, see the [fetching with Suspense reference](../../data/suspense).

### Example

```jsx
import { Suspense } from 'react';
import { useSuspenseQuery } from '@apollo/client';

const listQuery = gql`
  query {
    list {
      id
    }
  }
`;

function App() {
  return (
    <Suspense fallback={<Spinner />}>
      <List />
    </Suspense>
  );
}

function List() {
  const { data } = useSuspenseQuery(listQuery);

  return (
    <ol>
      {data.list.map(item => <Item key={item.id} id={item.id}/>)}
    </ol>
  );
}

```

### Signature

```ts
function useSuspenseQuery<TData, TVariables>(
  query: DocumentNode,
  options?: SuspenseQueryHookOptions<TData, TVariables> | SkipToken,
): UseSuspenseQueryResult<TData, TVariables>
```

### Params

#### `query`

| Param   | Type         | Description                                                   |
| ------- | ------------ | ------------------------------------------------------------- |
| `query` | (Typed)DocumentNode | A GraphQL query document parsed into an AST by `gql`. |


#### `options`

Instead of passing a `SuspenseQueryHookOptions` object into the hook, you can also pass a [`skipToken`](#skiptoken) to prevent the `useSuspenseQuery` hook from executing the query or suspending.

<InterfaceDetails
  canonicalReference="@apollo/client!SuspenseQueryHookOptions:interface"
  customPropertyOrder={["variables", "errorPolicy", "skip"]}
  headingLevel={3}
/>

### Result

<UseSuspenseQueryResult />

<MinVersion version="3.8.0">

## `useBackgroundQuery`

</MinVersion>

For a detailed explanation of `useBackgroundQuery`, see the [fetching with Suspense reference](../../data/suspense#avoiding-request-waterfalls).

### Example

```jsx
import { Suspense } from 'react';
import {
  ApolloClient,
  InMemoryCache,
  useBackgroundQuery,
  useReadQuery,
} from '@apollo/client';

const query = gql`
  foo {
    bar
  }
`;

const client = new ApolloClient({
  uri: "http://localhost:4000/graphql",
  cache: new InMemoryCache()
});

function SuspenseFallback() {
  return <div>Loading...</div>;
}

function Child({ queryRef }) {
  const { data } = useReadQuery(queryRef);

  return <div>{data.foo.bar}</div>;
}

function Parent() {
  const [queryRef] = useBackgroundQuery(query);

  return (
    <Suspense fallback={<SuspenseFallback />}>
      <Child queryRef={queryRef} />
    </Suspense>
  );
}

function App() {
  return (
    <ApolloProvider client={client}>
      <Parent />
    </ApolloProvider>
  );
}
```

### Signature

```ts
function useBackgroundQuery<TData, TVariables>(
  query: DocumentNode | TypedDocumentNode<TData, TVariables>,
  options: BackgroundQueryHookOptions<TData, TVariables> | SkipToken,
): [
  // Will return `undefined` here if no query has been executed yet and the query
  // is currently skipped using `skipToken` or { skip: true }
  QueryReference<TData> | undefined,
  {
    fetchMore: FetchMoreFunction<TData, TVariables>;
    refetch: RefetchFunction<TData, TVariables>;
  }
]
```

### Params

#### `query`

| Param   | Type         | Description                                                   |
| ------- | ------------ | ------------------------------------------------------------- |
| `query` | (Typed)DocumentNode | A GraphQL query document parsed into an AST by `gql`. |


#### `options`

Instead of passing a `BackgroundQueryHookOptions` object into the hook, you can also pass a [`skipToken`](#skiptoken) to prevent the `useBackgroundQuery` hook from executing the query.

If no query has been executed yet and you skip the query, the hook will return `undefined` instead of a `queryRef`.

<UseBackgroundQueryOptions />

### Result

<UseBackgroundQueryResult />

<MinVersion version="3.8.0">

## `useReadQuery`

</MinVersion>

For a detailed explanation of `useReadQuery`, see the [fetching with Suspense reference](../../data/suspense#avoiding-request-waterfalls).

### Example

See the [example](#example-10) in the `useBackgroundQuery` section above.

### Signature

```ts
function useReadQuery<TData>(
  queryRef: QueryReference<TData>
): {
  data: TData;
  networkStatus: NetworkStatus;
  error: ApolloError | undefined;
} {}
```

### Params

#### `queryRef`

| Param   | Type         | Description                                                   |
| ------- | ------------ | ------------------------------------------------------------- |
| `queryRef` | QueryReference | The [`queryRef`](#queryref) that was generated via `useBackgroundQuery`. |

### Result

<UseReadQueryResult />

<MinVersion version="3.8.0">

## `skipToken`

</MinVersion>

While not a hook by itself, `skipToken` is designed to be used with `useSuspenseQuery` and `useBackgroundQuery`.
If a `skipToken` is passed into one of those hooks instead of the `options` object, that hook will not cause any requests or suspenseful behavior, while keeping the last `data` available.

```js title="Recommended usage of skipToken with useSuspenseQuery"
import { skipToken, useSuspenseQuery } from '@apollo/client';
const { data } = useSuspenseQuery(
  query,
  id ? { variables: { id } } : skipToken
);
```


```js title="Recommended usage of skipToken with useBackgroundQuery"
import { skipToken, useBackgroundQuery } from '@apollo/client';
const [queryRef] = useBackgroundQuery(
  query,
  id ? { variables: { id } } : skipToken
);
```

<blockquote>

Note: **Why do we recommend `skipToken` over `{ skip: true }`?**

Imagine this very common scenario for `skip`: You want to skip your query if a certain variable is not set. You might be tempted to write something like this:

```ts
const { data } = useSuspenseQuery(query, {
  variables: { id },
  skip: !id
});
```
But in that case, TypeScript will complain:
```
Type 'number | undefined' is not assignable to type 'number'.
      Type 'undefined' is not assignable to type 'number'.ts(2769)
```

To get around that, you have to tell TypeScript to ignore the fact that `id` could be `undefined`:
```ts
const { data } = useSuspenseQuery(query, {
  variables: { id: id! },
  skip: !id
});
```
Alternatively, you could also use some obscure default value:
```ts
const { data } = useSuspenseQuery(query, {
  variables: { id: id || 0 },
  skip: !id
});
```

What both of these solutions have in common: They hide a potential bug. If your `skip` logic becomes more complex in the future, you might accidentally introduce a bug that causes your query not to be skipped, even though `id` is still `undefined` - and TypeScript won't be able to warn you about it.

So instead, we recommend using `skipToken`, as that will work without a lie to the compiler or an obscure default value:

```ts
const { data } = useSuspenseQuery(
  query,
  id ? { variables: { id } } : skipToken
);
```
In this case, it becomes apparent for TypeScript that there is a direct connection between skipping and the `variables` option - and it will work without unsafe workarounds.

</blockquote>
