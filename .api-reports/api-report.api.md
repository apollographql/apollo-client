## API Report File for "@apollo/client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { ASTNode } from 'graphql';
import { disableExperimentalFragmentVariables } from 'graphql-tag';
import { disableFragmentWarnings } from 'graphql-tag';
import { DocumentNode } from 'graphql';
import { enableExperimentalFragmentVariables } from 'graphql-tag';
import type { FieldNode } from 'graphql';
import type { FormattedExecutionResult } from 'graphql';
import type { FragmentDefinitionNode } from 'graphql';
import { gql } from 'graphql-tag';
import type { GraphQLFormattedError } from 'graphql';
import type { InlineFragmentNode } from 'graphql';
import type { InteropObservable } from 'rxjs';
import type { NextNotification } from 'rxjs';
import { Observable } from 'rxjs';
import type { ObservableNotification } from 'rxjs';
import type { Observer } from 'rxjs';
import { OperationTypeNode } from 'graphql';
import type { print as print_2 } from 'graphql';
import { resetCaches } from 'graphql-tag';
import type { SelectionSetNode } from 'graphql';
import type { Subscribable } from 'rxjs';
import type { Subscription } from 'rxjs';
import { Trie } from '@wry/trie';
import { TypedDocumentNode } from '@graphql-typed-document-node/core';

// Warning: (ae-forgotten-export) The symbol "Modifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "StoreObjectValueMaybeReference" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<Entity[keyof Entity] extends infer Value ? StoreObjectValueMaybeReference<Exclude<Value, undefined>> : never>;

// @public (undocumented)
export namespace ApolloCache {
    export interface WatchFragmentOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        // Warning: (ae-forgotten-export) The symbol "NoInfer_2" needs to be exported by the entry point index.d.ts
        from: StoreObject | Reference | FragmentType<NoInfer_2<TData>> | string;
        optimistic?: boolean;
        variables?: TVariables;
    }
    export type WatchFragmentResult<TData = unknown> = ({
        complete: true;
        missing?: never;
    } & GetDataState<TData, "complete">) | ({
        complete: false;
        missing: MissingTree;
    } & GetDataState<TData, "partial">);
}

// @public (undocumented)
export abstract class ApolloCache {
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    batch<U>(options: Cache_2.BatchOptions<this, U>): U;
    abstract diff<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: Cache_2.DiffOptions<TData, TVariables>): Cache_2.DiffResult<TData>;
    // (undocumented)
    abstract evict(options: Cache_2.EvictOptions): boolean;
    abstract extract(optimistic?: boolean): unknown;
    // (undocumented)
    abstract fragmentMatches(fragment: InlineFragmentNode | FragmentDefinitionNode, typename: string): boolean;
    // (undocumented)
    gc(): string[];
    // Warning: (ae-forgotten-export) The symbol "getApolloCacheMemoryInternals" needs to be exported by the entry point index.d.ts
    //
    // @internal @deprecated
    getMemoryInternals?: typeof getApolloCacheMemoryInternals;
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // (undocumented)
    lookupFragment(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_2.ModifyOptions<Entity>): boolean;
    // (undocumented)
    abstract performTransaction(transaction: Transaction, optimisticId?: string | null): void;
    // (undocumented)
    abstract read<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: Cache_2.ReadOptions<TData, TVariables>): Unmasked<TData> | null;
    readFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>({ fragment, variables, fragmentName, id, optimistic, returnPartialData, }: Cache_2.ReadFragmentOptions<TData, TVariables>): Unmasked<TData> | null;
    // (undocumented)
    readFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: Cache_2.ReadFragmentOptions<TData, TVariables>,
    optimistic: boolean): Unmasked<TData> | null;
    readQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>({ query, variables, id, optimistic, returnPartialData, }: Cache_2.ReadQueryOptions<TData, TVariables>): Unmasked<TData> | null;
    readQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: Cache_2.ReadQueryOptions<TData, TVariables>,
    optimistic: boolean): Unmasked<TData> | null;
    // (undocumented)
    recordOptimisticTransaction(transaction: Transaction, optimisticId: string): void;
    // (undocumented)
    abstract removeOptimistic(id: string): void;
    // (undocumented)
    abstract reset(options?: Cache_2.ResetOptions): Promise<void>;
    abstract restore(serializedState: unknown): this;
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
    // (undocumented)
    transformForLink(document: DocumentNode): DocumentNode;
    // (undocumented)
    updateFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: Cache_2.UpdateFragmentOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    updateQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: Cache_2.UpdateQueryOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    abstract watch<TData = unknown, TVariables extends OperationVariables = OperationVariables>(watch: Cache_2.WatchOptions<TData, TVariables>): () => void;
    watchFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloCache.WatchFragmentOptions<TData, TVariables>): Observable<ApolloCache.WatchFragmentResult<Unmasked<TData>>>;
    // (undocumented)
    abstract write<TData = unknown, TVariables extends OperationVariables = OperationVariables>(write: Cache_2.WriteOptions<TData, TVariables>): Reference | undefined;
    writeFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>({ data, fragment, fragmentName, variables, overwrite, id, broadcast, }: Cache_2.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    writeQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>({ data, query, variables, overwrite, id, broadcast, }: Cache_2.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public (undocumented)
export namespace ApolloClient {
    // (undocumented)
    export namespace Base {
        // (undocumented)
        export interface ReadQueryOptions<TData, TVariables extends OperationVariables> {
            id?: string;
            optimistic?: boolean;
            query: DocumentNode | TypedDocumentNode<TData, TVariables>;
            returnPartialData?: boolean;
        }
    }
    // (undocumented)
    export namespace Base {
        // (undocumented)
        export interface ReadFragmentOptions<TData, TVariables extends OperationVariables> {
            fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
            fragmentName?: string;
            id?: string;
            optimistic?: boolean;
            returnPartialData?: boolean;
        }
    }
    // (undocumented)
    export namespace Base {
        // (undocumented)
        export interface WriteQueryOptions<TData, TVariables extends OperationVariables> {
            broadcast?: boolean;
            data: Unmasked<TData>;
            id?: string;
            overwrite?: boolean;
            query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        }
    }
    // (undocumented)
    export namespace Base {
        // (undocumented)
        export interface WriteFragmentOptions<TData, TVariables extends OperationVariables> {
            broadcast?: boolean;
            data: Unmasked<TData>;
            fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
            fragmentName?: string;
            id?: string;
            overwrite?: boolean;
        }
    }
    // (undocumented)
    export interface DefaultOptions {
        // (undocumented)
        mutate?: Partial<ApolloClient.MutateOptions<any, any, any>>;
        // (undocumented)
        query?: Partial<ApolloClient.QueryOptions<any, any>>;
        // (undocumented)
        watchQuery?: Partial<ApolloClient.WatchQueryOptions<any, any>>;
    }
    // (undocumented)
    export interface DevtoolsOptions {
        enabled?: boolean;
        name?: string;
    }
    // (undocumented)
    export namespace DocumentationTypes {
        // (undocumented)
        export interface ReadQueryOptions<TData, TVariables extends OperationVariables> extends Base.ReadQueryOptions<TData, TVariables> {
            variables?: TVariables;
        }
    }
    // (undocumented)
    export namespace DocumentationTypes {
        // (undocumented)
        export interface WriteQueryOptions<TData, TVariables extends OperationVariables> extends Base.WriteQueryOptions<TData, TVariables> {
            variables?: TVariables;
        }
    }
    // (undocumented)
    export namespace DocumentationTypes {
        // (undocumented)
        export interface WriteQueryOptions<TData, TVariables extends OperationVariables> extends Base.WriteQueryOptions<TData, TVariables> {
            variables?: TVariables;
        }
    }
    // (undocumented)
    export namespace DocumentationTypes {
        // (undocumented)
        export interface WriteFragmentOptions<TData, TVariables extends OperationVariables> extends Base.WriteFragmentOptions<TData, TVariables> {
            variables?: TVariables;
        }
    }
    // Warning: (ae-forgotten-export) The symbol "VariablesOption" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export type MutateOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables, TCache extends ApolloCache = ApolloCache> = {
        optimisticResponse?: Unmasked<NoInfer<TData>> | ((vars: TVariables, { IGNORE }: {
            IGNORE: IgnoreModifier;
        }) => Unmasked<NoInfer<TData>> | IgnoreModifier);
        updateQueries?: MutationQueryReducersMap<TData>;
        refetchQueries?: ((result: NormalizedExecutionResult<Unmasked<TData>>) => InternalRefetchQueriesInclude) | InternalRefetchQueriesInclude;
        awaitRefetchQueries?: boolean;
        update?: MutationUpdaterFunction<TData, TVariables, TCache>;
        onQueryUpdated?: OnQueryUpdated<any>;
        errorPolicy?: ErrorPolicy;
        context?: DefaultContext;
        fetchPolicy?: MutationFetchPolicy;
        keepRootFields?: boolean;
        mutation: DocumentNode | TypedDocumentNode<TData, TVariables>;
    } & VariablesOption<NoInfer<TVariables>>;
    // (undocumented)
    export interface MutateResult<TData = unknown> {
        data: TData | undefined;
        error?: ErrorLike;
        extensions?: Record<string, unknown>;
    }
    // (undocumented)
    export interface Options {
        assumeImmutableResults?: boolean;
        cache: ApolloCache;
        // Warning: (ae-forgotten-export) The symbol "ClientAwarenessLink" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        clientAwareness?: ClientAwarenessLink.ClientAwarenessOptions;
        dataMasking?: boolean;
        // (undocumented)
        defaultContext?: Partial<DefaultContext>;
        defaultOptions?: ApolloClient.DefaultOptions;
        devtools?: ApolloClient.DevtoolsOptions;
        // (undocumented)
        documentTransform?: DocumentTransform;
        // (undocumented)
        enhancedClientAwareness?: ClientAwarenessLink.EnhancedClientAwarenessOptions;
        // Warning: (ae-forgotten-export) The symbol "Incremental" needs to be exported by the entry point index.d.ts
        incrementalHandler?: Incremental.Handler<any>;
        link: ApolloLink;
        // Warning: (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        localState?: LocalState;
        queryDeduplication?: boolean;
        ssrForceFetchDelay?: number;
        ssrMode?: boolean;
    }
    export type QueryOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = {
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        errorPolicy?: ErrorPolicy;
        context?: DefaultContext;
        fetchPolicy?: FetchPolicy;
    } & VariablesOption<NoInfer<TVariables>>;
    // (undocumented)
    export interface QueryResult<TData = unknown> {
        data: TData | undefined;
        error?: ErrorLike;
    }
    // (undocumented)
    export type ReadFragmentOptions<TData, TVariables extends OperationVariables> = Base.ReadFragmentOptions<TData, TVariables> & VariablesOption<TVariables>;
    // (undocumented)
    export type ReadQueryOptions<TData, TVariables extends OperationVariables> = Base.ReadQueryOptions<TData, TVariables> & VariablesOption<TVariables>;
    export interface RefetchQueriesOptions<TCache extends ApolloCache, TResult> {
        include?: RefetchQueriesInclude;
        onQueryUpdated?: OnQueryUpdated<TResult> | null;
        optimistic?: boolean;
        updateCache?: (cache: TCache) => void;
    }
    export interface RefetchQueriesResult<TResult> extends Promise<RefetchQueriesPromiseResults<TResult>>, RefetchQueriesResult.AdditionalProperties<TResult> {
    }
    // (undocumented)
    export namespace RefetchQueriesResult {
        // (undocumented)
        export interface AdditionalProperties<TResult> {
            queries: ObservableQuery<any>[];
            results: InternalRefetchQueriesResult<TResult>[];
        }
    }
    // (undocumented)
    export type SubscribeOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = {
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fetchPolicy?: FetchPolicy;
        errorPolicy?: ErrorPolicy;
        context?: DefaultContext;
        extensions?: Record<string, any>;
    } & VariablesOption<NoInfer<TVariables>>;
    // (undocumented)
    export interface SubscribeResult<TData = unknown> {
        data: TData | undefined;
        error?: ErrorLike;
        extensions?: Record<string, unknown>;
    }
    // (undocumented)
    export type WatchFragmentOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = ApolloCache.WatchFragmentOptions<TData, TVariables>;
    // (undocumented)
    export type WatchFragmentResult<TData = unknown> = ApolloCache.WatchFragmentResult<TData>;
    export type WatchQueryOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = {
        fetchPolicy?: WatchQueryFetchPolicy;
        nextFetchPolicy?: WatchQueryFetchPolicy | ((this: WatchQueryOptions<TData, TVariables>, currentFetchPolicy: WatchQueryFetchPolicy, context: NextFetchPolicyContext<TData, TVariables>) => WatchQueryFetchPolicy);
        initialFetchPolicy?: WatchQueryFetchPolicy;
        refetchWritePolicy?: RefetchWritePolicy;
        errorPolicy?: ErrorPolicy;
        context?: DefaultContext;
        pollInterval?: number;
        notifyOnNetworkStatusChange?: boolean;
        returnPartialData?: boolean;
        skipPollAttempt?: () => boolean;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        [variablesUnknownSymbol]?: boolean;
    } & VariablesOption<NoInfer<TVariables>>;
    // (undocumented)
    export type WriteFragmentOptions<TData, TVariables extends OperationVariables> = Base.WriteFragmentOptions<TData, TVariables> & VariablesOption<TVariables>;
    // (undocumented)
    export type WriteQueryOptions<TData, TVariables extends OperationVariables> = Base.WriteQueryOptions<TData, TVariables> & VariablesOption<TVariables>;
}

// @public
export class ApolloClient {
    // (undocumented)
    __actionHookForDevTools(cb: () => any): void;
    constructor(options: ApolloClient.Options);
    // (undocumented)
    __requestRaw(request: ApolloLink.Request): Observable<ApolloLink.Result<unknown>>;
    // (undocumented)
    cache: ApolloCache;
    clearStore(): Promise<any[]>;
    // (undocumented)
    get defaultContext(): Partial<DefaultContext>;
    // (undocumented)
    defaultOptions: ApolloClient.DefaultOptions;
    // (undocumented)
    readonly devtoolsConfig: ApolloClient.DevtoolsOptions;
    // @deprecated (undocumented)
    disableNetworkFetches: never;
    get documentTransform(): DocumentTransform;
    extract(optimistic?: boolean): unknown;
    // Warning: (ae-forgotten-export) The symbol "getApolloClientMemoryInternals" needs to be exported by the entry point index.d.ts
    getMemoryInternals?: typeof getApolloClientMemoryInternals;
    getObservableQueries(include?: RefetchQueriesInclude): Set<ObservableQuery<any>>;
    // (undocumented)
    link: ApolloLink;
    get localState(): LocalState | undefined;
    set localState(localState: LocalState);
    mutate<TData = unknown, TVariables extends OperationVariables = OperationVariables, TCache extends ApolloCache = ApolloCache>(options: ApolloClient.MutateOptions<TData, TVariables, TCache>): Promise<ApolloClient.MutateResult<MaybeMasked<TData>>>;
    onClearStore(cb: () => Promise<any>): () => void;
    onResetStore(cb: () => Promise<any>): () => void;
    set prioritizeCacheValues(value: boolean);
    get prioritizeCacheValues(): boolean;
    query<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.QueryOptions<TData, TVariables>): Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    queryDeduplication: boolean;
    readFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.ReadFragmentOptions<TData, TVariables>): Unmasked<TData> | null;
    // @deprecated
    readFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.ReadFragmentOptions<TData, TVariables>, optimistic: boolean): Unmasked<TData> | null;
    readQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.ReadQueryOptions<TData, TVariables>): Unmasked<TData> | null;
    // @deprecated
    readQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.ReadQueryOptions<TData, TVariables>,
    optimistic: boolean): Unmasked<TData> | null;
    // @deprecated
    reFetchObservableQueries: (includeStandby?: boolean) => Promise<ApolloClient.QueryResult<any>[]>;
    refetchObservableQueries(includeStandby?: boolean): Promise<ApolloClient.QueryResult<any>[]>;
    refetchQueries<TCache extends ApolloCache = ApolloCache, TResult = Promise<ApolloClient.QueryResult<any>>>(options: ApolloClient.RefetchQueriesOptions<TCache, TResult>): ApolloClient.RefetchQueriesResult<TResult>;
    resetStore(): Promise<ApolloClient.QueryResult<any>[] | null>;
    restore(serializedState: unknown): ApolloCache;
    setLink(newLink: ApolloLink): void;
    stop(): void;
    subscribe<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.SubscribeOptions<TData, TVariables>): SubscriptionObservable<ApolloClient.SubscribeResult<MaybeMasked<TData>>>;
    // (undocumented)
    version: string;
    watchFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.WatchFragmentOptions<TData, TVariables>): Observable<ApolloClient.WatchFragmentResult<MaybeMasked<TData>>>;
    watchQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.WatchQueryOptions<TData, TVariables>): ObservableQuery<TData, TVariables>;
    writeFragment<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    writeQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public @deprecated (undocumented)
export type ApolloClientOptions = ApolloClient.Options;

// @public (undocumented)
export namespace ApolloLink {
    // Warning: (ae-forgotten-export) The symbol "ApplyHKTImplementationWithDefault" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "NotImplementedHandler" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export type AdditionalResultTypes<TData = Record<string, any>, TExtensions = Record<string, any>> = ApplyHKTImplementationWithDefault<TypeOverrides, "AdditionalApolloLinkResultTypes", NotImplementedHandler.TypeOverrides, TData, TExtensions>;
    // (undocumented)
    export namespace DocumentationTypes {
        export function ForwardFunction(operation: ApolloLink.Operation): Observable<ApolloLink.Result>;
        export function RequestHandler(operation: ApolloLink.Operation, forward: ApolloLink.ForwardFunction): Observable<ApolloLink.Result>;
    }
    export interface ExecuteContext {
        client: ApolloClient;
    }
    export type ForwardFunction = (operation: ApolloLink.Operation) => Observable<ApolloLink.Result>;
    export interface Operation {
        readonly client: ApolloClient;
        extensions: Record<string, any>;
        getContext: () => Readonly<ApolloLink.OperationContext>;
        operationName: string | undefined;
        operationType: OperationTypeNode;
        query: DocumentNode;
        setContext: {
            (context: Partial<ApolloLink.OperationContext>): void;
            (updateContext: (previousContext: Readonly<ApolloLink.OperationContext>) => Partial<ApolloLink.OperationContext>): void;
        };
        variables: OperationVariables;
    }
    export interface OperationContext extends DefaultContext {
    }
    export interface Request {
        context?: DefaultContext;
        extensions?: Record<string, any>;
        query: DocumentNode;
        variables?: OperationVariables;
    }
    export type RequestHandler = (operation: ApolloLink.Operation, forward: ApolloLink.ForwardFunction) => Observable<ApolloLink.Result>;
    // (undocumented)
    export type Result<TData = Record<string, any>, TExtensions = Record<string, any>> = FormattedExecutionResult<TData, TExtensions> | AdditionalResultTypes<TData, TExtensions>;
}

// @public
export class ApolloLink {
    constructor(request?: ApolloLink.RequestHandler);
    // @deprecated
    static concat(...links: ApolloLink[]): ApolloLink;
    concat(...links: ApolloLink[]): ApolloLink;
    static empty(): ApolloLink;
    static execute(link: ApolloLink, request: ApolloLink.Request, context: ApolloLink.ExecuteContext): Observable<ApolloLink.Result>;
    static from(links: ApolloLink[]): ApolloLink;
    // @internal @deprecated
    getMemoryInternals?: () => unknown;
    // @internal @deprecated
    readonly left?: ApolloLink;
    request(operation: ApolloLink.Operation, forward: ApolloLink.ForwardFunction): Observable<ApolloLink.Result>;
    // @internal @deprecated
    readonly right?: ApolloLink;
    static split(test: (op: ApolloLink.Operation) => boolean, left: ApolloLink, right?: ApolloLink): ApolloLink;
    split(test: (op: ApolloLink.Operation) => boolean, left: ApolloLink, right?: ApolloLink): ApolloLink;
}

// @public (undocumented)
export interface ApolloPayloadResult<TData = Record<string, any>, TExtensions = Record<string, any>> {
    // (undocumented)
    errors?: ReadonlyArray<GraphQLFormattedError>;
    // (undocumented)
    payload: FormattedExecutionResult<TData, TExtensions> | null;
}

// @public @deprecated (undocumented)
export type ApolloQueryResult<TData, TStates extends DataState<TData>["dataState"] = DataState<TData>["dataState"]> = ObservableQuery.Result<TData, TStates>;

// @public (undocumented)
export type ApolloReducerConfig = {
    dataIdFromObject?: KeyFieldsFunction;
};

// Warning: (ae-forgotten-export) The symbol "HKT" needs to be exported by the entry point index.d.ts
//
// @internal @deprecated (undocumented)
type ApplyHKT<fn extends HKT, arg1, arg2 = never, arg3 = never, arg4 = never> = (fn & {
    arg1: arg1;
    arg2: arg2;
    arg3: arg3;
    arg4: arg4;
})["return"];

// Warning: (ae-forgotten-export) The symbol "ApplyHKT" needs to be exported by the entry point index.d.ts
//
// @internal @deprecated (undocumented)
type ApplyHKTImplementationWithDefault<Implementation, Name extends string, DefaultImplementation extends Record<Name, HKT>, arg1, arg2 = never, arg3 = never, arg4 = never> = ApplyHKT<Implementation extends {
    [name in Name]: infer Implementation extends HKT;
} ? Implementation : DefaultImplementation[Name], arg1, arg2, arg3, arg4>;

// @public
type AsStoreObject<T extends {
    __typename?: string;
}> = {
    [K in keyof T]: T[K];
};

// @public (undocumented)
namespace BaseHttpLink {
    // (undocumented)
    interface Body {
        // (undocumented)
        extensions?: Record<string, any>;
        // (undocumented)
        operationName?: string;
        // (undocumented)
        query?: string;
        // (undocumented)
        variables?: Record<string, any>;
    }
    interface ContextOptions {
        credentials?: RequestCredentials;
        fetchOptions?: RequestInit;
        headers?: Record<string, string>;
        http?: BaseHttpLink.HttpOptions;
        uri?: string | BaseHttpLink.UriFunction;
    }
    interface HttpOptions {
        accept?: string[];
        includeExtensions?: boolean;
        includeQuery?: boolean;
        preserveHeaderCase?: boolean;
    }
    // Warning: (ae-forgotten-export) The symbol "BaseHttpLink" needs to be exported by the entry point index.d.ts
    interface Options extends Shared.Options {
        useGETForQueries?: boolean;
    }
    // (undocumented)
    type Printer = (node: ASTNode, originalPrint: typeof print_2) => string;
    // (undocumented)
    namespace Shared {
        interface Options {
            credentials?: RequestCredentials;
            fetch?: typeof fetch;
            fetchOptions?: RequestInit;
            headers?: Record<string, string>;
            includeExtensions?: boolean;
            includeUnusedVariables?: boolean;
            preserveHeaderCase?: boolean;
            print?: BaseHttpLink.Printer;
            uri?: string | BaseHttpLink.UriFunction;
        }
    }
    // (undocumented)
    type UriFunction = (operation: ApolloLink.Operation) => string;
}

// @public
class BaseHttpLink extends ApolloLink {
    constructor(options?: BaseHttpLink.Options);
}

// @public (undocumented)
type BroadcastOptions = Pick<Cache_2.BatchOptions<InMemoryCache>, "optimistic" | "onWatchUpdated">;

// @public (undocumented)
export const build: "source" | "esm" | "cjs";

// @public (undocumented)
namespace Cache_2 {
    // (undocumented)
    interface BatchOptions<TCache extends ApolloCache, TUpdateResult = void> {
        onWatchUpdated?: (this: TCache, watch: Cache_2.WatchOptions, diff: Cache_2.DiffResult<any>, lastDiff?: Cache_2.DiffResult<any> | undefined) => any;
        optimistic?: string | boolean;
        removeOptimistic?: string;
        update(cache: TCache): TUpdateResult;
    }
    // (undocumented)
    interface DiffOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> extends Omit<ReadOptions<TData, TVariables>, "rootId"> {
    }
    // (undocumented)
    type DiffResult<TData> = {
        result: DataValue.Complete<TData>;
        complete: true;
        missing?: never;
        fromOptimisticTransaction?: boolean;
    } | {
        result: DataValue.Partial<TData> | null;
        complete: false;
        missing?: MissingFieldError;
        fromOptimisticTransaction?: boolean;
    };
    // (undocumented)
    interface EvictOptions {
        // (undocumented)
        args?: Record<string, any>;
        // (undocumented)
        broadcast?: boolean;
        // (undocumented)
        fieldName?: string;
        // (undocumented)
        id?: string;
    }
    // (undocumented)
    interface ModifyOptions<Entity extends Record<string, any> = Record<string, any>> {
        // (undocumented)
        broadcast?: boolean;
        // Warning: (ae-forgotten-export) The symbol "Modifiers" needs to be exported by the entry point index.d.ts
        // Warning: (ae-forgotten-export) The symbol "AllFieldsModifier" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        fields: Modifiers<Entity> | AllFieldsModifier<Entity>;
        // (undocumented)
        id?: string;
        // (undocumented)
        optimistic?: boolean;
    }
    // (undocumented)
    interface ReadFragmentOptions<TData, TVariables extends OperationVariables> {
        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        id?: string;
        optimistic?: boolean;
        returnPartialData?: boolean;
        variables?: TVariables;
    }
    // (undocumented)
    interface ReadOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
        id?: string;
        // (undocumented)
        optimistic: boolean;
        // (undocumented)
        previousResult?: any;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        // (undocumented)
        returnPartialData?: boolean;
        // (undocumented)
        rootId?: string;
        variables?: TVariables;
    }
    // (undocumented)
    interface ReadQueryOptions<TData, TVariables extends OperationVariables> {
        id?: string;
        optimistic?: boolean;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        returnPartialData?: boolean;
        variables?: TVariables;
    }
    // (undocumented)
    interface ResetOptions {
        // (undocumented)
        discardWatches?: boolean;
    }
    // (undocumented)
    interface UpdateFragmentOptions<TData, TVariables extends OperationVariables> extends Omit<ReadFragmentOptions<TData, TVariables> & WriteFragmentOptions<TData, TVariables>, "data"> {
    }
    // (undocumented)
    interface UpdateQueryOptions<TData, TVariables extends OperationVariables> extends Omit<ReadQueryOptions<TData, TVariables> & WriteQueryOptions<TData, TVariables>, "data"> {
    }
    // (undocumented)
    type WatchCallback<TData = unknown> = (diff: Cache_2.DiffResult<TData>, lastDiff?: Cache_2.DiffResult<TData>) => void;
    // (undocumented)
    interface WatchOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> extends DiffOptions<TData, TVariables> {
        // (undocumented)
        callback: WatchCallback<TData>;
        // (undocumented)
        immediate?: boolean;
        // (undocumented)
        lastDiff?: DiffResult<TData>;
        // (undocumented)
        watcher?: object;
    }
    // (undocumented)
    interface WriteFragmentOptions<TData, TVariables extends OperationVariables> {
        broadcast?: boolean;
        data: Unmasked<TData>;
        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        id?: string;
        overwrite?: boolean;
        variables?: TVariables;
    }
    // (undocumented)
    interface WriteOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
        broadcast?: boolean;
        // (undocumented)
        dataId?: string;
        overwrite?: boolean;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        // (undocumented)
        result: Unmasked<TData>;
        variables?: TVariables;
    }
    // (undocumented)
    interface WriteQueryOptions<TData, TVariables extends OperationVariables> {
        broadcast?: boolean;
        data: Unmasked<TData>;
        id?: string;
        overwrite?: boolean;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        variables?: TVariables;
    }
}
export { Cache_2 as Cache }

// @public (undocumented)
class CacheGroup {
    constructor(caching: boolean, parent?: CacheGroup | null);
    // (undocumented)
    readonly caching: boolean;
    // (undocumented)
    depend(dataId: string, storeFieldName: string): void;
    // (undocumented)
    dirty(dataId: string, storeFieldName: string): void;
    // (undocumented)
    keyMaker: Trie<object>;
    // (undocumented)
    resetCaching(): void;
}

// @public (undocumented)
type CanReadFunction = (value: StoreValue) => boolean;

// @public (undocumented)
export const checkFetcher: (fetcher: typeof fetch | undefined) => void;

// @public (undocumented)
namespace ClientAwarenessLink {
    // (undocumented)
    interface ClientAwarenessOptions {
        name?: string;
        transport?: "headers" | false;
        version?: string;
    }
    interface ContextOptions {
        clientAwareness?: ClientAwarenessLink.ClientAwarenessOptions;
    }
    // (undocumented)
    interface EnhancedClientAwarenessOptions {
        transport?: "extensions" | false;
    }
    // (undocumented)
    interface Options {
        clientAwareness?: ClientAwarenessLink.ClientAwarenessOptions;
        enhancedClientAwareness?: ClientAwarenessLink.EnhancedClientAwarenessOptions;
    }
}

// @public
class ClientAwarenessLink extends ApolloLink {
    constructor(options?: ClientAwarenessLink.Options);
}

// @public (undocumented)
export namespace CombinedGraphQLErrors {
    // (undocumented)
    export namespace DocumentationTypes {
        export function formatMessage(errors: ReadonlyArray<GraphQLFormattedError>, options: MessageFormatterOptions): string;
        // (undocumented)
        export interface InstanceProperties {
            readonly data: Record<string, unknown> | null | undefined;
            readonly errors: ReadonlyArray<GraphQLFormattedError>;
            readonly extensions: Record<string, unknown> | undefined;
        }
        export function is(error: unknown): boolean;
    }
    export type MessageFormatter = (errors: ReadonlyArray<GraphQLFormattedError>, options: MessageFormatterOptions) => string;
    // (undocumented)
    export interface MessageFormatterOptions {
        defaultFormatMessage: (errors: ReadonlyArray<GraphQLFormattedError>) => string;
        result: ApolloLink.Result<unknown>;
    }
}

// @public
export class CombinedGraphQLErrors extends Error {
    constructor(result: FormattedExecutionResult<any>);
    constructor(result: ApolloLink.Result<any>, errors: ReadonlyArray<GraphQLFormattedError>);
    readonly data: Record<string, unknown> | null | undefined;
    readonly errors: ReadonlyArray<GraphQLFormattedError>;
    readonly extensions: Record<string, unknown> | undefined;
    static formatMessage: CombinedGraphQLErrors.MessageFormatter;
    static is(error: unknown): error is CombinedGraphQLErrors;
}

// @public (undocumented)
export namespace CombinedProtocolErrors {
    // (undocumented)
    export namespace DocumentationTypes {
        export function formatMessage(errors: ReadonlyArray<GraphQLFormattedError>, options: MessageFormatterOptions): string;
        // (undocumented)
        export interface InstanceProperties {
            readonly errors: ReadonlyArray<GraphQLFormattedError>;
        }
    }
    export type MessageFormatter = (errors: ReadonlyArray<GraphQLFormattedError>, options: MessageFormatterOptions) => string;
    // (undocumented)
    export interface MessageFormatterOptions {
        defaultFormatMessage: (errors: ReadonlyArray<GraphQLFormattedError>) => string;
    }
}

// @public
export class CombinedProtocolErrors extends Error {
    constructor(protocolErrors: Array<GraphQLFormattedError> | ReadonlyArray<GraphQLFormattedError>);
    readonly errors: ReadonlyArray<GraphQLFormattedError>;
    static formatMessage: CombinedProtocolErrors.MessageFormatter;
    static is(error: unknown): error is CombinedProtocolErrors;
}

// @public @deprecated (undocumented)
export const concat: typeof ApolloLink.concat;

// @public @deprecated (undocumented)
export const createHttpLink: (options?: HttpLink.Options) => HttpLink;

// @public @deprecated (undocumented)
export const createSignalIfSupported: () => {
    controller: boolean;
    signal: boolean;
} | {
    controller: AbortController;
    signal: AbortSignal;
};

// @public (undocumented)
export type DataState<TData> = {
    data: DataValue.Complete<TData>;
    dataState: "complete";
} | {
    data: DataValue.Streaming<TData>;
    dataState: "streaming";
} | {
    data: DataValue.Partial<TData>;
    dataState: "partial";
} | {
    data: undefined;
    dataState: "empty";
};

// @public (undocumented)
export namespace DataValue {
    // Warning: (ae-forgotten-export) The symbol "OverridableTypes" needs to be exported by the entry point index.d.ts
    export type Complete<TData> = ApplyHKTImplementationWithDefault<TypeOverrides, "Complete", OverridableTypes.Defaults, TData>;
    export type Partial<TData> = ApplyHKTImplementationWithDefault<TypeOverrides, "Partial", OverridableTypes.Defaults, TData>;
    export type Streaming<TData> = ApplyHKTImplementationWithDefault<TypeOverrides, "Streaming", OverridableTypes.Defaults, TData>;
}

// Warning: (ae-forgotten-export) The symbol "DeepPartialPrimitive" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialReadonlyMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialSet" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialReadonlySet" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialObject" needs to be exported by the entry point index.d.ts
//
// @public
type DeepPartial<T> = T extends DeepPartialPrimitive ? T : T extends Map<infer TKey, infer TValue> ? DeepPartialMap<TKey, TValue> : T extends ReadonlyMap<infer TKey, infer TValue> ? DeepPartialReadonlyMap<TKey, TValue> : T extends Set<infer TItem> ? DeepPartialSet<TItem> : T extends ReadonlySet<infer TItem> ? DeepPartialReadonlySet<TItem> : T extends (...args: any[]) => unknown ? T | undefined : T extends object ? T extends (ReadonlyArray<infer TItem>) ? TItem[] extends (T) ? readonly TItem[] extends T ? ReadonlyArray<DeepPartial<TItem | undefined>> : Array<DeepPartial<TItem | undefined>> : DeepPartialObject<T> : DeepPartialObject<T> : unknown;

// Warning: (ae-forgotten-export) The symbol "DeepPartial" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepPartialMap<TKey, TValue> = {} & Map<DeepPartial<TKey>, DeepPartial<TValue>>;

// @public (undocumented)
type DeepPartialObject<T extends object> = {
    [K in keyof T]?: DeepPartial<T[K]>;
};

// Warning: (ae-forgotten-export) The symbol "Primitive" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepPartialPrimitive = Primitive | Date | RegExp;

// @public (undocumented)
type DeepPartialReadonlyMap<TKey, TValue> = {} & ReadonlyMap<DeepPartial<TKey>, DeepPartial<TValue>>;

// @public (undocumented)
type DeepPartialReadonlySet<T> = {} & ReadonlySet<DeepPartial<T>>;

// @public (undocumented)
type DeepPartialSet<T> = {} & Set<DeepPartial<T>>;

// @public (undocumented)
export interface DefaultContext extends Record<string, any> {
    // (undocumented)
    clientAwareness?: ClientAwarenessLink.ClientAwarenessOptions;
    queryDeduplication?: boolean;
}

// Warning: (ae-forgotten-export) The symbol "KeyFieldsContext" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function defaultDataIdFromObject({ __typename, id, _id }: Readonly<StoreObject>, context?: KeyFieldsContext): string | undefined;

// @public @deprecated (undocumented)
export type DefaultOptions = ApolloClient.DefaultOptions;

// Warning: (ae-forgotten-export) The symbol "BaseHttpLink" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const defaultPrinter: BaseHttpLink.Printer;

// @public (undocumented)
interface DeleteModifier {
    // (undocumented)
    [_deleteModifier]: true;
}

// @public (undocumented)
const _deleteModifier: unique symbol;

// @public @deprecated (undocumented)
export type DevtoolsOptions = ApolloClient.DevtoolsOptions;

// @public (undocumented)
export type DiffQueryAgainstStoreOptions = ReadQueryOptions & {
    returnPartialData?: boolean;
};

export { disableExperimentalFragmentVariables }

export { disableFragmentWarnings }

export { DocumentNode }

// @public
export class DocumentTransform {
    // Warning: (ae-forgotten-export) The symbol "TransformFn" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "DocumentTransformOptions" needs to be exported by the entry point index.d.ts
    constructor(transform: TransformFn, options?: DocumentTransformOptions);
    concat(otherTransform: DocumentTransform): DocumentTransform;
    static identity(): DocumentTransform;
    // @internal @deprecated
    readonly left?: DocumentTransform;
    resetCache(): void;
    // @internal @deprecated
    readonly right?: DocumentTransform;
    static split(predicate: (document: DocumentNode) => boolean, left: DocumentTransform, right?: DocumentTransform): DocumentTransform & {
        left: DocumentTransform;
        right: DocumentTransform;
    };
    transformDocument(document: DocumentNode): DocumentNode;
}

// @public (undocumented)
export type DocumentTransformCacheKey = ReadonlyArray<unknown>;

// @public (undocumented)
interface DocumentTransformOptions {
    cache?: boolean;
    getCacheKey?: (document: DocumentNode) => DocumentTransformCacheKey | undefined;
}

// @public @deprecated (undocumented)
export const empty: typeof ApolloLink.empty;

export { enableExperimentalFragmentVariables }

// @public (undocumented)
abstract class EntityStore implements NormalizedCache {
    constructor(policies: Policies, group: CacheGroup);
    // Warning: (ae-forgotten-export) The symbol "Layer" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
    // Warning: (ae-forgotten-export) The symbol "CanReadFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    clear(): void;
    // (undocumented)
    protected data: NormalizedCacheObject;
    // (undocumented)
    delete(dataId: string, fieldName?: string, args?: Record<string, any>): boolean;
    // (undocumented)
    evict(options: Cache_2.EvictOptions, limit: EntityStore): boolean;
    // (undocumented)
    extract(): NormalizedCacheObject;
    // (undocumented)
    findChildRefIds(dataId: string): Record<string, true>;
    // (undocumented)
    gc(): string[];
    // (undocumented)
    get(dataId: string, fieldName: string): StoreValue;
    // Warning: (ae-forgotten-export) The symbol "SafeReadonly" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getFieldValue: <T = StoreValue>(objectOrReference: StoreObject | Reference | undefined, storeFieldName: string) => SafeReadonly<T>;
    // (undocumented)
    getRootIdSet(ids?: Set<string>): Set<string>;
    // Warning: (ae-forgotten-export) The symbol "StorageType" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract getStorage(idOrObj: string | StoreObject, ...storeFieldNames: (string | number)[]): StorageType;
    // Warning: (ae-forgotten-export) The symbol "CacheGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly group: CacheGroup;
    // (undocumented)
    has(dataId: string): boolean;
    // (undocumented)
    protected lookup(dataId: string, dependOnExistence?: boolean): StoreObject | undefined;
    makeCacheKey(document: DocumentNode, callback: Cache_2.WatchCallback<any>, details: string): object;
    makeCacheKey(selectionSet: SelectionSetNode, parent: string | StoreObject, varString: string | undefined): object;
    makeCacheKey(field: FieldNode, array: readonly any[], varString: string | undefined): object;
    // @deprecated (undocumented)
    makeCacheKey(...args: any[]): object;
    // (undocumented)
    merge(older: string | StoreObject, newer: StoreObject | string): void;
    // (undocumented)
    modify(dataId: string, fields: Modifier<any> | Modifiers<Record<string, any>>, exact: boolean): boolean;
    // Warning: (ae-forgotten-export) The symbol "Policies" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly policies: Policies;
    // (undocumented)
    release(rootId: string): number;
    // (undocumented)
    abstract removeLayer(layerId: string): EntityStore;
    // (undocumented)
    replace(newData: NormalizedCacheObject | null): void;
    // (undocumented)
    retain(rootId: string): number;
    // Warning: (ae-forgotten-export) The symbol "Root" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static Root: typeof Root;
    // (undocumented)
    get supportsResultCaching(): boolean;
    // (undocumented)
    toObject(): NormalizedCacheObject;
    // Warning: (ae-forgotten-export) The symbol "ToReferenceFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    toReference: ToReferenceFunction;
}

// @public
export interface ErrorLike {
    // (undocumented)
    message: string;
    // (undocumented)
    name: string;
    // (undocumented)
    stack?: string;
}

// @public
export type ErrorPolicy = "none" | "ignore" | "all";

// @public (undocumented)
export const execute: typeof ApolloLink.execute;

// @public (undocumented)
export const fallbackHttpConfig: {
    http: BaseHttpLink.HttpOptions;
    headers: {
        accept: string;
        "content-type": string;
    };
    options: {
        method: string;
    };
};

// @public
export type FetchPolicy = "cache-first" | "network-only" | "cache-only" | "no-cache";

// @public @deprecated (undocumented)
export type FetchResult<TData = Record<string, any>, TExtensions = Record<string, any>> = ApolloLink.Result<TData, TExtensions>;

// @public (undocumented)
export interface FieldFunctionOptions<TArgs = Record<string, any>, TVariables extends OperationVariables = Record<string, any>> {
    // (undocumented)
    args: TArgs | null;
    // (undocumented)
    cache: InMemoryCache;
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    field: FieldNode | null;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    isReference: typeof isReference;
    // Warning: (ae-forgotten-export) The symbol "MergeObjectsFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mergeObjects: MergeObjectsFunction;
    // Warning: (ae-forgotten-export) The symbol "ReadFieldFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readField: ReadFieldFunction;
    // (undocumented)
    storage: StorageType;
    // (undocumented)
    storeFieldName: string;
    // (undocumented)
    toReference: ToReferenceFunction;
    // (undocumented)
    variables?: TVariables;
}

// @public (undocumented)
export type FieldMergeFunction<TExisting = any, TIncoming = TExisting, TOptions extends FieldFunctionOptions = FieldFunctionOptions> = (existing: SafeReadonly<TExisting> | undefined, incoming: SafeReadonly<TIncoming>, options: TOptions) => SafeReadonly<TExisting>;

// @public (undocumented)
export type FieldPolicy<TExisting = any, TIncoming = TExisting, TReadResult = TIncoming, TOptions extends FieldFunctionOptions = FieldFunctionOptions> = {
    keyArgs?: KeySpecifier | KeyArgsFunction | false;
    read?: FieldReadFunction<TExisting, TReadResult, TOptions>;
    merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;
};

// @public (undocumented)
export type FieldReadFunction<TExisting = any, TReadResult = TExisting, TOptions extends FieldFunctionOptions = FieldFunctionOptions> = (existing: SafeReadonly<TExisting> | undefined, options: TOptions) => TReadResult | undefined;

// @public (undocumented)
interface FieldSpecifier {
    // (undocumented)
    args?: Record<string, any>;
    // (undocumented)
    field?: FieldNode;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    typename?: string;
    // (undocumented)
    variables?: Record<string, any>;
}

// Warning: (ae-forgotten-export) The symbol "EntityStore" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FieldValueGetter = EntityStore["getFieldValue"];

// Warning: (ae-forgotten-export) The symbol "WriteContext" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FlavorableWriteContext = Pick<WriteContext, "clientOnly" | "deferred" | "flavors">;

// @internal @deprecated
interface FragmentMap {
    // (undocumented)
    [fragmentName: string]: FragmentDefinitionNode;
}

// @internal @deprecated (undocumented)
type FragmentMapFunction = (fragmentName: string) => FragmentDefinitionNode | null;

// @public (undocumented)
interface FragmentRegistryAPI {
    // (undocumented)
    lookup(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    register(...fragments: DocumentNode[]): this;
    // (undocumented)
    resetCaches(): void;
    // (undocumented)
    transform<D extends DocumentNode>(document: D): D;
}

// Warning: (ae-forgotten-export) The symbol "PreserveTypes" needs to be exported by the entry point index.d.ts
//
// @public
export type FragmentType<TFragmentData> = ApplyHKTImplementationWithDefault<TypeOverrides, "FragmentType", PreserveTypes.TypeOverrides, TFragmentData>;

// @public @deprecated (undocumented)
export const from: typeof ApolloLink.from;

// @internal @deprecated
const getApolloCacheMemoryInternals: (() => {
    cache: {
        fragmentQueryDocuments: number | undefined;
    };
}) | undefined;

// @internal @deprecated
const getApolloClientMemoryInternals: (() => {
    limits: {
        [k: string]: number;
    };
    sizes: {
        cache?: {
            fragmentQueryDocuments: number | undefined;
        } | undefined;
        addTypenameDocumentTransform?: {
            cache: number;
        }[] | undefined;
        inMemoryCache?: {
            executeSelectionSet: number | undefined;
            executeSubSelectedArray: number | undefined;
            maybeBroadcastWatch: number | undefined;
        } | undefined;
        fragmentRegistry?: {
            findFragmentSpreads: number | undefined;
            lookup: number | undefined;
            transform: number | undefined;
        } | undefined;
        print: number | undefined;
        canonicalStringify: number | undefined;
        links: unknown[];
        queryManager: {
            getDocumentInfo: number;
            documentTransforms: {
                cache: number;
            }[];
        };
    };
}) | undefined;

// @public (undocumented)
export type GetDataState<TData, TState extends DataState<TData>["dataState"]> = Extract<DataState<TData>, {
    dataState: TState;
}>;

// @internal @deprecated
const getInMemoryCacheMemoryInternals: (() => {
    addTypenameDocumentTransform: {
        cache: number;
    }[];
    inMemoryCache: {
        executeSelectionSet: number | undefined;
        executeSubSelectedArray: number | undefined;
        maybeBroadcastWatch: number | undefined;
    };
    fragmentRegistry: {
        findFragmentSpreads: number | undefined;
        lookup: number | undefined;
        transform: number | undefined;
    };
    cache: {
        fragmentQueryDocuments: number | undefined;
    };
}) | undefined;

export { gql }

// @public @deprecated (undocumented)
export type GraphQLRequest = ApolloLink.Request;

// @beta
interface HKT {
    // (undocumented)
    arg1: unknown;
    // (undocumented)
    arg2: unknown;
    // (undocumented)
    arg3: unknown;
    // (undocumented)
    arg4: unknown;
    // (undocumented)
    return: unknown;
}

// @public (undocumented)
interface HttpConfig {
    // (undocumented)
    credentials?: any;
    // (undocumented)
    headers?: Record<string, string>;
    // (undocumented)
    http?: BaseHttpLink.HttpOptions;
    // (undocumented)
    options?: any;
}

// @public (undocumented)
export namespace HttpLink {
    export interface ContextOptions extends BaseHttpLink.ContextOptions, ClientAwarenessLink.ContextOptions {
    }
    export interface Options extends BaseHttpLink.Options, ClientAwarenessLink.Options {
    }
}

// @public
export class HttpLink extends ApolloLink {
    constructor(options?: HttpLink.Options);
}

// @public (undocumented)
export type IdGetter = (value: IdGetterObj) => string | undefined;

// @public (undocumented)
export interface IdGetterObj extends Object {
    // (undocumented)
    __typename?: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    _id?: string;
}

// @public (undocumented)
interface IgnoreModifier {
    // (undocumented)
    [_ignoreModifier]: true;
}

// @public (undocumented)
const _ignoreModifier: unique symbol;

// @public (undocumented)
namespace Incremental {
    // @internal @deprecated (undocumented)
    interface Handler<Chunk extends Record<string, unknown> = Record<string, unknown>> {
        // (undocumented)
        extractErrors: (result: ApolloLink.Result<any>) => readonly GraphQLFormattedError[] | undefined | void;
        // (undocumented)
        isIncrementalResult: (result: ApolloLink.Result<any>) => result is Chunk;
        // (undocumented)
        prepareRequest: (request: ApolloLink.Request) => ApolloLink.Request;
        // Warning: (ae-forgotten-export) The symbol "Incremental" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        startRequest: <TData extends Record<string, unknown>>(request: {
            query: DocumentNode;
        }) => IncrementalRequest<Chunk, TData>;
    }
    // (undocumented)
    interface IncrementalRequest<Chunk extends Record<string, unknown>, TData> {
        // (undocumented)
        handle: (cacheData: TData | DeepPartial<TData> | undefined | null, chunk: Chunk) => FormattedExecutionResult<TData>;
        // (undocumented)
        hasNext: boolean;
    }
    // (undocumented)
    type Path = ReadonlyArray<string | number>;
}

// @public (undocumented)
type InferContextValueFromResolvers<TResolvers> = TResolvers extends {
    [typename: string]: infer TFieldResolvers;
} ? TFieldResolvers extends ({
    [field: string]: LocalState.Resolver<any, any, infer TContext, any>;
}) ? unknown extends TContext ? DefaultContext : TContext : DefaultContext : DefaultContext;

// @public (undocumented)
export class InMemoryCache extends ApolloCache {
    constructor(config?: InMemoryCacheConfig);
    // (undocumented)
    readonly assumeImmutableResults = true;
    batch<TUpdateResult>(options: Cache_2.BatchOptions<InMemoryCache, TUpdateResult>): TUpdateResult;
    // Warning: (ae-forgotten-export) The symbol "BroadcastOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected broadcastWatches(options?: BroadcastOptions): void;
    // (undocumented)
    protected config: InMemoryCacheConfig;
    // (undocumented)
    diff<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: Cache_2.DiffOptions<TData, TVariables>): Cache_2.DiffResult<TData>;
    // (undocumented)
    evict(options: Cache_2.EvictOptions): boolean;
    // (undocumented)
    extract(optimistic?: boolean): NormalizedCacheObject;
    // (undocumented)
    fragmentMatches(fragment: InlineFragmentNode | FragmentDefinitionNode, typename: string): boolean;
    // (undocumented)
    gc(options?: {
        resetResultCache?: boolean;
    }): string[];
    // Warning: (ae-forgotten-export) The symbol "getInMemoryCacheMemoryInternals" needs to be exported by the entry point index.d.ts
    //
    // @internal @deprecated
    getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // (undocumented)
    lookupFragment(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    readonly makeVar: typeof makeVar;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_2.ModifyOptions<Entity>): boolean;
    // (undocumented)
    performTransaction(update: (cache: InMemoryCache) => any, optimisticId?: string | null): any;
    // (undocumented)
    readonly policies: Policies;
    // (undocumented)
    read<TData = unknown>(options: Cache_2.ReadOptions<TData, OperationVariables> & {
        returnPartialData: true;
    }): TData | DeepPartial<TData> | null;
    // (undocumented)
    read<TData = unknown>(options: Cache_2.ReadOptions<TData, OperationVariables>): TData | null;
    // (undocumented)
    release(rootId: string, optimistic?: boolean): number;
    // (undocumented)
    removeOptimistic(idToRemove: string): void;
    // (undocumented)
    reset(options?: Cache_2.ResetOptions): Promise<void>;
    // (undocumented)
    restore(data: NormalizedCacheObject): this;
    // (undocumented)
    retain(rootId: string, optimistic?: boolean): number;
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
    // (undocumented)
    watch<TData = unknown, TVariables extends OperationVariables = OperationVariables>(watch: Cache_2.WatchOptions<TData, TVariables>): () => void;
    // (undocumented)
    write<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: Cache_2.WriteOptions<TData, TVariables>): Reference | undefined;
}

// @public (undocumented)
export interface InMemoryCacheConfig extends ApolloReducerConfig {
    // Warning: (ae-forgotten-export) The symbol "FragmentRegistryAPI" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fragments?: FragmentRegistryAPI;
    // (undocumented)
    possibleTypes?: PossibleTypesMap;
    // (undocumented)
    resultCaching?: boolean;
    // (undocumented)
    typePolicies?: TypePolicies;
}

// Warning: (ae-forgotten-export) The symbol "RefetchQueriesIncludeShorthand" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type InternalRefetchQueriesInclude = InternalRefetchQueryDescriptor[] | RefetchQueriesIncludeShorthand;

// @public (undocumented)
export type InternalRefetchQueriesMap<TResult> = Map<ObservableQuery<any>, InternalRefetchQueriesResult<TResult>>;

// @public (undocumented)
export interface InternalRefetchQueriesOptions<TCache extends ApolloCache, TResult> extends Omit<ApolloClient.RefetchQueriesOptions<TCache, TResult>, "include"> {
    // (undocumented)
    include?: InternalRefetchQueriesInclude;
    // (undocumented)
    removeOptimistic?: string;
}

// @public (undocumented)
export type InternalRefetchQueriesResult<TResult> = TResult extends boolean ? Promise<ApolloClient.QueryResult<any>> : TResult;

// @public (undocumented)
export type InternalRefetchQueryDescriptor = RefetchQueryDescriptor | ApolloClient.QueryOptions;

// @internal @deprecated (undocumented)
export namespace InternalTypes {
    export type { NextFetchPolicyContext, QueryManager };
}

// @public (undocumented)
interface InvalidateModifier {
    // (undocumented)
    [_invalidateModifier]: true;
}

// @public (undocumented)
const _invalidateModifier: unique symbol;

// @internal @deprecated (undocumented)
type IsAny<T> = 0 extends 1 & T ? true : false;

// @public
export function isNetworkRequestSettled(networkStatus?: NetworkStatus): boolean;

// @public
export function isReference(obj: any): obj is Reference;

// @public (undocumented)
type KeyArgsFunction = (args: Record<string, any> | null, context: {
    typename: string;
    fieldName: string;
    field: FieldNode | null;
    variables?: Record<string, any>;
}) => KeySpecifier | false | ReturnType<IdGetter>;

// @public (undocumented)
type KeyFieldsContext = {
    typename: string | undefined;
    storeObject: StoreObject;
    readField: ReadFieldFunction;
    selectionSet?: SelectionSetNode;
    fragmentMap?: FragmentMap;
    keyObject?: Record<string, any>;
};

// @public (undocumented)
type KeyFieldsFunction = (object: Readonly<StoreObject>, context: KeyFieldsContext) => KeySpecifier | false | ReturnType<IdGetter>;

// @public (undocumented)
type KeySpecifier = ReadonlyArray<string | KeySpecifier>;

// @public (undocumented)
class Layer extends EntityStore {
    constructor(id: string, parent: EntityStore, replay: (layer: EntityStore) => any, group: CacheGroup);
    // (undocumented)
    addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
    // (undocumented)
    findChildRefIds(dataId: string): Record<string, true>;
    // (undocumented)
    getStorage(...args: Parameters<EntityStore["getStorage"]>): StorageType;
    // (undocumented)
    readonly group: CacheGroup;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly parent: EntityStore;
    // (undocumented)
    removeLayer(layerId: string): EntityStore;
    // (undocumented)
    readonly replay: (layer: EntityStore) => any;
    // (undocumented)
    toObject(): NormalizedCacheObject;
}

// @public
export const LinkError: {
    is: (error: unknown) => boolean;
};

// @public (undocumented)
namespace LocalState {
    // Warning: (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    type ContextFunction<TContext> = (options: ContextFunctionOptions) => TContext;
    // (undocumented)
    interface ContextFunctionOptions {
        // (undocumented)
        client: ApolloClient;
        // (undocumented)
        document: DocumentNode;
        // (undocumented)
        phase: "exports" | "resolve";
        // (undocumented)
        requestContext: DefaultContext;
        // (undocumented)
        variables: OperationVariables;
    }
    // Warning: (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "MaybeRequireContextFunction" needs to be exported by the entry point index.d.ts
    type Options<TResolvers extends Resolvers = Resolvers, TContext = DefaultContext> = {
        context?: ContextFunction<TContext>;
        resolvers?: TResolvers;
    } & MaybeRequireContextFunction<TContext>;
    // (undocumented)
    type Path = Array<string | number>;
    type Resolver<TResult = unknown, TParent = unknown, TContext = DefaultContext, TArgs = Record<string, unknown>> = (rootValue: TParent, args: TArgs, context: {
        requestContext: TContext;
        client: ApolloClient;
        phase: "exports" | "resolve";
    }, info: {
        field: FieldNode;
        fragmentMap: FragmentMap;
        path: Path;
    }) => TResult | Promise<TResult>;
    interface Resolvers<TContext = any> {
        // (undocumented)
        [typename: string]: {
            [field: string]: Resolver<any, any, TContext, any>;
        };
    }
    // Warning: (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    type RootValueFunction<TRootValue> = (context: RootValueFunctionContext) => TRootValue;
    // (undocumented)
    interface RootValueFunctionContext {
        // (undocumented)
        client: ApolloClient;
        // (undocumented)
        context: DefaultContext;
        // (undocumented)
        document: DocumentNode;
        // (undocumented)
        phase: "exports" | "resolve";
        // (undocumented)
        variables: OperationVariables;
    }
}

// Warning: (ae-forgotten-export) The symbol "InferContextValueFromResolvers" needs to be exported by the entry point index.d.ts
//
// @public
class LocalState<TResolvers extends LocalState.Resolvers = LocalState.Resolvers<DefaultContext>, TContext = InferContextValueFromResolvers<TResolvers>> {
    constructor(...[options]: {} extends TResolvers ? [
    options?: LocalState.Options<TResolvers, NoInfer_2<TContext>>
    ] : [
    options: LocalState.Options<TResolvers, NoInfer_2<TContext>> & {
        resolvers: TResolvers;
    }
    ]);
    addResolvers(resolvers: TResolvers): void;
    // (undocumented)
    execute<TData = unknown, TVariables extends OperationVariables = OperationVariables>({ document, client, context, remoteResult, variables, onlyRunForcedResolvers, returnPartialData, }: {
        document: DocumentNode | TypedDocumentNode<TData, TVariables>;
        client: ApolloClient;
        context: DefaultContext | undefined;
        remoteResult: FormattedExecutionResult<any> | undefined;
        variables: TVariables | undefined;
        onlyRunForcedResolvers?: boolean;
        returnPartialData?: boolean;
    }): Promise<FormattedExecutionResult<TData>>;
    // (undocumented)
    getExportedVariables<TVariables extends OperationVariables = OperationVariables>({ document, client, context, variables, }: {
        document: DocumentNode | TypedDocumentNode<any, TVariables>;
        client: ApolloClient;
        context: DefaultContext | undefined;
        variables: Partial<NoInfer_2<TVariables>>;
    }): Promise<TVariables>;
}

// @public (undocumented)
export namespace LocalStateError {
    // (undocumented)
    export namespace DocumentationTypes {
        // (undocumented)
        export interface InstanceProperties {
            readonly path?: Array<string | number>;
        }
    }
    // (undocumented)
    export interface Options {
        // (undocumented)
        path?: Array<string | number>;
        // (undocumented)
        sourceError?: unknown;
    }
}

// @public
export class LocalStateError extends Error {
    constructor(message: string, options?: LocalStateError.Options);
    static is(error: unknown): error is LocalStateError;
    readonly path?: Array<string | number>;
}

// @public (undocumented)
export function makeVar<T>(value: T): ReactiveVar<T>;

// @public (undocumented)
interface MaskFragmentOptions<TData> {
    // (undocumented)
    data: TData;
    // (undocumented)
    fragment: DocumentNode;
    // (undocumented)
    fragmentName?: string;
}

// @public (undocumented)
interface MaskOperationOptions<TData> {
    cause?: object;
    // (undocumented)
    data: TData;
    // (undocumented)
    document: DocumentNode;
    // (undocumented)
    fetchPolicy?: WatchQueryFetchPolicy;
}

// @public
export type MaybeMasked<TData> = ApplyHKTImplementationWithDefault<TypeOverrides, "MaybeMasked", PreserveTypes.TypeOverrides, TData>;

// Warning: (ae-forgotten-export) The symbol "RemoveIndexSignature" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type MaybeRequireContextFunction<TContext> = {} extends RemoveIndexSignature<TContext> ? {} : {
    context: LocalState.ContextFunction<TContext>;
};

// @public (undocumented)
export interface MergeInfo {
    // (undocumented)
    field: FieldNode;
    // (undocumented)
    merge: FieldMergeFunction;
    // (undocumented)
    typename: string | undefined;
}

// @public (undocumented)
type MergeObjectsFunction = <T extends StoreObject | Reference>(existing: T, incoming: T) => T;

// @public (undocumented)
export interface MergeTree {
    // (undocumented)
    info?: MergeInfo;
    // (undocumented)
    map: Map<string | number, MergeTree>;
}

// @public (undocumented)
export class MissingFieldError extends Error {
    constructor(message: string, path: MissingTree | Array<string | number>, query: DocumentNode, variables?: Record<string, any> | undefined);
    // (undocumented)
    readonly message: string;
    // (undocumented)
    readonly missing: MissingTree;
    // (undocumented)
    readonly path: MissingTree | Array<string | number>;
    // (undocumented)
    readonly query: DocumentNode;
    // (undocumented)
    readonly variables?: Record<string, any> | undefined;
}

// @public (undocumented)
type MissingTree = string | {
    readonly [key: string]: MissingTree;
};

// Warning: (ae-forgotten-export) The symbol "ModifierDetails" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeleteModifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "InvalidateModifier" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Modifier<T> = (value: T, details: ModifierDetails) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;

// @public (undocumented)
type ModifierDetails = {
    DELETE: DeleteModifier;
    INVALIDATE: InvalidateModifier;
    fieldName: string;
    storeFieldName: string;
    readField: ReadFieldFunction;
    canRead: CanReadFunction;
    isReference: typeof isReference;
    toReference: ToReferenceFunction;
    storage: StorageType;
};

// @public (undocumented)
type Modifiers<T extends Record<string, any> = Record<string, unknown>> = Partial<{
    [FieldName in keyof T]: Modifier<StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>>;
}>;

// @public @deprecated (undocumented)
export type MutateResult<TData = unknown> = ApolloClient.MutateResult<TData>;

// @public (undocumented)
export type MutationFetchPolicy = Extract<FetchPolicy, "network-only" | "no-cache">;

// @public @deprecated (undocumented)
export type MutationOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables, TCache extends ApolloCache = ApolloCache> = ApolloClient.MutateOptions<TData, TVariables, TCache>;

// @public (undocumented)
export type MutationQueryReducer<T> = (previousResult: Record<string, any>, options: {
    mutationResult: NormalizedExecutionResult<Unmasked<T>>;
    queryName: string | undefined;
    queryVariables: Record<string, any>;
}) => Record<string, any>;

// @public (undocumented)
export type MutationQueryReducersMap<T = {
    [key: string]: any;
}> = {
    [queryName: string]: MutationQueryReducer<T>;
};

// @public (undocumented)
interface MutationStoreValue {
    // (undocumented)
    error: Error | null;
    // (undocumented)
    loading: boolean;
    // (undocumented)
    mutation: DocumentNode;
    // (undocumented)
    variables: Record<string, any>;
}

// @public (undocumented)
export type MutationUpdaterFunction<TData, TVariables extends OperationVariables, TCache extends ApolloCache> = (cache: TCache, result: FormattedExecutionResult<Unmasked<TData>>, options: {
    context?: DefaultContext;
    variables?: TVariables;
}) => void;

// @public
export enum NetworkStatus {
    error = 8,
    fetchMore = 3,
    loading = 1,
    poll = 6,
    ready = 7,
    refetch = 4,
    setVariables = 2,
    streaming = 9
}

// @public (undocumented)
interface NextFetchPolicyContext<TData, TVariables extends OperationVariables> {
    // (undocumented)
    initialFetchPolicy: WatchQueryFetchPolicy;
    // (undocumented)
    observable: ObservableQuery<TData, TVariables>;
    // (undocumented)
    options: ApolloClient.WatchQueryOptions<TData, TVariables>;
    // (undocumented)
    reason: "after-fetch" | "variables-changed";
}

// @public @deprecated
type NoInfer_2<T> = [T][T extends any ? 0 : never];

// @public
export interface NormalizedCache {
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    clear(): void;
    // (undocumented)
    delete(dataId: string, fieldName?: string): boolean;
    // (undocumented)
    get(dataId: string, fieldName: string): StoreValue;
    // Warning: (ae-forgotten-export) The symbol "FieldValueGetter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getFieldValue: FieldValueGetter;
    // (undocumented)
    getStorage(idOrObj: string | StoreObject, ...storeFieldNames: (string | number)[]): StorageType;
    // (undocumented)
    has(dataId: string): boolean;
    // (undocumented)
    merge(olderId: string, newerObject: StoreObject): void;
    // (undocumented)
    merge(olderObject: StoreObject, newerId: string): void;
    // (undocumented)
    modify<Entity extends Record<string, any>>(dataId: string, fields: Modifiers<Entity> | AllFieldsModifier<Entity>, exact: boolean): boolean;
    // (undocumented)
    release(rootId: string): number;
    replace(newData: NormalizedCacheObject): void;
    retain(rootId: string): number;
    toObject(): NormalizedCacheObject;
    // (undocumented)
    toReference: ToReferenceFunction;
}

// @public
export interface NormalizedCacheObject {
    // (undocumented)
    [dataId: string]: StoreObject | undefined;
    // (undocumented)
    __META?: {
        extraRootIds: string[];
    };
}

// @public
export type NormalizedExecutionResult<TData = Record<string, unknown>, TExtensions = Record<string, unknown>> = Omit<FormattedExecutionResult<TData, TExtensions>, "data"> & GetDataState<TData, "streaming" | "complete">;

// @public (undocumented)
namespace NotImplementedHandler {
    // (undocumented)
    interface NotImplementedResult extends HKT {
        // (undocumented)
        arg1: unknown;
        // (undocumented)
        arg2: unknown;
        // (undocumented)
        return: never;
    }
    // (undocumented)
    interface TypeOverrides {
        // Warning: (ae-forgotten-export) The symbol "NotImplementedHandler" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        AdditionalApolloLinkResultTypes: NotImplementedResult;
    }
}

// @public (undocumented)
class NotImplementedHandler implements Incremental.Handler<never> {
    // (undocumented)
    extractErrors(): void;
    // (undocumented)
    isIncrementalResult(_: any): _ is never;
    // (undocumented)
    prepareRequest(request: ApolloLink.Request): ApolloLink.Request;
    // (undocumented)
    startRequest: any;
}

export { Observable }

// @public (undocumented)
interface ObservableAndInfo<TData> {
    // (undocumented)
    fromLink: boolean;
    // Warning: (ae-forgotten-export) The symbol "QueryNotification" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    observable: Observable<QueryNotification.Value<TData>>;
}

// @public (undocumented)
export namespace ObservableQuery {
    // @internal @deprecated
    export interface CacheWatchOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> extends Cache_2.WatchOptions<TData, TVariables> {
        // @deprecated
        lastOwnDiff?: Cache_2.DiffResult<TData>;
    }
    // (undocumented)
    export namespace DocumentationTypes {
        // (undocumented)
        export interface ObservableMethods<TData, OperatorResult> {
            pipe(...operators: OperatorFunctionChain<ObservableQuery.Result<TData>, OperatorResult>): Observable<OperatorResult>;
            subscribe(observerOrNext: Partial<Observer<ObservableQuery.Result<MaybeMasked<TData>>>> | ((value: ObservableQuery.Result<MaybeMasked<TData>>) => void)): Subscription;
        }
        // (undocumented)
        export type OperatorFunctionChain<From, To> = [];
    }
    // (undocumented)
    export type FetchMoreOptions<TData, TVariables extends OperationVariables, TFetchData = TData, TFetchVars extends OperationVariables = TVariables> = {
        query?: DocumentNode | TypedDocumentNode<TFetchData, TFetchVars>;
        variables?: Partial<NoInfer<TFetchVars>>;
        errorPolicy?: ErrorPolicy;
        context?: DefaultContext;
        updateQuery?: (previousQueryResult: Unmasked<TData>, options: {
            fetchMoreResult: Unmasked<TFetchData>;
            variables: TFetchVars;
        }) => Unmasked<TData>;
    };
    // (undocumented)
    export type Options<TData = unknown, TVariables extends OperationVariables = OperationVariables> = {
        fetchPolicy: WatchQueryFetchPolicy;
        nextFetchPolicy?: WatchQueryFetchPolicy | ((this: ApolloClient.WatchQueryOptions<TData, TVariables>, currentFetchPolicy: WatchQueryFetchPolicy, context: NextFetchPolicyContext<TData, TVariables>) => WatchQueryFetchPolicy);
        initialFetchPolicy: WatchQueryFetchPolicy;
        refetchWritePolicy?: RefetchWritePolicy;
        errorPolicy?: ErrorPolicy;
        context?: DefaultContext;
        pollInterval?: number;
        notifyOnNetworkStatusChange?: boolean;
        returnPartialData?: boolean;
        skipPollAttempt?: () => boolean;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        variables: TVariables;
    };
    // (undocumented)
    export type Result<TData, TStates extends DataState<TData>["dataState"] = DataState<TData>["dataState"]> = {
        error?: ErrorLike;
        loading: boolean;
        networkStatus: NetworkStatus;
        partial: boolean;
    } & GetDataState<TData, TStates>;
    export interface ResultPromise<T> extends Promise<T> {
        retain(): this;
    }
    // (undocumented)
    export interface SubscribeToMoreOptions<TData = unknown, TSubscriptionVariables extends OperationVariables = OperationVariables, TSubscriptionData = TData, TVariables extends OperationVariables = TSubscriptionVariables> {
        // (undocumented)
        context?: DefaultContext;
        // (undocumented)
        document: DocumentNode | TypedDocumentNode<TSubscriptionData, TSubscriptionVariables>;
        // (undocumented)
        onError?: (error: ErrorLike) => void;
        // (undocumented)
        updateQuery?: SubscribeToMoreUpdateQueryFn<TData, TVariables, TSubscriptionData>;
        // (undocumented)
        variables?: TSubscriptionVariables;
    }
}

// @public (undocumented)
export class ObservableQuery<TData = unknown, TVariables extends OperationVariables = OperationVariables> implements Subscribable<ObservableQuery.Result<MaybeMasked<TData>>>, InteropObservable<ObservableQuery.Result<MaybeMasked<TData>>> {
    // (undocumented)
    ["@@observable"]: () => Subscribable<ObservableQuery.Result<MaybeMasked<TData>>>;
    // (undocumented)
    [Symbol.observable]: () => Subscribable<ObservableQuery.Result<MaybeMasked<TData>>>;
    constructor({ queryManager, options, transformedQuery, }: {
        queryManager: QueryManager;
        options: ApolloClient.WatchQueryOptions<TData, TVariables>;
        transformedQuery?: DocumentNode | TypedDocumentNode<TData, TVariables>;
        queryId?: string;
    });
    // @internal @deprecated (undocumented)
    applyOptions(newOptions: Partial<ObservableQuery.Options<TData, TVariables>>): void;
    fetchMore<TFetchData = TData, TFetchVars extends OperationVariables = TVariables>(options: ObservableQuery.FetchMoreOptions<TData, TVariables, TFetchData, TFetchVars>): Promise<ApolloClient.QueryResult<TFetchData>>;
    // @internal @deprecated (undocumented)
    getCacheDiff({ optimistic }?: {
        optimistic?: boolean | undefined;
    }): Cache_2.DiffResult<TData>;
    // (undocumented)
    getCurrentResult(): ObservableQuery.Result<MaybeMasked<TData>>;
    // (undocumented)
    hasObservers(): boolean;
    // @internal @deprecated
    _lastWrite?: unknown;
    // @internal @deprecated (undocumented)
    notify(scheduled?: boolean): void;
    // (undocumented)
    readonly options: ObservableQuery.Options<TData, TVariables>;
    pipe: Observable<ObservableQuery.Result<MaybeMasked<TData>>>["pipe"];
    // (undocumented)
    get query(): TypedDocumentNode<TData, TVariables>;
    // (undocumented)
    readonly queryName?: string;
    refetch(variables?: Partial<TVariables>): ObservableQuery.ResultPromise<ApolloClient.QueryResult<TData>>;
    reobserve(newOptions?: Partial<ObservableQuery.Options<TData, TVariables>>): ObservableQuery.ResultPromise<ApolloClient.QueryResult<MaybeMasked<TData>>>;
    // @internal @deprecated
    reset(): void;
    setVariables(variables: TVariables): Promise<ApolloClient.QueryResult<TData>>;
    startPolling(pollInterval: number): void;
    stop(): void;
    stopPolling(): void;
    subscribe: (observerOrNext: Partial<Observer<ObservableQuery.Result<MaybeMasked<TData>>>> | ((value: ObservableQuery.Result<MaybeMasked<TData>>) => void)) => Subscription;
    subscribeToMore<TSubscriptionData = TData, TSubscriptionVariables extends OperationVariables = TVariables>(options: ObservableQuery.SubscribeToMoreOptions<TData, TSubscriptionVariables, TSubscriptionData, TVariables>): () => void;
    updateQuery(mapFn: UpdateQueryMapFn<TData, TVariables>): void;
    get variables(): TVariables;
}

// @public (undocumented)
export type OnQueryUpdated<TResult> = (observableQuery: ObservableQuery<any>, diff: Cache_2.DiffResult<any>, lastDiff: Cache_2.DiffResult<any> | undefined) => boolean | TResult;

// @public @deprecated (undocumented)
export type Operation = ApolloLink.Operation;

// @public (undocumented)
export type OperationVariables = Record<string, any>;

// @public (undocumented)
export type OptimisticStoreItem = {
    id: string;
    data: NormalizedCacheObject;
    transaction: Transaction;
};

// @public (undocumented)
namespace OverridableTypes {
    // (undocumented)
    interface Complete extends HKT {
        // (undocumented)
        arg1: unknown;
        // (undocumented)
        return: this["arg1"];
    }
    // (undocumented)
    interface Defaults {
        // Warning: (ae-forgotten-export) The symbol "OverridableTypes" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        Complete: Complete;
        // Warning: (ae-forgotten-export) The symbol "OverridableTypes" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        Partial: Partial;
        // Warning: (ae-forgotten-export) The symbol "OverridableTypes" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        Streaming: Streaming;
    }
    // (undocumented)
    interface Partial extends HKT {
        // (undocumented)
        arg1: unknown;
        // (undocumented)
        return: DeepPartial<this["arg1"]>;
    }
    // (undocumented)
    interface Streaming extends HKT {
        // (undocumented)
        arg1: unknown;
        // (undocumented)
        return: this["arg1"];
    }
}

// @public (undocumented)
export function parseAndCheckHttpResponse(operations: ApolloLink.Operation | ApolloLink.Operation[]): (response: Response) => Promise<any>;

// @public (undocumented)
class Policies {
    constructor(config: {
        cache: InMemoryCache;
        dataIdFromObject?: KeyFieldsFunction;
        possibleTypes?: PossibleTypesMap;
        typePolicies?: TypePolicies;
    });
    // (undocumented)
    addPossibleTypes(possibleTypes: PossibleTypesMap): void;
    // (undocumented)
    addTypePolicies(typePolicies: TypePolicies): void;
    // (undocumented)
    readonly cache: InMemoryCache;
    // (undocumented)
    fragmentMatches(fragment: InlineFragmentNode | FragmentDefinitionNode, typename: string | undefined, result?: Record<string, any>, variables?: Record<string, any>): boolean;
    // (undocumented)
    getMergeFunction(parentTypename: string | undefined, fieldName: string, childTypename: string | undefined): FieldMergeFunction | undefined;
    // (undocumented)
    getReadFunction(typename: string | undefined, fieldName: string): FieldReadFunction | undefined;
    // Warning: (ae-forgotten-export) The symbol "FieldSpecifier" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getStoreFieldName(fieldSpec: FieldSpecifier): string;
    // (undocumented)
    hasKeyArgs(typename: string | undefined, fieldName: string): boolean;
    // (undocumented)
    identify(object: StoreObject, partialContext?: Partial<KeyFieldsContext>): [string?, StoreObject?];
    // Warning: (ae-forgotten-export) The symbol "ReadFieldOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readField<V = StoreValue>(options: ReadFieldOptions, context: ReadMergeModifyContext): SafeReadonly<V> | undefined;
    // (undocumented)
    readonly rootIdsByTypename: Record<string, string>;
    // (undocumented)
    readonly rootTypenamesById: Record<string, string>;
    // (undocumented)
    runMergeFunction(existing: StoreValue, incoming: StoreValue, { field, typename, merge }: MergeInfo, context: WriteContext, storage?: StorageType): any;
    // (undocumented)
    readonly usingPossibleTypes = false;
}

// @public (undocumented)
export type PossibleTypesMap = {
    [supertype: string]: string[];
};

// @public (undocumented)
namespace PreserveTypes {
    // (undocumented)
    type FragmentType<_TData> = never;
    // (undocumented)
    namespace HKTImplementation {
        // (undocumented)
        interface FragmentType extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: never;
        }
        // (undocumented)
        interface MaybeMasked extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: this["arg1"];
        }
        // (undocumented)
        interface Unmasked extends HKT {
            // (undocumented)
            arg1: unknown;
            // (undocumented)
            return: this["arg1"];
        }
    }
    // (undocumented)
    type MaybeMasked<TData> = TData;
    // (undocumented)
    interface TypeOverrides {
        // Warning: (ae-forgotten-export) The symbol "PreserveTypes" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        FragmentType: HKTImplementation.FragmentType;
        // (undocumented)
        MaybeMasked: HKTImplementation.MaybeMasked;
        // (undocumented)
        Unmasked: HKTImplementation.Unmasked;
    }
    // (undocumented)
    type Unmasked<TData> = TData;
}

// @internal @deprecated (undocumented)
type Primitive = null | undefined | string | number | boolean | symbol | bigint;

// @public (undocumented)
class QueryManager {
    // Warning: (ae-forgotten-export) The symbol "QueryManagerOptions" needs to be exported by the entry point index.d.ts
    constructor(options: QueryManagerOptions);
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    // (undocumented)
    broadcastQueries(): void;
    // (undocumented)
    get cache(): ApolloCache;
    // (undocumented)
    clearStore(options?: Cache_2.ResetOptions): Promise<void>;
    // (undocumented)
    readonly client: ApolloClient;
    readonly clientOptions: ApolloClient.Options;
    // (undocumented)
    readonly dataMasking: boolean;
    // (undocumented)
    readonly defaultContext: Partial<DefaultContext>;
    // (undocumented)
    defaultOptions: ApolloClient.DefaultOptions;
    // (undocumented)
    readonly documentTransform: DocumentTransform;
    // (undocumented)
    protected fetchCancelFns: Map<string, (error: any) => any>;
    // Warning: (ae-forgotten-export) The symbol "ObservableAndInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fetchObservableWithInfo<TData, TVariables extends OperationVariables>(options: ApolloClient.WatchQueryOptions<TData, TVariables>, { networkStatus, query, fetchQueryOperator, onCacheHit, observableQuery, }: {
        networkStatus?: NetworkStatus;
        query?: DocumentNode;
        fetchQueryOperator?: <T>(source: Observable<T>) => Observable<T>;
        onCacheHit?: () => void;
        observableQuery?: ObservableQuery<TData, TVariables> | undefined;
    }): ObservableAndInfo<TData>;
    // (undocumented)
    fetchQuery<TData, TVariables extends OperationVariables>(options: ApolloClient.WatchQueryOptions<TData, TVariables>, networkStatus?: NetworkStatus): Promise<ApolloClient.QueryResult<TData>>;
    // (undocumented)
    generateRequestId(): number;
    // Warning: (ae-forgotten-export) The symbol "TransformCacheEntry" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getDocumentInfo(document: DocumentNode): TransformCacheEntry;
    // (undocumented)
    getObservableQueries(include?: InternalRefetchQueriesInclude): Set<ObservableQuery<any, OperationVariables>>;
    // (undocumented)
    getVariables<TVariables extends OperationVariables>(document: DocumentNode, variables?: TVariables): TVariables;
    // (undocumented)
    readonly incrementalHandler: Incremental.Handler;
    // (undocumented)
    protected inFlightLinkObservables: Trie<{
        observable?: Observable<ApolloLink.Result<any>>;
        restart?: () => void;
    }>;
    // (undocumented)
    get link(): ApolloLink;
    // (undocumented)
    localState: LocalState | undefined;
    // Warning: (ae-forgotten-export) The symbol "MaskFragmentOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>): TData;
    // Warning: (ae-forgotten-export) The symbol "MaskOperationOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    maskOperation<TData = unknown>(options: MaskOperationOptions<TData>): MaybeMasked<TData>;
    // (undocumented)
    mutate<TData, TVariables extends OperationVariables, TCache extends ApolloCache>({ mutation, variables, optimisticResponse, updateQueries, refetchQueries, awaitRefetchQueries, update: updateWithProxyFn, onQueryUpdated, fetchPolicy, errorPolicy, keepRootFields, context, }: ApolloClient.MutateOptions<TData, TVariables, TCache> & {
        errorPolicy: ErrorPolicy;
        fetchPolicy: MutationFetchPolicy;
    }): Promise<ApolloClient.MutateResult<MaybeMasked<TData>>>;
    // (undocumented)
    mutationStore?: {
        [mutationId: string]: MutationStoreValue;
    };
    obsQueries: Set<ObservableQuery<any, any>>;
    prioritizeCacheValues: boolean;
    // (undocumented)
    query<TData, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.QueryOptions<TData, TVariables>): Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>;
    // (undocumented)
    refetchObservableQueries(includeStandby?: boolean): Promise<ApolloClient.QueryResult<any>[]>;
    // (undocumented)
    refetchQueries<TResult>({ updateCache, include, optimistic, removeOptimistic, onQueryUpdated, }: InternalRefetchQueriesOptions<ApolloCache, TResult>): InternalRefetchQueriesMap<TResult>;
    // (undocumented)
    readonly ssrMode: boolean;
    // (undocumented)
    startGraphQLSubscription<TData = unknown>(options: ApolloClient.SubscribeOptions<TData>): SubscriptionObservable<ApolloClient.SubscribeResult<TData>>;
    stop(): void;
    // (undocumented)
    transform(document: DocumentNode): DocumentNode;
    // (undocumented)
    watchQuery<TData, TVariables extends OperationVariables = OperationVariables>(options: ApolloClient.WatchQueryOptions<TData, TVariables>): ObservableQuery<TData, TVariables>;
}

// @public (undocumented)
interface QueryManagerOptions {
    // (undocumented)
    assumeImmutableResults: boolean;
    // (undocumented)
    client: ApolloClient;
    // (undocumented)
    clientOptions: ApolloClient.Options;
    // (undocumented)
    dataMasking: boolean;
    // (undocumented)
    defaultContext: Partial<DefaultContext> | undefined;
    // (undocumented)
    defaultOptions: ApolloClient.DefaultOptions;
    // (undocumented)
    documentTransform: DocumentTransform | null | undefined;
    // (undocumented)
    incrementalHandler: Incremental.Handler;
    // (undocumented)
    localState: LocalState | undefined;
    // (undocumented)
    onBroadcast: undefined | (() => void);
    // (undocumented)
    queryDeduplication: boolean;
    // (undocumented)
    ssrMode: boolean;
}

// @public (undocumented)
namespace QueryNotification {
    // (undocumented)
    type FromCache<TData> = NextNotification<ObservableQuery.Result<TData>> & {
        source: "cache";
    };
    // (undocumented)
    type FromNetwork<TData> = ObservableNotification<ObservableQuery.Result<TData>> & {
        source: "network";
    };
    // (undocumented)
    type NewNetworkStatus = NextNotification<{
        resetError?: boolean;
    }> & {
        source: "newNetworkStatus";
    };
    // (undocumented)
    type SetResult<TData> = NextNotification<ObservableQuery.Result<TData>> & {
        source: "setResult";
    };
    // Warning: (ae-forgotten-export) The symbol "QueryNotification" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "QueryNotification" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "QueryNotification" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "QueryNotification" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    type Value<TData> = FromCache<TData> | FromNetwork<TData> | NewNetworkStatus | SetResult<TData>;
}

// @public @deprecated (undocumented)
export type QueryOptions<TVariables extends OperationVariables = OperationVariables, TData = unknown> = ApolloClient.QueryOptions<TData, TVariables>;

// @public (undocumented)
type ReactiveListener<T> = (value: T) => any;

// @public (undocumented)
export interface ReactiveVar<T> {
    // (undocumented)
    (newValue?: T): T;
    // (undocumented)
    attachCache(cache: ApolloCache): this;
    // (undocumented)
    forgetCache(cache: ApolloCache): boolean;
    // Warning: (ae-forgotten-export) The symbol "ReactiveListener" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    onNextChange(listener: ReactiveListener<T>): () => void;
}

// @public (undocumented)
interface ReadFieldFunction {
    // (undocumented)
    <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;
    // (undocumented)
    <V = StoreValue>(fieldName: string, from?: StoreObject | Reference): SafeReadonly<V> | undefined;
}

// @public (undocumented)
interface ReadFieldOptions extends FieldSpecifier {
    // (undocumented)
    from?: StoreObject | Reference;
}

// @public (undocumented)
export interface ReadMergeModifyContext {
    // (undocumented)
    store: NormalizedCache;
    // (undocumented)
    variables?: OperationVariables;
    // (undocumented)
    varString?: string;
}

// @public (undocumented)
export type ReadQueryOptions = {
    store: NormalizedCache;
    query: DocumentNode;
    variables?: Object;
    previousResult?: any;
    rootId?: string;
    config?: ApolloReducerConfig;
};

// @public
export interface Reference {
    // (undocumented)
    readonly __ref: string;
}

// @public (undocumented)
export type RefetchQueriesInclude = RefetchQueryDescriptor[] | RefetchQueriesIncludeShorthand;

// @public (undocumented)
type RefetchQueriesIncludeShorthand = "all" | "active";

// @public @deprecated (undocumented)
export type RefetchQueriesOptions<TCache extends ApolloCache, TResult> = ApolloClient.RefetchQueriesOptions<TCache, TResult>;

// Warning: (ae-forgotten-export) The symbol "IsAny" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type RefetchQueriesPromiseResults<TResult> = IsAny<TResult> extends true ? any[] : TResult extends boolean ? ApolloClient.QueryResult<any>[] : TResult extends PromiseLike<infer U> ? U[] : TResult[];

// @public @deprecated (undocumented)
export type RefetchQueriesResult<TResult> = ApolloClient.RefetchQueriesResult<TResult>;

// @public (undocumented)
export type RefetchQueryDescriptor = string | DocumentNode;

// @public (undocumented)
export type RefetchWritePolicy = "merge" | "overwrite";

// @internal @deprecated (undocumented)
type RemoveIndexSignature<T> = {
    [K in keyof T as string extends K ? never : number extends K ? never : symbol extends K ? never : K]: T[K];
};

// @public @deprecated (undocumented)
export type RequestHandler = ApolloLink.RequestHandler;

export { resetCaches }

// @public (undocumented)
export function rewriteURIForGET(chosenURI: string, body: BaseHttpLink.Body): {
    parseError: unknown;
    newURI?: undefined;
} | {
    newURI: string;
    parseError?: undefined;
};

// @public (undocumented)
class Root extends EntityStore {
    constructor({ policies, resultCaching, seed, }: {
        policies: Policies;
        resultCaching?: boolean;
        seed?: NormalizedCacheObject;
    });
    // (undocumented)
    addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
    // (undocumented)
    getStorage(): StorageType;
    // (undocumented)
    removeLayer(): Root;
    // (undocumented)
    readonly storageTrie: Trie<StorageType>;
    // Warning: (ae-forgotten-export) The symbol "Stump" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly stump: Stump;
}

// @public (undocumented)
type SafeReadonly<T> = T extends object ? Readonly<T> : T;

// Warning: (ae-forgotten-export) The symbol "HttpConfig" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function selectHttpOptionsAndBody(operation: ApolloLink.Operation, fallbackConfig: HttpConfig, ...configs: Array<HttpConfig>): {
    options: HttpConfig & Record<string, any>;
    body: BaseHttpLink.Body;
};

// @public (undocumented)
export function selectHttpOptionsAndBodyInternal(operation: ApolloLink.Operation, printer: BaseHttpLink.Printer, ...configs: HttpConfig[]): {
    options: HttpConfig & Record<string, any>;
    body: BaseHttpLink.Body;
};

// @public (undocumented)
export const selectURI: (operation: ApolloLink.Operation, fallbackURI?: string | ((operation: ApolloLink.Operation) => string)) => any;

// @public (undocumented)
export namespace ServerError {
    // (undocumented)
    export namespace DocumentationTypes {
        // (undocumented)
        export interface InstanceProperties {
            readonly bodyText: string;
            readonly response: Response;
            readonly statusCode: number;
        }
    }
    // (undocumented)
    export interface Options {
        // (undocumented)
        bodyText: string;
        // (undocumented)
        response: Response;
    }
}

// @public
export class ServerError extends Error {
    constructor(message: string, options: ServerError.Options);
    readonly bodyText: string;
    static is(error: unknown): error is ServerError;
    readonly response: Response;
    readonly statusCode: number;
}

// @public (undocumented)
export namespace ServerParseError {
    // (undocumented)
    export namespace DocumentationTypes {
        // (undocumented)
        export interface InstanceProperties {
            readonly bodyText: string;
            readonly response: Response;
            readonly statusCode: number;
        }
    }
    // (undocumented)
    export interface Options {
        // (undocumented)
        bodyText: string;
        // (undocumented)
        response: Response;
    }
}

// @public
export class ServerParseError extends Error {
    constructor(originalParseError: unknown, options: ServerParseError.Options);
    readonly bodyText: string;
    static is(error: unknown): error is ServerParseError;
    readonly response: Response;
    readonly statusCode: number;
}

// Warning: (ae-forgotten-export) The symbol "VerbosityLevel" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function setLogVerbosity(level: VerbosityLevel): VerbosityLevel;

// @public @deprecated (undocumented)
export const split: typeof ApolloLink.split;

// @public (undocumented)
type StorageType = Record<string, any>;

// @public
export interface StoreObject {
    // (undocumented)
    [storeFieldName: string]: StoreValue;
    // (undocumented)
    __typename?: string;
}

// Warning: (ae-forgotten-export) The symbol "AsStoreObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type StoreObjectValueMaybeReference<StoreVal> = StoreVal extends ReadonlyArray<Record<string, any>> ? StoreVal extends ReadonlyArray<infer Item> ? [
Item
] extends [Record<string, any>] ? ReadonlyArray<AsStoreObject<Item> | Reference> : never : never : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference : StoreVal;

// @public
export type StoreValue = number | string | string[] | Reference | Reference[] | null | undefined | void | Object;

// @public (undocumented)
class Stump extends Layer {
    constructor(root: Root);
    // (undocumented)
    merge(older: string | StoreObject, newer: string | StoreObject): void;
    // (undocumented)
    removeLayer(): this;
}

// @public (undocumented)
export interface SubscribeToMoreFunction<TData, TVariables extends OperationVariables = OperationVariables> {
    // (undocumented)
    <TSubscriptionData = TData, TSubscriptionVariables extends OperationVariables = TVariables>(options: ObservableQuery.SubscribeToMoreOptions<TData, TSubscriptionVariables, TSubscriptionData, TVariables>): () => void;
}

// @public @deprecated (undocumented)
export type SubscribeToMoreOptions<TData = unknown, TSubscriptionVariables extends OperationVariables = OperationVariables, TSubscriptionData = TData, TVariables extends OperationVariables = TSubscriptionVariables> = ObservableQuery.SubscribeToMoreOptions<TData, TSubscriptionVariables, TSubscriptionData, TVariables>;

// @public (undocumented)
export type SubscribeToMoreUpdateQueryFn<TData = unknown, TVariables extends OperationVariables = OperationVariables, TSubscriptionData = TData> = {
    (
    unsafePreviousData: DeepPartial<Unmasked<TData>>, options: UpdateQueryOptions<TData, TVariables> & {
        subscriptionData: {
            data: Unmasked<TSubscriptionData>;
        };
    }): Unmasked<TData> | void;
};

// @public
export interface SubscriptionObservable<T> extends Observable<T> {
    restart: () => void;
}

// @public @deprecated (undocumented)
export type SubscriptionOptions<TVariables extends OperationVariables = OperationVariables, TData = unknown> = ApolloClient.SubscribeOptions<TData, TVariables>;

// @public (undocumented)
type ToReferenceFunction = (objOrIdOrRef: StoreObject | string | Reference, mergeIntoStore?: boolean) => Reference | undefined;

// @public (undocumented)
export type Transaction = (c: ApolloCache) => void;

// @public (undocumented)
interface TransformCacheEntry {
    // (undocumented)
    asQuery: DocumentNode;
    // (undocumented)
    clientQuery: DocumentNode | null;
    // (undocumented)
    defaultVars: OperationVariables;
    // (undocumented)
    hasClientExports: boolean;
    // (undocumented)
    hasForcedResolvers: boolean;
    // (undocumented)
    hasIncrementalDirective: boolean;
    // (undocumented)
    hasNonreactiveDirective: boolean;
    // (undocumented)
    nonReactiveQuery: DocumentNode;
    // (undocumented)
    operationType: OperationTypeNode | undefined;
    // (undocumented)
    serverQuery: DocumentNode | null;
    // (undocumented)
    violation?: Error | undefined;
}

// @public (undocumented)
type TransformFn = (document: DocumentNode) => DocumentNode;

export { TypedDocumentNode }

// @public (undocumented)
export interface TypeOverrides {
}

// @public (undocumented)
export type TypePolicies = {
    [__typename: string]: TypePolicy;
};

// @public (undocumented)
export type TypePolicy = {
    keyFields?: KeySpecifier | KeyFieldsFunction | false;
    merge?: FieldMergeFunction | boolean;
    queryType?: true;
    mutationType?: true;
    subscriptionType?: true;
    fields?: {
        [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;
    };
};

// @public
export class UnconventionalError extends Error {
    constructor(errorType: unknown);
    static is(error: unknown): error is UnconventionalError;
}

// @public
export type Unmasked<TData> = ApplyHKTImplementationWithDefault<TypeOverrides, "Unmasked", PreserveTypes.TypeOverrides, TData>;

// @public (undocumented)
export interface UpdateQueryMapFn<TData = unknown, TVariables extends OperationVariables = OperationVariables> {
    // (undocumented)
    (
    unsafePreviousData: DeepPartial<Unmasked<TData>>, options: UpdateQueryOptions<TData, TVariables>): Unmasked<TData> | void;
}

// @public (undocumented)
export type UpdateQueryOptions<TData, TVariables extends OperationVariables> = {
    variables?: TVariables;
} & ({
    complete: true;
    previousData: Unmasked<TData>;
} | {
    complete: false;
    previousData: DeepPartial<Unmasked<TData>> | undefined;
});

// @internal @deprecated (undocumented)
type VariablesOption<TVariables extends OperationVariables> = {} extends TVariables ? {
    variables?: TVariables;
} : {
    variables: TVariables;
};

// @internal @deprecated
const variablesUnknownSymbol: unique symbol;

// Warning: (ae-forgotten-export) The symbol "verbosityLevels" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type VerbosityLevel = (typeof verbosityLevels)[number];

// @public (undocumented)
const verbosityLevels: readonly ["debug", "log", "warn", "error", "silent"];

// @public (undocumented)
export const version: string;

// @public @deprecated (undocumented)
export type WatchFragmentOptions<TData = unknown, TVariables extends OperationVariables = OperationVariables> = ApolloCache.WatchFragmentOptions<TData, TVariables>;

// @public @deprecated (undocumented)
export type WatchFragmentResult<TData> = ApolloCache.WatchFragmentResult<TData>;

// @public (undocumented)
export type WatchQueryFetchPolicy = FetchPolicy | "cache-and-network" | "standby";

// @public @deprecated (undocumented)
export type WatchQueryOptions<TVariables extends OperationVariables = OperationVariables, TData = unknown> = ApolloClient.WatchQueryOptions<TData, TVariables>;

// @public (undocumented)
interface WriteContext extends ReadMergeModifyContext {
    // (undocumented)
    clientOnly: boolean;
    // (undocumented)
    deferred: boolean;
    // Warning: (ae-forgotten-export) The symbol "FlavorableWriteContext" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    flavors: Map<string, FlavorableWriteContext>;
    // (undocumented)
    readonly fragmentMap: FragmentMap;
    // (undocumented)
    incomingById: Map<string, {
        storeObject: StoreObject;
        mergeTree?: MergeTree;
        fieldNodeSet: Set<FieldNode>;
    }>;
    // Warning: (ae-forgotten-export) The symbol "FragmentMapFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    lookupFragment: FragmentMapFunction;
    // (undocumented)
    merge<T>(existing: T, incoming: T): T;
    // (undocumented)
    overwrite: boolean;
    // (undocumented)
    readonly written: {
        [dataId: string]: SelectionSetNode[];
    };
}

// Warnings were encountered during analysis:
//
// src/cache/core/cache.ts:94:9 - (ae-forgotten-export) The symbol "MissingTree" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:98:3 - (ae-forgotten-export) The symbol "FragmentMap" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:167:3 - (ae-forgotten-export) The symbol "KeySpecifier" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:167:3 - (ae-forgotten-export) The symbol "KeyArgsFunction" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/types.ts:134:3 - (ae-forgotten-export) The symbol "KeyFieldsFunction" needs to be exported by the entry point index.d.ts
// src/core/ApolloClient.ts:162:5 - (ae-forgotten-export) The symbol "IgnoreModifier" needs to be exported by the entry point index.d.ts
// src/core/ApolloClient.ts:356:5 - (ae-forgotten-export) The symbol "NextFetchPolicyContext" needs to be exported by the entry point index.d.ts
// src/core/ObservableQuery.ts:363:5 - (ae-forgotten-export) The symbol "QueryManager" needs to be exported by the entry point index.d.ts
// src/core/QueryManager.ts:180:5 - (ae-forgotten-export) The symbol "MutationStoreValue" needs to be exported by the entry point index.d.ts
// src/local-state/LocalState.ts:147:5 - (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts
// src/local-state/LocalState.ts:200:7 - (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts
// src/local-state/LocalState.ts:243:7 - (ae-forgotten-export) The symbol "LocalState" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
