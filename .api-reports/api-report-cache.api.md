## API Report File for "@apollo/client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { ApolloCache as ApolloCache_2 } from '@apollo/client';
import type { AsStoreObject } from '@apollo/client/utilities';
import { canonicalStringify } from '@apollo/client/utilities';
import type { DeepPartial } from '@apollo/client/utilities';
import type { DocumentNode } from 'graphql';
import type { FieldNode } from 'graphql';
import type { FragmentDefinitionNode } from 'graphql';
import type { FragmentMap } from '@apollo/client/utilities';
import type { FragmentMapFunction } from '@apollo/client/utilities';
import type { FragmentType } from '@apollo/client/masking';
import { getApolloCacheMemoryInternals } from '@apollo/client/utilities/internal';
import { getInMemoryCacheMemoryInternals } from '@apollo/client/utilities/internal';
import type { InlineFragmentNode } from 'graphql';
import { isReference } from '@apollo/client/utilities';
import { makeReference } from '@apollo/client/utilities';
import type { MaybeMasked } from '@apollo/client/masking';
import type { NoInfer as NoInfer_2 } from '@apollo/client/utilities';
import { Observable } from 'rxjs';
import type { OperationVariables } from '@apollo/client';
import { Reference } from '@apollo/client/utilities';
import type { SelectionSetNode } from 'graphql';
import type { StoreObject } from '@apollo/client/utilities';
import type { StoreValue } from '@apollo/client/utilities';
import { Trie } from '@wry/trie';
import type { TypedDocumentNode } from '@graphql-typed-document-node/core';
import type { TypedDocumentNode as TypedDocumentNode_2 } from '@apollo/client';
import type { Unmasked } from '@apollo/client/masking';

// Warning: (ae-forgotten-export) The symbol "StoreObjectValueMaybeReference" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<Entity[keyof Entity] extends infer Value ? StoreObjectValueMaybeReference<Exclude<Value, undefined>> : never>;

// @public (undocumented)
export abstract class ApolloCache implements DataProxy {
    // (undocumented)
    readonly assumeImmutableResults: boolean;
    // (undocumented)
    batch<U>(options: Cache_2.BatchOptions<this, U>): U;
    abstract diff<TData = unknown, TVariables extends OperationVariables = OperationVariables>(query: Cache_2.DiffOptions<TData, TVariables>): Cache_2.DiffResult<TData>;
    // (undocumented)
    abstract evict(options: Cache_2.EvictOptions): boolean;
    abstract extract(optimistic?: boolean): unknown;
    // (undocumented)
    fragmentMatches?(fragment: InlineFragmentNode, typename: string): boolean;
    // (undocumented)
    gc(): string[];
    // @internal
    getMemoryInternals?: typeof getApolloCacheMemoryInternals;
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // (undocumented)
    lookupFragment(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_2.ModifyOptions<Entity>): boolean;
    // (undocumented)
    abstract performTransaction(transaction: Transaction, optimisticId?: string | null): void;
    // (undocumented)
    abstract read<TData = unknown, TVariables = OperationVariables>(query: Cache_2.ReadOptions<TVariables, TData>): Unmasked<TData> | null;
    // (undocumented)
    readFragment<TData = unknown, TVariables = OperationVariables>(options: Cache_2.ReadFragmentOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    // (undocumented)
    readQuery<TData = unknown, TVariables = OperationVariables>(options: Cache_2.ReadQueryOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    // (undocumented)
    recordOptimisticTransaction(transaction: Transaction, optimisticId: string): void;
    // (undocumented)
    abstract removeOptimistic(id: string): void;
    // (undocumented)
    abstract reset(options?: Cache_2.ResetOptions): Promise<void>;
    abstract restore(serializedState: unknown): this;
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
    // (undocumented)
    transformForLink(document: DocumentNode): DocumentNode;
    // (undocumented)
    updateFragment<TData = unknown, TVariables = OperationVariables>(options: Cache_2.UpdateFragmentOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    updateQuery<TData = unknown, TVariables = OperationVariables>(options: Cache_2.UpdateQueryOptions<TData, TVariables>, update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void): Unmasked<TData> | null;
    // (undocumented)
    abstract watch<TData = unknown, TVariables = OperationVariables>(watch: Cache_2.WatchOptions<TData, TVariables>): () => void;
    watchFragment<TData = unknown, TVars = OperationVariables>(options: WatchFragmentOptions<TData, TVars>): Observable<WatchFragmentResult<TData>>;
    // (undocumented)
    abstract write<TData = unknown, TVariables = OperationVariables>(write: Cache_2.WriteOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeFragment<TData = unknown, TVariables = OperationVariables>({ id, data, fragment, fragmentName, ...options }: Cache_2.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    // (undocumented)
    writeQuery<TData = unknown, TVariables = OperationVariables>({ id, data, ...options }: Cache_2.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// @public (undocumented)
export type ApolloReducerConfig = {
    dataIdFromObject?: KeyFieldsFunction;
};

// @public (undocumented)
type BroadcastOptions = Pick<Cache_2.BatchOptions<InMemoryCache>, "optimistic" | "onWatchUpdated">;

// @public (undocumented)
namespace Cache_2 {
    // (undocumented)
    interface BatchOptions<TCache extends ApolloCache, TUpdateResult = void> {
        // (undocumented)
        onWatchUpdated?: (this: TCache, watch: Cache_2.WatchOptions, diff: Cache_2.DiffResult<any>, lastDiff?: Cache_2.DiffResult<any> | undefined) => any;
        // (undocumented)
        optimistic?: string | boolean;
        // (undocumented)
        removeOptimistic?: string;
        // (undocumented)
        update(cache: TCache): TUpdateResult;
    }
    // (undocumented)
    interface DiffOptions<TData = unknown, TVariables = OperationVariables> extends Omit<ReadOptions<TVariables, TData>, "rootId"> {
    }
    // (undocumented)
    interface EvictOptions {
        // (undocumented)
        args?: Record<string, any>;
        // (undocumented)
        broadcast?: boolean;
        // (undocumented)
        fieldName?: string;
        // (undocumented)
        id?: string;
    }
    // (undocumented)
    interface ModifyOptions<Entity extends Record<string, any> = Record<string, any>> {
        // (undocumented)
        broadcast?: boolean;
        // Warning: (ae-forgotten-export) The symbol "AllFieldsModifier" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        fields: Modifiers<Entity> | AllFieldsModifier<Entity>;
        // (undocumented)
        id?: string;
        // (undocumented)
        optimistic?: boolean;
    }
    // (undocumented)
    interface ReadOptions<TVariables = OperationVariables, TData = unknown> extends DataProxy.Query<TVariables, TData> {
        // (undocumented)
        optimistic: boolean;
        // (undocumented)
        previousResult?: any;
        // (undocumented)
        returnPartialData?: boolean;
        // (undocumented)
        rootId?: string;
    }
    // (undocumented)
    interface ResetOptions {
        // (undocumented)
        discardWatches?: boolean;
    }
    // (undocumented)
    type WatchCallback<TData = unknown> = (diff: Cache_2.DiffResult<TData>, lastDiff?: Cache_2.DiffResult<TData>) => void;
    // (undocumented)
    interface WatchOptions<TData = unknown, TVariables = OperationVariables> extends DiffOptions<TData, TVariables> {
        // (undocumented)
        callback: WatchCallback<TData>;
        // (undocumented)
        immediate?: boolean;
        // (undocumented)
        lastDiff?: DiffResult<TData>;
        // (undocumented)
        watcher?: object;
    }
    // (undocumented)
    interface WriteOptions<TData = unknown, TVariables = OperationVariables> extends Omit<DataProxy.Query<TVariables, TData>, "id">, Omit<DataProxy.WriteOptions<TData>, "data"> {
        // (undocumented)
        dataId?: string;
        // (undocumented)
        result: Unmasked<TData>;
    }
    import DiffResult = DataProxy.DiffResult;
    import ReadQueryOptions = DataProxy.ReadQueryOptions;
    import ReadFragmentOptions = DataProxy.ReadFragmentOptions;
    import WriteQueryOptions = DataProxy.WriteQueryOptions;
    import WriteFragmentOptions = DataProxy.WriteFragmentOptions;
    import UpdateQueryOptions = DataProxy.UpdateQueryOptions;
    import UpdateFragmentOptions = DataProxy.UpdateFragmentOptions;
    import Fragment = DataProxy.Fragment;
}
export { Cache_2 as Cache }

// @public (undocumented)
class CacheGroup {
    constructor(caching: boolean, parent?: CacheGroup | null);
    // (undocumented)
    readonly caching: boolean;
    // (undocumented)
    depend(dataId: string, storeFieldName: string): void;
    // (undocumented)
    dirty(dataId: string, storeFieldName: string): void;
    // (undocumented)
    keyMaker: Trie<object>;
    // (undocumented)
    resetCaching(): void;
}

// @public (undocumented)
export const cacheSlot: {
    readonly id: string;
    hasValue(): boolean;
    getValue(): ApolloCache_2 | undefined;
    withValue<TResult, TArgs extends any[], TThis = any>(value: ApolloCache_2, callback: (this: TThis, ...args: TArgs) => TResult, args?: TArgs | undefined, thisArg?: TThis | undefined): TResult;
};

export { canonicalStringify }

// @public (undocumented)
type CanReadFunction = (value: StoreValue) => boolean;

// @public (undocumented)
export function createFragmentRegistry(...fragments: DocumentNode[]): FragmentRegistryAPI;

// @public (undocumented)
export namespace DataProxy {
    // (undocumented)
    export type DiffResult<TData> = {
        result: TData;
        complete: true;
        missing?: never;
        fromOptimisticTransaction?: boolean;
    } | {
        result: DeepPartial<TData> | null;
        complete: false;
        missing?: MissingFieldError;
        fromOptimisticTransaction?: boolean;
    };
    // (undocumented)
    export interface Fragment<TVariables, TData> {
        fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;
        fragmentName?: string;
        id?: string;
        variables?: TVariables;
    }
    // (undocumented)
    export interface Query<TVariables, TData> {
        id?: string;
        query: DocumentNode | TypedDocumentNode<TData, TVariables>;
        variables?: TVariables;
    }
    // (undocumented)
    export interface ReadFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData> {
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // (undocumented)
    export interface ReadQueryOptions<TData, TVariables> extends Query<TVariables, TData> {
        optimistic?: boolean;
        returnPartialData?: boolean;
    }
    // (undocumented)
    export interface UpdateFragmentOptions<TData, TVariables> extends Omit<ReadFragmentOptions<TData, TVariables> & WriteFragmentOptions<TData, TVariables>, "data"> {
    }
    // (undocumented)
    export interface UpdateQueryOptions<TData, TVariables> extends Omit<ReadQueryOptions<TData, TVariables> & WriteQueryOptions<TData, TVariables>, "data"> {
    }
    // (undocumented)
    export interface WriteFragmentOptions<TData, TVariables> extends Fragment<TVariables, TData>, WriteOptions<TData> {
    }
    // (undocumented)
    export interface WriteOptions<TData> {
        broadcast?: boolean;
        data: Unmasked<TData>;
        overwrite?: boolean;
    }
    // (undocumented)
    export interface WriteQueryOptions<TData, TVariables> extends Query<TVariables, TData>, WriteOptions<TData> {
    }
}

// @public
export interface DataProxy {
    readFragment<TData = unknown, TVariables = OperationVariables>(options: DataProxy.ReadFragmentOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    readQuery<TData = unknown, TVariables = OperationVariables>(options: DataProxy.ReadQueryOptions<TData, TVariables>, optimistic?: boolean): Unmasked<TData> | null;
    writeFragment<TData = unknown, TVariables = OperationVariables>(options: DataProxy.WriteFragmentOptions<TData, TVariables>): Reference | undefined;
    writeQuery<TData = unknown, TVariables = OperationVariables>(options: DataProxy.WriteQueryOptions<TData, TVariables>): Reference | undefined;
}

// Warning: (ae-forgotten-export) The symbol "KeyFieldsContext" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function defaultDataIdFromObject({ __typename, id, _id }: Readonly<StoreObject>, context?: KeyFieldsContext): string | undefined;

// @public (undocumented)
interface DeleteModifier {
    // (undocumented)
    [_deleteModifier]: true;
}

// @public (undocumented)
const _deleteModifier: unique symbol;

// @public (undocumented)
export type DiffQueryAgainstStoreOptions = ReadQueryOptions & {
    returnPartialData?: boolean;
};

// @public (undocumented)
export abstract class EntityStore implements NormalizedCache {
    constructor(policies: Policies, group: CacheGroup);
    // Warning: (ae-forgotten-export) The symbol "Layer" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
    // Warning: (ae-forgotten-export) The symbol "CanReadFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    clear(): void;
    // (undocumented)
    protected data: NormalizedCacheObject;
    // (undocumented)
    delete(dataId: string, fieldName?: string, args?: Record<string, any>): boolean;
    // (undocumented)
    evict(options: Cache_2.EvictOptions, limit: EntityStore): boolean;
    // (undocumented)
    extract(): NormalizedCacheObject;
    // (undocumented)
    findChildRefIds(dataId: string): Record<string, true>;
    // (undocumented)
    gc(): string[];
    // (undocumented)
    get(dataId: string, fieldName: string): StoreValue;
    // Warning: (ae-forgotten-export) The symbol "SafeReadonly" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getFieldValue: <T = StoreValue>(objectOrReference: StoreObject | Reference | undefined, storeFieldName: string) => SafeReadonly<T>;
    // (undocumented)
    getRootIdSet(ids?: Set<string>): Set<string>;
    // Warning: (ae-forgotten-export) The symbol "StorageType" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    abstract getStorage(idOrObj: string | StoreObject, ...storeFieldNames: (string | number)[]): StorageType;
    // Warning: (ae-forgotten-export) The symbol "CacheGroup" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly group: CacheGroup;
    // (undocumented)
    has(dataId: string): boolean;
    // (undocumented)
    protected lookup(dataId: string, dependOnExistence?: boolean): StoreObject | undefined;
    makeCacheKey(document: DocumentNode, callback: Cache_2.WatchCallback<any>, details: string): object;
    makeCacheKey(selectionSet: SelectionSetNode, parent: string | StoreObject, varString: string | undefined): object;
    makeCacheKey(field: FieldNode, array: readonly any[], varString: string | undefined): object;
    // @deprecated (undocumented)
    makeCacheKey(...args: any[]): object;
    // (undocumented)
    merge(older: string | StoreObject, newer: StoreObject | string): void;
    // (undocumented)
    modify(dataId: string, fields: Modifier<any> | Modifiers<Record<string, any>>): boolean;
    // (undocumented)
    readonly policies: Policies;
    // (undocumented)
    release(rootId: string): number;
    // (undocumented)
    abstract removeLayer(layerId: string): EntityStore;
    // (undocumented)
    replace(newData: NormalizedCacheObject | null): void;
    // (undocumented)
    retain(rootId: string): number;
    // (undocumented)
    get supportsResultCaching(): boolean;
    // (undocumented)
    toObject(): NormalizedCacheObject;
    // Warning: (ae-forgotten-export) The symbol "ToReferenceFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    toReference: ToReferenceFunction;
}

// @public (undocumented)
export namespace EntityStore {
    // (undocumented)
    export class Root extends EntityStore {
        constructor({ policies, resultCaching, seed, }: {
            policies: Policies;
            resultCaching?: boolean;
            seed?: NormalizedCacheObject;
        });
        // (undocumented)
        addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
        // (undocumented)
        getStorage(): StorageType;
        // (undocumented)
        removeLayer(): Root;
        // (undocumented)
        readonly storageTrie: Trie<StorageType>;
        // Warning: (ae-forgotten-export) The symbol "Stump" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        readonly stump: Stump;
    }
}

// @public (undocumented)
export interface FieldFunctionOptions<TArgs = Record<string, any>, TVars = Record<string, any>> {
    // (undocumented)
    args: TArgs | null;
    // (undocumented)
    cache: InMemoryCache;
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    field: FieldNode | null;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    isReference: typeof isReference;
    // Warning: (ae-forgotten-export) The symbol "MergeObjectsFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mergeObjects: MergeObjectsFunction;
    // Warning: (ae-forgotten-export) The symbol "ReadFieldFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readField: ReadFieldFunction;
    // (undocumented)
    storage: StorageType;
    // (undocumented)
    storeFieldName: string;
    // (undocumented)
    toReference: ToReferenceFunction;
    // (undocumented)
    variables?: TVars;
}

// @public (undocumented)
export type FieldMergeFunction<TExisting = any, TIncoming = TExisting, TOptions extends FieldFunctionOptions = FieldFunctionOptions> = (existing: SafeReadonly<TExisting> | undefined, incoming: SafeReadonly<TIncoming>, options: TOptions) => SafeReadonly<TExisting>;

// @public (undocumented)
export function fieldNameFromStoreName(storeFieldName: string): string;

// @public (undocumented)
export type FieldPolicy<TExisting = any, TIncoming = TExisting, TReadResult = TIncoming, TOptions extends FieldFunctionOptions = FieldFunctionOptions> = {
    keyArgs?: KeySpecifier | KeyArgsFunction | false;
    read?: FieldReadFunction<TExisting, TReadResult, TOptions>;
    merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;
};

// @public (undocumented)
export type FieldReadFunction<TExisting = any, TReadResult = TExisting, TOptions extends FieldFunctionOptions = FieldFunctionOptions> = (existing: SafeReadonly<TExisting> | undefined, options: TOptions) => TReadResult | undefined;

// @public (undocumented)
interface FieldSpecifier {
    // (undocumented)
    args?: Record<string, any>;
    // (undocumented)
    field?: FieldNode;
    // (undocumented)
    fieldName: string;
    // (undocumented)
    typename?: string;
    // (undocumented)
    variables?: Record<string, any>;
}

// @public (undocumented)
type FieldValueGetter = EntityStore["getFieldValue"];

// Warning: (ae-forgotten-export) The symbol "WriteContext" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type FlavorableWriteContext = Pick<WriteContext, "clientOnly" | "deferred" | "flavors">;

// @public (undocumented)
export interface FragmentRegistryAPI {
    // (undocumented)
    lookup(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    register(...fragments: DocumentNode[]): this;
    // (undocumented)
    resetCaches(): void;
    // (undocumented)
    transform<D extends DocumentNode>(document: D): D;
}

// @public (undocumented)
export type IdGetter = (value: IdGetterObj) => string | undefined;

// @public (undocumented)
export interface IdGetterObj extends Object {
    // (undocumented)
    __typename?: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    _id?: string;
}

// @public (undocumented)
export class InMemoryCache extends ApolloCache {
    constructor(config?: InMemoryCacheConfig);
    // (undocumented)
    readonly assumeImmutableResults = true;
    // (undocumented)
    batch<TUpdateResult>(options: Cache_2.BatchOptions<InMemoryCache, TUpdateResult>): TUpdateResult;
    // Warning: (ae-forgotten-export) The symbol "BroadcastOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected broadcastWatches(options?: BroadcastOptions): void;
    // (undocumented)
    protected config: InMemoryCacheConfig;
    // (undocumented)
    diff<TData = unknown, TVariables extends OperationVariables = OperationVariables>(options: Cache_2.DiffOptions<TData, TVariables>): Cache_2.DiffResult<TData>;
    // (undocumented)
    evict(options: Cache_2.EvictOptions): boolean;
    // (undocumented)
    extract(optimistic?: boolean): NormalizedCacheObject;
    // (undocumented)
    fragmentMatches(fragment: InlineFragmentNode, typename: string): boolean;
    // (undocumented)
    gc(options?: {
        resetResultCache?: boolean;
    }): string[];
    // @internal
    getMemoryInternals?: typeof getInMemoryCacheMemoryInternals;
    // (undocumented)
    identify(object: StoreObject | Reference): string | undefined;
    // (undocumented)
    lookupFragment(fragmentName: string): FragmentDefinitionNode | null;
    // (undocumented)
    readonly makeVar: typeof makeVar;
    // (undocumented)
    modify<Entity extends Record<string, any> = Record<string, any>>(options: Cache_2.ModifyOptions<Entity>): boolean;
    // (undocumented)
    performTransaction(update: (cache: InMemoryCache) => any, optimisticId?: string | null): any;
    // (undocumented)
    readonly policies: Policies;
    // (undocumented)
    read<TData = unknown>(options: Cache_2.ReadOptions<OperationVariables, TData> & {
        returnPartialData: true;
    }): TData | DeepPartial<TData> | null;
    // (undocumented)
    read<TData = unknown>(options: Cache_2.ReadOptions<OperationVariables, TData>): TData | null;
    // (undocumented)
    release(rootId: string, optimistic?: boolean): number;
    // (undocumented)
    removeOptimistic(idToRemove: string): void;
    // (undocumented)
    reset(options?: Cache_2.ResetOptions): Promise<void>;
    // (undocumented)
    restore(data: NormalizedCacheObject): this;
    // (undocumented)
    retain(rootId: string, optimistic?: boolean): number;
    // (undocumented)
    transformDocument(document: DocumentNode): DocumentNode;
    // (undocumented)
    watch<TData = unknown, TVariables = OperationVariables>(watch: Cache_2.WatchOptions<TData, TVariables>): () => void;
    // (undocumented)
    write<TData = unknown, TVariables = OperationVariables>(options: Cache_2.WriteOptions<TData, TVariables>): Reference | undefined;
}

// @public (undocumented)
export interface InMemoryCacheConfig extends ApolloReducerConfig {
    // (undocumented)
    fragments?: FragmentRegistryAPI;
    // (undocumented)
    possibleTypes?: PossibleTypesMap;
    // @deprecated (undocumented)
    resultCacheMaxSize?: number;
    // (undocumented)
    resultCaching?: boolean;
    // (undocumented)
    typePolicies?: TypePolicies;
}

// @public (undocumented)
interface InvalidateModifier {
    // (undocumented)
    [_invalidateModifier]: true;
}

// @public (undocumented)
const _invalidateModifier: unique symbol;

export { isReference }

// @public (undocumented)
type KeyArgsFunction = (args: Record<string, any> | null, context: {
    typename: string;
    fieldName: string;
    field: FieldNode | null;
    variables?: Record<string, any>;
}) => KeySpecifier | false | ReturnType<IdGetter>;

// @public (undocumented)
type KeyFieldsContext = {
    typename: string | undefined;
    storeObject: StoreObject;
    readField: ReadFieldFunction;
    selectionSet?: SelectionSetNode;
    fragmentMap?: FragmentMap;
    keyObject?: Record<string, any>;
};

// @public (undocumented)
type KeyFieldsFunction = (object: Readonly<StoreObject>, context: KeyFieldsContext) => KeySpecifier | false | ReturnType<IdGetter>;

// @public (undocumented)
type KeySpecifier = ReadonlyArray<string | KeySpecifier>;

// @public (undocumented)
class Layer extends EntityStore {
    constructor(id: string, parent: EntityStore, replay: (layer: EntityStore) => any, group: CacheGroup);
    // (undocumented)
    addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer;
    // (undocumented)
    findChildRefIds(dataId: string): Record<string, true>;
    // (undocumented)
    getStorage(...args: Parameters<EntityStore["getStorage"]>): StorageType;
    // (undocumented)
    readonly group: CacheGroup;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly parent: EntityStore;
    // (undocumented)
    removeLayer(layerId: string): EntityStore;
    // (undocumented)
    readonly replay: (layer: EntityStore) => any;
    // (undocumented)
    toObject(): NormalizedCacheObject;
}

export { makeReference }

// @public (undocumented)
export function makeVar<T>(value: T): ReactiveVar<T>;

// @public (undocumented)
export interface MergeInfo {
    // (undocumented)
    field: FieldNode;
    // (undocumented)
    merge: FieldMergeFunction;
    // (undocumented)
    typename: string | undefined;
}

// @public (undocumented)
type MergeObjectsFunction = <T extends StoreObject | Reference>(existing: T, incoming: T) => T;

// @public (undocumented)
export interface MergeTree {
    // (undocumented)
    info?: MergeInfo;
    // (undocumented)
    map: Map<string | number, MergeTree>;
}

// @public (undocumented)
export class MissingFieldError extends Error {
    constructor(message: string, path: MissingTree | Array<string | number>, query: DocumentNode, variables?: Record<string, any> | undefined);
    // (undocumented)
    readonly message: string;
    // (undocumented)
    readonly missing: MissingTree;
    // (undocumented)
    readonly path: MissingTree | Array<string | number>;
    // (undocumented)
    readonly query: DocumentNode;
    // (undocumented)
    readonly variables?: Record<string, any> | undefined;
}

// @public (undocumented)
export type MissingTree = string | {
    readonly [key: string]: MissingTree;
};

// Warning: (ae-forgotten-export) The symbol "DeleteModifier" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "InvalidateModifier" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Modifier<T> = (value: T, details: ModifierDetails) => DeepPartial<T> | DeleteModifier | InvalidateModifier | undefined;

// @public (undocumented)
export type ModifierDetails = {
    DELETE: DeleteModifier;
    INVALIDATE: InvalidateModifier;
    fieldName: string;
    storeFieldName: string;
    readField: ReadFieldFunction;
    canRead: CanReadFunction;
    isReference: typeof isReference;
    toReference: ToReferenceFunction;
    storage: StorageType;
};

// @public (undocumented)
export type Modifiers<T extends Record<string, any> = Record<string, unknown>> = Partial<{
    [FieldName in keyof T]: Modifier<StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>>;
}>;

// @public
export interface NormalizedCache {
    // (undocumented)
    canRead: CanReadFunction;
    // (undocumented)
    clear(): void;
    // (undocumented)
    delete(dataId: string, fieldName?: string): boolean;
    // (undocumented)
    get(dataId: string, fieldName: string): StoreValue;
    // Warning: (ae-forgotten-export) The symbol "FieldValueGetter" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getFieldValue: FieldValueGetter;
    // (undocumented)
    getStorage(idOrObj: string | StoreObject, ...storeFieldNames: (string | number)[]): StorageType;
    // (undocumented)
    has(dataId: string): boolean;
    // (undocumented)
    merge(olderId: string, newerObject: StoreObject): void;
    // (undocumented)
    merge(olderObject: StoreObject, newerId: string): void;
    // (undocumented)
    modify<Entity extends Record<string, any>>(dataId: string, fields: Modifiers<Entity> | AllFieldsModifier<Entity>): boolean;
    // (undocumented)
    release(rootId: string): number;
    replace(newData: NormalizedCacheObject): void;
    retain(rootId: string): number;
    toObject(): NormalizedCacheObject;
    // (undocumented)
    toReference: ToReferenceFunction;
}

// @public
export interface NormalizedCacheObject {
    // (undocumented)
    [dataId: string]: StoreObject | undefined;
    // (undocumented)
    __META?: {
        extraRootIds: string[];
    };
}

// @public (undocumented)
export type OptimisticStoreItem = {
    id: string;
    data: NormalizedCacheObject;
    transaction: Transaction;
};

// @public (undocumented)
export class Policies {
    constructor(config: {
        cache: InMemoryCache;
        dataIdFromObject?: KeyFieldsFunction;
        possibleTypes?: PossibleTypesMap;
        typePolicies?: TypePolicies;
    });
    // (undocumented)
    addPossibleTypes(possibleTypes: PossibleTypesMap): void;
    // (undocumented)
    addTypePolicies(typePolicies: TypePolicies): void;
    // (undocumented)
    readonly cache: InMemoryCache;
    // (undocumented)
    fragmentMatches(fragment: InlineFragmentNode | FragmentDefinitionNode, typename: string | undefined, result?: Record<string, any>, variables?: Record<string, any>): boolean;
    // (undocumented)
    getMergeFunction(parentTypename: string | undefined, fieldName: string, childTypename: string | undefined): FieldMergeFunction | undefined;
    // (undocumented)
    getReadFunction(typename: string | undefined, fieldName: string): FieldReadFunction | undefined;
    // Warning: (ae-forgotten-export) The symbol "FieldSpecifier" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getStoreFieldName(fieldSpec: FieldSpecifier): string;
    // (undocumented)
    hasKeyArgs(typename: string | undefined, fieldName: string): boolean;
    // (undocumented)
    identify(object: StoreObject, partialContext?: Partial<KeyFieldsContext>): [string?, StoreObject?];
    // (undocumented)
    readField<V = StoreValue>(options: ReadFieldOptions, context: ReadMergeModifyContext): SafeReadonly<V> | undefined;
    // (undocumented)
    readonly rootIdsByTypename: Record<string, string>;
    // (undocumented)
    readonly rootTypenamesById: Record<string, string>;
    // (undocumented)
    runMergeFunction(existing: StoreValue, incoming: StoreValue, { field, typename, merge }: MergeInfo, context: WriteContext, storage?: StorageType): any;
    // (undocumented)
    readonly usingPossibleTypes = false;
}

// @public (undocumented)
export type PossibleTypesMap = {
    [supertype: string]: string[];
};

// @public (undocumented)
type ReactiveListener<T> = (value: T) => any;

// @public (undocumented)
export interface ReactiveVar<T> {
    // (undocumented)
    (newValue?: T): T;
    // (undocumented)
    attachCache(cache: ApolloCache_2): this;
    // (undocumented)
    forgetCache(cache: ApolloCache_2): boolean;
    // Warning: (ae-forgotten-export) The symbol "ReactiveListener" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    onNextChange(listener: ReactiveListener<T>): () => void;
}

// @public (undocumented)
interface ReadFieldFunction {
    // (undocumented)
    <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;
    // (undocumented)
    <V = StoreValue>(fieldName: string, from?: StoreObject | Reference): SafeReadonly<V> | undefined;
}

// @public (undocumented)
export interface ReadFieldOptions extends FieldSpecifier {
    // (undocumented)
    from?: StoreObject | Reference;
}

// @public (undocumented)
export interface ReadMergeModifyContext {
    // (undocumented)
    store: NormalizedCache;
    // (undocumented)
    variables?: OperationVariables;
    // (undocumented)
    varString?: string;
}

// @public (undocumented)
export type ReadQueryOptions = {
    store: NormalizedCache;
    query: DocumentNode;
    variables?: Object;
    previousResult?: any;
    rootId?: string;
    config?: ApolloReducerConfig;
};

export { Reference }

// @public (undocumented)
type SafeReadonly<T> = T extends object ? Readonly<T> : T;

// @public (undocumented)
type StorageType = Record<string, any>;

export { StoreObject }

// @public (undocumented)
type StoreObjectValueMaybeReference<StoreVal> = StoreVal extends Array<Record<string, any>> ? StoreVal extends Array<infer Item> ? [
Item
] extends [Record<string, any>] ? ReadonlyArray<AsStoreObject<Item> | Reference> : never : never : StoreVal extends Record<string, any> ? AsStoreObject<StoreVal> | Reference : StoreVal;

export { StoreValue }

// @public (undocumented)
class Stump extends Layer {
    constructor(root: EntityStore.Root);
    // (undocumented)
    merge(older: string | StoreObject, newer: string | StoreObject): void;
    // (undocumented)
    removeLayer(): this;
}

// @public (undocumented)
type ToReferenceFunction = (objOrIdOrRef: StoreObject | string | Reference, mergeIntoStore?: boolean) => Reference | undefined;

// @public (undocumented)
export type Transaction = (c: ApolloCache) => void;

// @public (undocumented)
export type TypePolicies = {
    [__typename: string]: TypePolicy;
};

// @public (undocumented)
export type TypePolicy = {
    keyFields?: KeySpecifier | KeyFieldsFunction | false;
    merge?: FieldMergeFunction | boolean;
    queryType?: true;
    mutationType?: true;
    subscriptionType?: true;
    fields?: {
        [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;
    };
};

// @public
export interface WatchFragmentOptions<TData, TVars> {
    fragment: DocumentNode | TypedDocumentNode_2<TData, TVars>;
    fragmentName?: string;
    from: StoreObject | Reference | FragmentType<NoInfer_2<TData>> | string;
    optimistic?: boolean;
    variables?: TVars;
}

// @public
export type WatchFragmentResult<TData> = {
    data: MaybeMasked<TData>;
    complete: true;
    missing?: never;
} | {
    data: DeepPartial<MaybeMasked<TData>>;
    complete: false;
    missing: MissingTree;
};

// @public (undocumented)
interface WriteContext extends ReadMergeModifyContext {
    // (undocumented)
    clientOnly: boolean;
    // (undocumented)
    deferred: boolean;
    // Warning: (ae-forgotten-export) The symbol "FlavorableWriteContext" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    flavors: Map<string, FlavorableWriteContext>;
    // (undocumented)
    readonly fragmentMap: FragmentMap;
    // (undocumented)
    incomingById: Map<string, {
        storeObject: StoreObject;
        mergeTree?: MergeTree;
        fieldNodeSet: Set<FieldNode>;
    }>;
    // (undocumented)
    lookupFragment: FragmentMapFunction;
    // (undocumented)
    merge<T>(existing: T, incoming: T): T;
    // (undocumented)
    overwrite: boolean;
    // (undocumented)
    readonly written: {
        [dataId: string]: SelectionSetNode[];
    };
}

// Warnings were encountered during analysis:
//
// src/cache/inmemory/policies.ts:166:3 - (ae-forgotten-export) The symbol "KeySpecifier" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/policies.ts:166:3 - (ae-forgotten-export) The symbol "KeyArgsFunction" needs to be exported by the entry point index.d.ts
// src/cache/inmemory/types.ts:133:3 - (ae-forgotten-export) The symbol "KeyFieldsFunction" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
