---
title: TypeScript with Apollo Client
descriptions: How to generate and use TypeScript types in your application
---

As your application grows, a type system can become an essential tool for catching bugs early and improving your overall developer experience.

GraphQL uses a type system to clearly define the available data for each type and field in a GraphQL schema. Given that a GraphQL server's schema is strongly typed, we can generate TypeScript definitions automatically using a tool like [GraphQL Code Generator](https://www.the-guild.dev/graphql/codegen). We'll use our generated types to ensure type safety for the _inputs_ and _results_ of our GraphQL operations.

We'll guide you through installing and configuring GraphQL Code Generator to generate types for your GraphQL operations.

## Setting up your project

Install the following packages. This installation assumes you already have [installed `@apollo/client` and its dependencies](../get-started#step-2-install-dependencies).

```bash
npm install -D @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations
```

Next, we'll create a configuration file for GraphQL Code Generator, named [`codegen.ts`](https://www.the-guild.dev/graphql/codegen/docs/config-reference/codegen-config), at the root of our project. The following is a recommended minimal configuration for Apollo Client apps.

```ts title="codegen.ts"
import { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
  overwrite: true,
  schema: "<URL_OF_YOUR_GRAPHQL_API>",
  // This assumes that all your source files are in a top-level `src/` directory - you might need to adjust this to your file structure
  documents: ["src/**/*.{ts,tsx}"],
  // Don't exit with non-zero status when there are no documents
  ignoreNoDocuments: true,
  generates: {
    // Use a path that works the best for the structure of your application
    "./src/types/__generated__/graphql.ts": {
      plugins: ["typescript", "typescript-operations"],
      config: {
        avoidOptionals: {
          // Use `null` for nullable fields instead of optionals
          field: true,
          // Allow nullable input fields to remain unspecified
          inputValue: false,
        },
        // Use `unknown` instead of `any` for unconfigured scalars
        defaultScalarType: "unknown",
        // Apollo Client always includes `__typename` fields
        nonOptionalTypename: true,
        // Apollo Client doesn't add the `__typename` field to root types so
        // don't generate a type for the `__typename` for root operation types.
        skipTypeNameForRoot: true,
      },
    },
  },
};

export default config;
```

<Note>

There are multiple ways to [specify a schema](https://www.the-guild.dev/graphql/codegen/docs/config-reference/schema-field#root-level) in your `codegen.ts`, so pick whichever way works best for your project setup.

</Note>

Finally, we'll add the script to our `package.json` file:

```json title="package.json"
{
  "scripts": {
    "codegen": "graphql-codegen --config codegen.ts"
  }
}
```

Running either of the scripts above generates types based on the schema file or GraphQL API you provided in `codegen.ts`:

```bash showLineNumbers=false
$ npm run codegen
✔ Parse Configuration
✔ Generate outputs
```

<Note>

If you follow GraphQL Codegen's [quickstart guide](https://the-guild.dev/graphql/codegen/docs/getting-started/installation), it recommends generating your config file using the GraphQL Code Generator CLI. This wizard installs and configures the [`@graphql-codegen/client-preset`](https://the-guild.dev/graphql/codegen/plugins/presets/preset-client).<br /><br />

We don't recommend using the client preset with Apollo Client apps because it generates some runtime code that adds additional bundle size to your app and includes some features that are incompatible with Apollo Client. We instead recommend using the [`typescript`](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript) and [`typescript-operations`](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-operations) plugins directly (at minimum) which focus on only generating types and doesn't include additional runtime code.<br /><br />

If you're already using the client preset, we recommend, at minimum, [disabling fragment masking](https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#how-to-disable-fragment-masking). See the guide on [data masking](../data/fragments#data-masking) for more information on using TypeScript with Apollo Client's data masking feature.

</Note>

## Using operation types

By default, Apollo Client sets the type of the `data` property as `unknown` type when the data type cannot be determined. This provides a layer of safety to avoid accessing properties on `data` that TypeScript doesn't know about.

The following example uses `gql` to create a GraphQL document for a query. The query is typed as a `DocumentNode` which doesn't provide type information about its data or variables.

```tsx
import { gql } from "@apollo/client";
import { useQuery } from "@apollo/client/react";

// This is of type `DocumentNode`
const GET_ROCKET_INVENTORY = gql`
  query GetRocketInventory {
    rocketInventory {
      id
      model
      year
      stock
    }
  }
`;

function RocketInventory() {
  const { data } = useQuery(GET_ROCKET_INVENTORY);
  //      ^? unknown

  return (
    <div>
      {/* ❌ TypeScript Error: 'data' is of type 'unknown'. */}
      {data.rocketInventory.map((rocket) => (
        <Rocket key={rocket.id} rocket={rocket} />
      ))}
    </div>
  );
}
```

This however makes it difficult to work with the `data` property. You either need to type cast each property on `data` to supress the error, or cast `data` as an `any` type (not recommended) which removes type safety entirely.

Instead, we can leverage the types generated by GraphQL Codegen along with `TypedDocumentNode` to provide types for GraphQL documents. `TypedDocumentNode` includes generic arguments for data and variables:

```ts
type QueryType = TypedDocumentNode<Data, Variables>;
```

Apollo Client allows for the use of `TypedDocumentNode` everywhere a `DocumentNode` is accepted. This enables Apollo Client APIs to infer the data and variable types using the GraphQL document.

The following updates the previous example to add types for the query using the types generated from GraphQL Codegen with `TypedDocumentNode`.

```tsx {2-5,7-10}
import { useQuery, TypedDocumentNode } from "@apollo/client";
import {
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables,
} from "@/types/__generated__/graphql";

const GET_ROCKET_INVENTORY: TypedDocumentNode<
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables
> = gql`
  query GetRocketInventory {
    rocketInventory {
      id
      model
      year
      stock
    }
  }
`;

function RocketInventory() {
  const { data } = useQuery(GET_ROCKET_INVENTORY);
  //      ^? GetRocketInventoryQuery | undefined

  // checks for loading and error states are omitted for brevity

  return (
    <div>
      {/* No more 'unknown' type error */}
      {data.rocketInventory.map((rocket) => (
        <Rocket key={rocket.id} rocket={rocket} />
      ))}
    </div>
  );
}
```

<Tip>

We recommend using `TypedDocumentNode` and relying on type inference throughout your application for your GraphQL operations instead of specifying the generic type arguments on Apollo Client APIs, such as `useQuery`. This makes GraphQL documents more portable and provides better type safety wherever the document is used.

<ExpansionPanel title="Example">

```ts
// ❌ Don't leave GraphQL documents as plain `DocumentNode`s
const query = gql`
  # ...
`;
// ❌ Don't provide generic arguments to Apollo Client APIs
const { data } = useQuery<QueryType, VariablesType>(query);

// ✅ Add the type for the GraphQL document with `TypedDocumentNode`
const query: TypedDocumentNode<QueryType, VariablesType> = gql`
  # ...
`;
const { data } = useQuery(query);
```

</ExpansionPanel>

</Tip>

<Tip>

We recommend that you always provide the variables type to `TypedDocumentNode`. GraphQL Codegen creates a variables type, even when the GraphQL operation doesn't define any variables. This ensures you don't provide variable values to your query which results in runtime errors from your GraphQL server. Additionally, this ensures that TypeScript catches errors when you update your query over time and include required variables.

</Tip>

### Type narrowing `data` with `dataState`

Throughout the lifecycle of your component, the value of `data` changes. `data` is influenced by several factors that affect its value such as different options or the query's current state.

Some examples of options that influence the value of `data` include:

- `returnPartialData` which might return partial data from the cache
- `errorPolicy` which affects the value of `data` when an error is returned
- `variables` which affects when the query is re-executed as variables change
- `fetchPolicy` which might provide a result from the cache
- `skip` which waits to execute the query

Some examples of the query state that influence the value of `data` include:

- The query is currently loading
- The query successfully loads its result
- The query returns partial data from the cache when `returnPartialData` is `true`
- The query returns an error
- The query is currently streaming additional data while using [`@defer`](../data/defer)

The combination of these states and options make it difficult to provide robust types for `data` based solely on the `loading` and `error` properties.

Apollo Client provides a `dataState` property for this purpose. `dataState` provides information about the completeness of the `data` property and includes type narrowing to give you better type safety without the need to add additional completeness checks.

The `dataState` property has the following values:

- `"empty"` - No data is available. `data` is `undefined`
- `"partial"` - Partial data is returned from the cache. `data` is `DeepPartial<TData>`
- `"streaming"` - Data from a deferred query is incomplete and still streaming. `data` is `TData`
- `"complete"` - Data fully satisfies the query. `data` is `TData`

The following demonstrates how `dataState` affects the type of `data`.

<Note>

This example uses `returnPartialData: true` to demonstrate the type of `data` when `dataState` is `partial`. When `returnPartialData` is `false` or omitted, `dataState` does not include the `partial` value and the type of `data` does not include `DeepPartial<TData>`.

</Note>

```tsx
const { data, dataState } = useQuery(GET_ROCKET_INVENTORY, {
  returnPartialData: true,
});

data;
// ^? GetRocketInventoryQuery | DeepPartial<GetRocketInventoryQuery> | undefined

if (dataState === "empty") {
  data;
  // ^? undefined
}

if (dataState === "partial") {
  data;
  // ^? DeepPartial<GetRocketInventoryQuery>
}

if (dataState === "streaming") {
  data;
  // ^? GetRocketInventoryQuery
}

if (dataState === "complete") {
  data;
  // ^? GetRocketInventoryQuery
}
```

<Note>

The type of `data` is the same when `dataState` is either `streaming` or `complete`. Additionally, `dataState` always includes `streaming` as a value, even when `@defer` is not used and isn't seen at runtime. This is because it is difficult to determine whether a query uses `@defer` based solely on the output format of the query type generated by GraphQL Codegen.<br/><br/>

If you use a type format that makes this possible, you can provide your own type implementations for the `complete` and `streaming` states to provide a corrected type. See the guide on [overriding types](#overriding-types) to learn how to provide your own type implementations.

</Note>

### Working with variables

When your GraphQL operations include variables, TypeScript ensures you provide all required variables with the correct types. Additionally, TypeScript ensures you omit variables that aren't included in the operation.

The following adds a non-null variable to the `GetRocketInventory` query used in previous examples.

```tsx {5-6}
const GET_ROCKET_INVENTORY: TypedDocumentNode<
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables
> = gql`
  query GetRocketInventory($year: Int!) {
    rocketInventory(year: $year) {
      id
      model
      year
      stock
    }
  }
`;

function RocketInventory() {
  // ❌ TypeScript Error: Expected 2 arguments, but got 1.
  const { data } = useQuery(GET_ROCKET_INVENTORY);

  // ❌ TypeScript Error: Property 'variables' is missing in type '{}'
  const { data } = useQuery(GET_ROCKET_INVENTORY, {});

  // ❌ TypeScript Error: Property 'year' is missing in type '{}'
  const { data } = useQuery(GET_ROCKET_INVENTORY, { variables: {} });

  // ✅ Correct: Required variable provided
  const { data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { year: 2024 },
  });

  // ❌ TypeScript Error: Type 'string' is not assignable to type 'number'
  const { data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { year: "2024" },
  });

  // ❌ TypeScript Error: 'notAVariable' does not exist in type '{ id: string }'
  const { data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { year: "2024", notAVariable: true },
  });
}
```

For operations with optional variables, TypeScript allows you to omit them:

```tsx
const GET_ROCKET_INVENTORY: TypedDocumentNode<
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables
> = gql`
  query GetRocketInventory($model: String, $year: Int) {
    rocketInventory(model: $model, year: $year) {
      id
      model
    }
  }
`;

function RocketInventory() {
  // ✅ All valid - all variables are optional
  const { data } = useQuery(GET_ROCKET_INVENTORY);

  // ✅ All valid - All variables satisfy the variables type
  const { data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { model: "Falcon" },
  });

  // ✅ All valid - All variables satisfy the variables type
  const { data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { year: 2024 },
  });

  // ✅ All valid - All variables satisfy the variables type
  const { data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { model: "Falcon", year: 2024 },
  });

  // ❌ TypeScript Error: 'notAVariable' does not exist in type '{ id: string }'
  const { data } = useQuery(GET_ROCKET_INVENTORY, {
    variables: { model: "Falcon", year: 2024, notAVariable: true },
  });
}
```

### Mutations

> For a more comprehensive guide on using mutations, see the [Mutations guide](../data/mutations).

Like `useQuery`, you provide `useMutation` a `TypedDocumentNode`. This adds the query type for the `data` property and ensures that `variables` are validated by TypeScript.

```tsx
import { gql, TypedDocumentNode } from "@apollo/client";
import { useMutation } from "@apollo/client/react";
import {
  SaveRocketMutation,
  SaveRocketMutationVariables,
} from "@/types/__generated__/graphql";

const SAVE_ROCKET: TypedDocumentNode<
  SaveRocketMutation,
  SaveRocketMutationVariables
> = gql`
  mutation SaveRocket($rocket: RocketInput!) {
    saveRocket(rocket: $rocket) {
      model
    }
  }
`;

export function NewRocketForm() {
  const [model, setModel] = useState("");
  const [year, setYear] = useState(0);
  const [stock, setStock] = useState(0);

  const [addRocket, { data }] = useMutation(SAVE_ROCKET, {
    //                ^? SaveRocketMutation | null | undefined
    variables: { rocket: { model, year, stock } },
  });

  return (
    <form>
      <p>
        <label>Model</label>
        <input name="model" onChange={(e) => setModel(e.target.value)} />
      </p>
      <p>
        <label>Year</label>
        <input
          type="number"
          name="year"
          onChange={(e) => setYear(+e.target.value)}
        />
      </p>
      <p>
        <label>Stock</label>
        <input
          type="number"
          name="stock"
          onChange={(e) => setStock(e.target.value)}
        />
      </p>
      <button onClick={() => addRocket()}>Add rocket</button>
    </form>
  );
}
```

<Note>

Unlike `useQuery`, `useMutation` doesn't provide a `dataState` property. `data` isn't tracked the same way as `useQuery` since its value is not read from the cache. The value of `data` is a set result of the last execution of the mutation.

</Note>

#### Using variables with `useMutation`

`useMutation` allows you to provide variables to either the hook or the mutate function returned in the result tuple. When variables are provided to both the hook and mutate function, they are shallowly merged (see the [Mutations guide](../data/mutations#option-precedence) for more information).

This behavior affects how TypeScript checks required variables with `useMutation`. Required variables must be provided to either the hook or the mutate function. If a required variable is not provided to the hook, the mutate function must include it. Required variables provided to the hook make them optional in the mutate function.

The following uses the previous example but flattens out the variable declarations to demonstrate how required variables affects TypeScript validation.

```tsx
const SAVE_ROCKET: TypedDocumentNode<
  SaveRocketMutation,
  SaveRocketMutationVariables
> = gql`
  mutation SaveRocket($model: String!, $year: Int!, $stock: Int) {
    saveRocket(rocket: { model: $model, year: $year, stock: $stock }) {
      model
    }
  }
`;

export function NewRocketForm() {
  // No required variables provided to the hook
  const [addRocket] = useMutation(SAVE_ROCKET);

  // ❌ TypeScript Error: Expected 1 argument, but got 0.
  addRocket();
  // ❌ TypeScript Error: Property 'variables' is missing in type '{}'
  addRocket({});
  // ❌ TypeScript Error: Type '{}' is missing the following properties from '{ year: number; model: string;, stock?: number }': model, year
  addRocket({ variables: {} });
  // ❌ TypeScript Error: Property 'year' is missing in type '{ model: string }'
  addRocket({ variables: { model: "Falcon" } });
  // ✅ Correct: All required variables provided
  addRocket({ variables: { model: "Falcon", year: 2025 } });
  // ❌ TypeScript Error: 'notAVariable' does not exist in type '{ year: number; model: string;, stock?: number }'
  addRocket({ variables: { model: "Falcon", year: 2025, notAVariable: true } });

  // Some required variables provided to the hook
  const [addRocket] = useMutation(SAVE_ROCKET, {
    variables: { model: "Falcon" },
  });

  // ❌ TypeScript Error: Expected 1 argument, but got 0.
  addRocket();
  // ❌ TypeScript Error: Property 'variables' is missing in type '{}'
  addRocket({});
  // ❌ TypeScript Error: Property 'year' is missing in type '{}'
  addRocket({ variables: {} });
  // ✅ Correct: All remaining required variables provided
  addRocket({ variables: { year: 2025 } });
  // ❌ TypeScript Error: 'notAVariable' does not exist in type '{ year: number; model?: string;, stock?: number }'
  addRocket({ variables: { year: 2025, notAVariable: true } });

  // All required variables provided to the hook
  const [addRocket] = useMutation(SAVE_ROCKET, {
    variables: { model: "Falcon", year: 2025 },
  });

  // ✅ Correct: All required variables are provided to the hook
  addRocket();
  // ✅ Correct: All required variables are provided to the hook
  addRocket({ variables: { stock: 10 } });
  // ❌ TypeScript Error: 'notAVariable' does not exist in type '{ year?: number; model?: string;, stock?: number }'
  addRocket({ variables: { notAVariable: true } });
}
```

### Subscriptions

> For a more comprehensive guide on using subscriptions, see the [Subscriptions guide](../data/subscriptions).

Like `useQuery`, you provide `useSubscription` a `TypedDocumentNode`. This adds the query type for the `data` property and ensures that `variables` are validated by TypeScript.

```tsx
import { gql, TypedDocumentNode } from "@apollo/client";
import { useSubscription } from "@apollo/client/react";
import {
  GetLatestNewsSubscription,
  GetLatestNewsSubscriptionVariables,
} from "@/types/__generated__/graphql";

const LATEST_NEWS: TypedDocumentNode<
  GetLatestNewsSubscription,
  GetLatestNewsSubscriptionVariables
> = gql`
  subscription GetLatestNews {
    latestNews {
      content
    }
  }
`;

export function LatestNews() {
  const { data } = useSubscription(LATEST_NEWS);
  //      ^? GetLatestNewsSubscription | undefined

  return (
    <div>
      <h5>Latest News</h5>
      <p>{data?.latestNews.content}</p>
    </div>
  );
}
```

Variables are validated the same as `useQuery`. See [working with variables](#working-with-variables) to learn more about how required variables are validated.

## Data masking

Learn more about integrating TypeScript with data masking in the [data masking docs](../data/fragments#using-with-typescript).

## Advanced GraphQL Codegen configuration

### Generating relative types files

As your application scales, a single types file that contains all operation types might become unwieldy. The [`near-operation-file-preset`](https://the-guild.dev/graphql/codegen/plugins/presets/near-operation-file-preset) makes it possible to generate an operation types file relative to the file where the operation is defined.

```bash
npm install -D @graphql-codegen/near-operation-file-preset
```

The following is a recommended minimal configuration. See the [`near-operation-file-preset` documentation](https://the-guild.dev/graphql/codegen/plugins/presets/near-operation-file-preset) for additional configuration options, such as customizing the file name or extension.

```ts title="codegen.ts"
import { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
  overwrite: true,
  schema: "<URL_OF_YOUR_GRAPHQL_API>",
  // This assumes that all your source files are in a top-level `src/` directory - you might need to adjust this to your file structure
  documents: ["src/**/*.{ts,tsx}"],
  // Don't exit with non-zero status when there are no documents
  ignoreNoDocuments: true,
  generates: {
    "./src/types/__generated__/graphql.ts": {
      plugins: ["typescript"],
    },
    "./src/": {
      preset: "near-operation-file",
      presetConfig: {
        // This should be the file generated by the "typescript" plugin above,
        // relative to the directory specified for this configuration
        baseTypesPath: "./types/__generated__/graphql.ts",
      },
      plugins: ["typescript-operations"],
      // Note: these config options moved from the other generated file config
      config: {
        avoidOptionals: {
          // Use `null` for nullable fields instead of optionals
          field: true,
          // Allow nullable input fields to remain unspecified
          inputValue: false,
        },
        // Use `unknown` instead of `any` for unconfigured scalars
        defaultScalarType: "unknown",
        // Apollo Client always includes `__typename` fields
        nonOptionalTypename: true,
        // Apollo Client doesn't add the `__typename` field to root types so
        // don't generate a type for the `__typename` for root operation types.
        skipTypeNameForRoot: true,
      },
    },
  },
};

export default config;
```

#### Usage

The following uses the example from the [`TypedDocumentNode` section](#using-typeddocumentnode).

```ts title="my-component.ts"
import { useQuery, TypedDocumentNode } from "@apollo/client/react";
// The query name and path might differ depending on your codegen config
import {
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables,
} from "./my-component.generated";

const GET_ROCKET_INVENTORY: TypedDocumentNode<
  GetRocketInventoryQuery,
  GetRocketInventoryQueryVariables
> = gql`
  query GetRocketInventory($year: Int!) {
    rocketInventory(year: $year) {
      id
      model
      year
      stock
    }
  }
`;

function MyComponent() {
  const { data } = useQuery(GET_ROCKET_INVENTORY);

  // `data` is properly typed!
}
```

### Generating precompiled GraphQL documents with their type definitions

The `gql` template literal tag is used in Apollo Client apps to define GraphQL documents for use with Apollo Client APIs. It's purpose is to parse the GraphQL string into a standard GraphQL AST. Parsing occurs when the module is executed which can add startup time to your application. Additionally, the GraphQL document returned by `gql` is typed as a `DocumentNode` which doesn't include type information about its data or variables.

The [`typed-document-node`](https://the-guild.dev/graphql/codegen/plugins/typescript/typed-document-node) plugin makes it possible to generate precompiled GraphQL documents preconfigured with [`TypedDocumentNode`](#using-typeddocumentnode).

```bash
npm install -D @graphql-codegen/typed-document-node
```

The following is a recommended minimal configuration which uses the `near-operation-file-preset` configuration from the previous section. If you don't use `near-operation-file-preset`, add the plugin to the file config that uses the `typescript-operations` plugin.

```ts {21} title="codegen.ts"
import { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
  overwrite: true,
  schema: "<URL_OF_YOUR_GRAPHQL_API>",
  // This assumes that all your source files are in a top-level `src/` directory - you might need to adjust this to your file structure
  documents: ["src/**/*.{ts,tsx}"],
  // Don't exit with non-zero status when there are no documents
  ignoreNoDocuments: true,
  generates: {
    "./src/types/__generated__/graphql.ts": {
      plugins: ["typescript"],
    },
    "./src/": {
      preset: "near-operation-file",
      presetConfig: {
        // This should be the file generated by the "typescript" plugin above,
        // relative to the directory specified for this configuration
        baseTypesPath: "./types/__generated__/graphql.ts",
      },
      plugins: ["typescript-operations", "typed-document-node"],
      // Note: these config options moved from the other generated file config
      config: {
        avoidOptionals: {
          // Use `null` for nullable fields instead of optionals
          field: true,
          // Allow nullable input fields to remain unspecified
          inputValue: false,
        },
        // Use `unknown` instead of `any` for unconfigured scalars
        defaultScalarType: "unknown",
        // Apollo Client always includes `__typename` fields
        nonOptionalTypename: true,
        // Apollo Client doesn't add the `__typename` field to root types so
        // don't generate a type for the `__typename` for root operation types.
        skipTypeNameForRoot: true,
      },
    },
  },
};

export default config;
```

<Note>

You might need to change the structure of your application to avoid bundling the query more than once in your application. If you author GraphQL documents using the `gql` template tag, you won't consume the returned GraphQL document since you'll import and use the precompiled document generated by this plugin instead.<br/><br/>

You may need to tweak your bundler settings to strip out unused variables from your bundle. Alternatively you can author GraphQL operations in `.graphql` files.

</Note>

#### Usage

The following uses the example from the [`TypedDocumentNode` section](#using-typeddocumentnode).

```ts title="my-component.ts"
import { useQuery } from "@apollo/client/react";
// The query name and path might differ depending on your codegen config
import { getRocketInventoryQuery } from "./my-component.generated";

function MyComponent() {
  const { data } = useQuery(getRocketInventoryQuery);

  // `data` is properly typed!
}
```
